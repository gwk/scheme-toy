(test (procedure? (lambda (x) x)) #t)
(test ((lambda (x) (+ x x)) 4) 8)
(test (let ((reverse-subtract (lambda (x y) (- y x)))) (reverse-subtract 7 10)) 3)
(test (let ((add4 (let ((x 4)) (lambda (y) (+ x y))))) (add4 6)) 10)
(test ((lambda x x) 3 4 5 6) (list 3 4 5 6))
(test ((lambda (x y . z) z) 3 4 5 6) (list 5 6))
(test ((lambda (a b c d e f) (+ a b c d e f)) 1 2 3 4 5 6) 21)
(test (let ((foo (lambda () 9))) (+ (foo) 1)) 10)
(test (let ((a 1)) (let ((f (lambda (x) (set! a x) a))) (let ((c (f 123))) (list c a)))) (list 123 123))
(test (let ((a 1) (b (lambda (a) a))) (b 3)) 3)
(test (let ((ctr 0)) (letrec ((f (lambda (x) (if (> x 0) (begin (set! ctr (+ ctr 1)) (f (- x 1))) 0)))) (f 10) ctr)) 10)
(test (let ((f (lambda (x) (car x)))) (f '(4 5 6))) 4)
(test ((lambda () ((lambda (x y) ((lambda (z) (* (car z) (cdr z))) (cons x y))) 3 4))) 12)
(test (let ((ctr 0)) (define (f) (set! ctr (+ ctr 1)) ctr) (let ((x (f))) (let ((y (f))) (list x y ctr)))) (list 1 2 2))

(test (let ((x 5)) (define foo (lambda (y) (bar x y))) (define bar (lambda (a b) (+ (* a b) a))) (foo (+ x 3))) 45)
(test (let ((x 5)) (letrec ((foo (lambda (y) (bar x y))) (bar (lambda (a b) (+ (* a b) a)))) (foo (+ x 3)))) 45)

(num-test (let () (define compose (lambda (f g) (lambda args (f (apply g args))))) ((compose sqrt *) 12 75))  30.0)
(let ()
  (define (compose . args) ; this just removes parens
    (if (procedure? (car args))
	(if (null? (cdr args))
	    ((car args))
	    ((car args) (apply compose (cdr args))))
	(apply values args)))
  (test (compose - + (lambda (a b c) (values a (* b c))) 2 3 4) -14)
  (test (- (+ ((lambda (a b c) (values a (* b c))) 2 3 4))) -14)) ; I prefer this

(test (let ((f (lambda () (lambda (x y) (+ x y))))) ((f) 1 2)) 3)
(test ((lambda (x) (define y 4) (+ x y)) 1) 5)
(test ((lambda(x)(define y 4)(+ x y))1) 5)
(test ((lambda () (define (y x) (+ x 1)) (y 1))) 2)
(test ((lambda (x) 123 (let ((a (+ x 1))) a)) 2) 3)
(test ((lambda (x) "documentation" (let ((a (+ x 1))) a)) 2) 3)
(test ((lambda (x) (x 1)) (lambda (y) (+ y 1))) 2)
(test (let ((a 1)) (let ((b (lambda (x) (define y 1) (define z 2) (define a 3) (+ x y z a)))) (b a))) 7)
(test ((lambda (f x) (f x x)) + 11) 22)
(test ((lambda () (+ 2 3))) 5)
(test (let ((x (let () (lambda () (+ 1 2))))) (x)) 3)
(test (cond (0 => (lambda (x) x))) 0)
(test ((lambda () "hiho")) "hiho")
(test ((lambda()()))())
(test (procedure-source (apply lambda (list) (list (list)))) '(lambda () ()))

(test (letrec ((f (lambda (x) (g x)))
	       (g (lambda (x) x)))
	(let ((top (f 1)))
	  (set! g (lambda (x) (- x)))
	  (+ top (f 1))))
      0)

(for-each
 (lambda (arg)
   (test ((lambda (x) x) arg) arg))
 (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))

(let ((list-length
       (lambda (obj)
	 (call-with-current-continuation
	  (lambda (return)
	    (letrec ((r (lambda (obj) (cond ((null? obj) 0)
					    ((pair? obj) (+ (r (cdr obj)) 1))
					    (else (return #f))))))
	      (r obj)))))))
  (test (list-length '(1 2 3 4)) 4)
  (test (list-length '(a b . c)) #f))

(test (let ((samples (vector 0 1 2 3 4 5 6 7 8 9 10)))
	(let ((make-scaler 
	       (lambda (start end)
		 (letrec ((ctr start)
			  (us (lambda (them)
				(vector-set! samples ctr (* 2 (vector-ref samples ctr)))
				(set! ctr (+ ctr 2))
				(if (<= ctr end)
				    (them us)))))
		   us))))
	  ((make-scaler 0 11)
	   (make-scaler 1 11))) 
	samples)
      (vector 0 2 4 6 8 10 12 14 16 18 20))

(test ((lambda (x . y) y) 1 2 '(3 . 4)) '(2 (3 . 4)))
(test ((lambda (x . y) y) 1) '())
(test ((lambda x x) '()) '(()))
(test ((lambda x x)) '())
(test ((lambda (x) x) '()) '())
(test ((lambda (x) (+ x ((lambda (x) (+ x 1)) 2))) 3) 6)
(test ((lambda (x) (define y 1) (+ x y)) 2) 3)
(test ((lambda (a) "this is a doc string" a) 1) 1)
;;; ideally ((lambda (a) "hiho" (define x 1) x) 1) -> 1 but I'm not sure it's r5rs-ish
(test (let ((g (lambda () '3))) (= (g) 3)) #t)
(test ((((lambda () lambda)) () 1)) 1)

(test (let () ; PLP Scott p168
	(define A
	  (lambda ()
	    (let* ((x 2)
		   (C (lambda (P)
			(let ((x 4))
			  (P))))
		   (D (lambda ()
			x))
		   (B (lambda ()
			(let ((x 3))
			  (C D)))))
	      (B))))
	(A))
      2)

#|
;;; here s7 "do" uses set!
(test (let ((funcs (make-vector 3 #f)))
	(do ((i 0 (+ i 1)))
	    ((= i 3))
	  (vector-set! funcs i (lambda () (+ i 1))))
	(+ ((vector-ref funcs 0))
	   ((vector-ref funcs 1))
	   ((vector-ref funcs 2))))
      6)
|#

;;; the equivalent named let version:
(test (let ((funcs (make-vector 3 #f)))
	(let loop ((i 0))
	  (if (< i 3)
	      (begin
		(vector-set! funcs i (lambda () (+ i 1)))
		(loop (+ i 1)))))
	(+ ((vector-ref funcs 0))
	   ((vector-ref funcs 1))
	   ((vector-ref funcs 2))))
      6)

(test (let ((i 1))
	(let ((func1 (lambda () i)))
	  (let ((i 2))
	    (let ((func2 (lambda () i)))
	      (+ (func1) (func2))))))
      3)

(test (let ((funcs (make-vector 3 #f)))
	(map
	 (lambda (i)
	   (vector-set! funcs i (lambda () (+ i 1))))
	 (list 0 1 2))
	(+ ((vector-ref funcs 0))
	   ((vector-ref funcs 1))
	   ((vector-ref funcs 2))))
      6)

(test (let ((funcs (make-vector 3 #f)))
	(for-each
	 (lambda (i)
	   (vector-set! funcs i (lambda () (+ i 1))))
	 (list 0 1 2))
	(+ ((vector-ref funcs 0))
	   ((vector-ref funcs 1))
	   ((vector-ref funcs 2))))
      6)

(test (let ((funcs (make-vector 3 #f)))
	(sort! (list 0 1 2)
	 (lambda (i j)
	   (vector-set! funcs i (lambda () (+ i 1))) 
	   (> i j)))
	(+ ((vector-ref funcs 0))
	   ((vector-ref funcs 1))
	   ((vector-ref funcs 2))))
      6)

(test (let ((funcs (make-vector 3 #f)))
	(member 4 (list 0 1 2)
	 (lambda (j i)
	   (vector-set! funcs i (lambda () (+ i 1)))
	   #f))
	(+ ((vector-ref funcs 0))
	   ((vector-ref funcs 1))
	   ((vector-ref funcs 2))))
      6)

(test (let ((funcs (make-vector 3 #f)))
	(assoc 4 (list (cons 0 0) (cons 1 0) (cons 2 0))
	 (lambda (j i) 
	   (vector-set! funcs i (lambda () (+ i 1)))
	   #f))
	(+ ((vector-ref funcs 0))
	   ((vector-ref funcs 1))
	   ((vector-ref funcs 2))))
      6)

(test (let ((func #f))
	(define (func1 x)
	  (set! func (lambda () (+ x 1))))
	(func1 1)
	(+ (func)
	   (let ()
	     (func1 2)
	     (func))))
      5)

(test (((lambda (x) (lambda () (+ x 1))) 32)) 33)

(test (let ((func #f))
	(define (func1 x)
	  (set! func (lambda () (string-append x "-"))))
	(func1 "hi")
	(string-append (func)
		       (let ()
			 (func1 "ho")
			 (func))))
      "hi-ho-")

(test (let ((func1 #f)
	    (func2 #f))
	(let ((x 1))
	  (set! func1 (lambda () x))
	  (set! func2 (lambda (y) (set! x y) y)))
	(+ (func1)
	   (let ()
	     (func2 32)
	     (func1))))
      33)

(test (let ((funcs (make-vector 3)))
	(let ((hi (lambda (a) (vector-set! funcs (- a 1) (lambda () a)))))
	  (hi 1) (hi 2) (hi 3)
	  (+ ((vector-ref funcs 0))
	     ((vector-ref funcs 1))
	     ((vector-ref funcs 2)))))
      6)

(test (let ((hi (lambda (a) (+ a 1)))
	    (ho (lambda (a) (a 32))))
	(+ (hi (hi (hi 1)))
	   (ho hi)))
      37)

(test (let ((x 0)
	    (b 4)
	    (f1 #f)
	    (f2 #f))
	(let ((x 1))
	  (let ((x 2))
	    (set! f1 (lambda (a) (+ a b x)))))
	(let ((x 3))
	  (let ((b 5))
	    (set! f2 (lambda (a) (+ a b x)))))
	(+ (f1 10) (f2 100)))  ; (+ 10 4 2) (+ 100 5 3)
      124)

(test ((if (> 3 2) + -) 3 2) 5)
(test (let ((op +)) (op 3 2)) 5)
(test (((lambda () +)) 3 2) 5)
(test ((car (cons + -)) 3 2) 5)
(test ((do ((i 0 (+ i 1))) ((= i 3) +) ) 3 2) 5)
(test (((lambda (x) x) (lambda (x) x)) 3) 3)
(test ((((lambda (x) x) (lambda (x) x)) (lambda (x) x)) 3) 3)
(test (((lambda (x) (lambda (y) x)) 3) 4) 3)
(test (((lambda (x) (lambda (x) x)) 3) 4) 4)
(test (let ((x 32)) (((lambda (x) (lambda (y) x)) 3) x)) 3)
(test ((call/cc (lambda (return) (return +))) 3 2) 5)
(test ((call-with-values (lambda () (values +)) (lambda (x) x)) 3 2) 5)
(test ((case '+ ((+) +)) 3 2) 5)
(test ((case '+ ((-) -) (else +)) 3 2) 5)
(test ((call/cc (lambda (return) (dynamic-wind (lambda () #f) (lambda () (return +)) (lambda () #f)))) 3 2) 5)
(test (+ 1 ((call/cc (lambda (return) (dynamic-wind (lambda () #f) (lambda () (return +)) (lambda () #f)))) 3 2) 2) 8)
(test (let ((lst (list + -))) ((car lst) 1 2 3)) 6)
(test (let ((a +)) ((let ((b -)) (if (eq? a b) a *)) 2 3)) 6)
(test ((list-ref (list + - * /) 0) 2 3) 5)
(test (((if #t list-ref oops) (list + - * /) 0) 2 3) 5)
(test ((((car (list car cdr)) (list car cdr)) (list + -)) 2 3) 5)
(test (let ()
	(define function lambda)
	(define hiho (function (a) (+ a 1)))
	(hiho 2))
      3)
(test ((lambda (a b c d e f g h i j k l m n o p q r s t u v x y z)
	 (+ a b c d e f g h i j k l m n o p q r s t u v x y z))
       1 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 21 22 23 24 25 26 27)
      348)
(test ((lambda (x) "a useless string" x) 32) 32)
(test ((lambda (>< =0=? .arg.) (+ >< =0=? .arg.)) 1 2 3) 6)
(test ((apply ((lambda () lambda)) ((lambda () (list 'a))) ((lambda () '((+ a 1))))) 3) 4)

(test
 (let ()
   (begin
     (define f1 #f)
     (define f2 #f)
     (let ((lv 32))
       (set! f1 (lambda (a) (+ a lv)))
       (set! f2 (lambda (a) (- a lv)))))
   (+ (f1 1) (f2 1)))
 2)

(test ((lambda () => abs)) 'error)
(test ((lambda () => => 3)) 'error)
;; actually, both Guile and Gauche accept
;; ((lambda () + 3)) and (begin + 3)
;; but surely => is an undefined variable in this context?

(test (lambda) 'error)
(test (lambda (a) ) 'error)
;; should this be an error: (lambda (a) (define x 1)) ?
(test (lambda . 1) 'error)
(test ((lambda . (x 1))) 1)
(test ((lambda . ((x . y) 2)) 1) 2)
(test ((lambda (x) . (x)) 1) 1)
(test ((lambda . ((x) . (x))) 1) 1)
(test ((lambda . (x . (x))) 1) '(1))
(test ((lambda . ((x . ()) x)) 1) 1)
(test (eval-string "((lambda . (x 1 . 3)) 1)") 'error)

(test (lambda 1) 'error)
(test (lambda (x 1) x) 'error)
(test (lambda "hi" 1) 'error)
(test (lambda (x x) x) 'error)
(test ((lambda (x x) x) 1 2) 'error) 
(test (lambda (x "a")) 'error)
(test ((lambda (x y) (+ x y a)) 1 2) 'error)
(test ((lambda ())) 'error)
(test (lambda (x (y)) x) 'error)
(test ((lambda (x) x . 5) 2) 'error)
(test (lambda (1) #f) 'error)
(test (eval-string "(lambda (x . y z) x)") 'error) 
(test ((lambda () 1) 1) 'error)
(test ((lambda (()) 1) 1) 'error)
(test ((lambda (x) x) 1 2) 'error)
(test ((lambda (x) x)) 'error)
(test ((lambda ("x") x)) 'error)
(test ((lambda "x" x)) 'error)
(test ((lambda (x . "hi") x)) 'error)
(test (lambda ((:hi . "hi") . "hi") 1) 'error)
(test ((lambda (x) (* quote ((x . 1) . 2))) 1) 'error)

(test (let ((hi (lambda (a 0.0) (b 0.0) (+ a b)))) (hi)) 'error)
(test (object->string
       ((lambda (arg)
	  (list arg
		(list (quote quote)
		      arg)))
	(quote (lambda (arg)
		 (list arg
		       (list (quote quote)
			     arg))))))
      "(#1=(lambda (arg) (list arg (list 'quote arg))) '#1#)")
      
(test ((apply lambda '((a) (+ a 1))) 2) 3)
(test ((apply lambda '(() #f))) #f)
(test ((apply lambda '(arg arg)) 3) '(3))
(test ((apply lambda* '((a (b 1)) (+ a b))) 3 4) 7)
(test ((apply lambda* '((a (b 1)) (+ a b))) 3) 4)

(let ()
  (define-macro (progv vars vals . body)
    `(apply (apply lambda ,vars ',body) ,vals))
  (test (let ((s '(one two)) (v '(1 2))) (progv s v (+ one two))) 3)
  (test (progv '(one two) '(1 2) (+ one two)) 3))


(test (lambda #(a b) a) 'error)
(test (lambda* (#(a 1)) a) 'error)

(test ((lambda (a) a) #<eof>) #<eof>)
(test ((lambda () (let ((a #<undefined>)) a))) #<undefined>)
