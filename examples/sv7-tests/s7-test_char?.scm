(test (char? #\a) #t)
(test (char? #\() #t)
(test (char? #\space) #t)
(test (char? '#\newline) #t)
(test (char? #\1) #t)
(test (char? #\$) #t)
(test (char? #\.) #t)
(test (char? #\\) #t)
(test (char? #\)) #t)
(test (char? #\%) #t)
(test (char? '#\space) #t)
(test (char? '#\ ) #t)
(test (char? '#\newline) #t)
(test (char? '#\a) #t)
(test (char? '#\8) #t)
(test (char? #\-) #t)
(test (char? #\n) #t)
(test (char? #\() #t)
(test (char? #e1) #f)
(test (char? #\#) #t)
(test (char? #\x) #t)
(test (char? #\o) #t)
(test (char? #\b) #t)
(test (char? #b101) #f)
(test (char? #o73) #f)
(test (char? #x73) #f)
(test (char? 'a) #f)
(test (char? 97) #f)
(test (char? "a") #f)
(test (char? (string-ref "hi" 0)) #t)
(test (char? (string-ref (make-string 1) 0)) #t)
(test (char? #\") #t)
(test (char? #\') #t)
(test (char? #\`) #t)
(test (char? #\@) #t)
(test (char? #<eof>) #f)
(test (char? '1e311) #f)

(for-each
 (lambda (arg)
   (if (char? arg)
       (format #t ";(char? ~A) -> #t?~%" arg)))
 (list "hi" '() (list 1) '(1 . 2) #f 'a-symbol (make-vector 3) abs _ht_ quasiquote macroexpand 1/0 (log 0) 
       3.14 3/4 1.0+1.0i #f #t (if #f #f) :hi (lambda (a) (+ a 1))))

(test (char? begin) #f)

(do ((i 0 (+ i 1)))
    ((= i 256))
  (if (not (char? (integer->char i)))
      (format #t ";(char? (integer->char ~A)) -> #f?~%" i)))

(test (char?) 'error)
(test (char? #\a #\b) 'error)
(test (char #\a) 'error)

(test (char? #\x65) #t)
(test (char? #\x000000000065) #t)
(test (char? #\x0) #t)
(test (char=? #\x000 #\null) #t)
(test (char=? #\x08 #\x8) #t)
(test (char=? #\x0e #\xe) #t) ; Guile thinks both of these names are bogus
(test (char=? #\x00e #\xe) #t)
(test (char=? #\x0000e #\xe) #t)
(test (char=? #\x00000000e #\xe) #t) ; hmmm -- surely this is a bug
(test (char? #\xff) #t)
;; any larger number is a reader error

(test (eval-string "(char? #\xbdca2cbec)") 'error) ; this can overflow internally!
(test (eval-string "(char? #\\x#b0)") 'error)
(test (eval-string "(char? #\\100)") 'error)
(test (eval-string "(char? #\\x-65)") 'error)
(test (eval-string "(char? #\\x6.5)") 'error)
(test (eval-string "(char? #\\x6/5)") 'error)
(test (eval-string "(char? #\\x6/3)") 'error)
(test (eval-string "(char? #\\x6+i)") 'error)
(test (eval-string "(char? #\\x6asd)") 'error)
(test (eval-string "(char? #\\x6#)") 'error)
(test (eval-string "(char? #\\x#b0") 'error)
(test (eval-string "(char? #\\x#e0.0") 'error)
(test (eval-string "(char? #\\x-0") 'error)
(test (eval-string "(char? #\\x#e0e100") 'error)
(test (eval-string "(char? #\\x1.4") 'error)

(test (char=? #\x6a #\j) #t)

(test (char? #\return) #t)
(test (char? #\null) #t)
(test (char? #\nul) #t)
(test (char? #\linefeed) #t)
(test (char? #\tab) #t)
(test (char? #\space) #t)
(test (char=? #\null #\nul) #t)
(test (char=? #\newline #\linefeed) #t)
(test (char=? #\return #\xd) #t)
(test (char=? #\nul #\x0) #t)
;(test (char? #\Ã¿) #t) ; this seems to involve unwanted translations in emacs?
(test (eval-string (string-append "(char? " (format #f "#\\~C" (integer->char 255)) ")")) #t)
(test (eval-string (string-append "(char? " (format #f "#\\~C" (integer->char 127)) ")")) #t)
(test (apply char? (list (integer->char 255))) #t)

(test (char? #\escape) #t)
(test (char? #\alarm) #t)
(test (char? #\backspace) #t)
(test (char? #\delete) #t)
(test (char=? #\delete #\backspace) #f)

(num-test (let ((str (make-string 258 #\space)))
	    (do ((i 1 (+ i 1)))
		((= i 256))
	      (string-set! str i (integer->char i)))
	    (string-set! str 257 (integer->char 0))
	    (string-length str))
	  258)


(let ((a-to-z (list #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\x #\y #\z))
      (cap-a-to-z (list #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\X #\Y #\Z))
      (mixed-a-to-z (list #\a #\B #\c #\D #\e #\F #\g #\H #\I #\j #\K #\L #\m #\n #\O #\p #\Q #\R #\s #\t #\U #\v #\X #\y #\Z))
      (digits (list #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))
