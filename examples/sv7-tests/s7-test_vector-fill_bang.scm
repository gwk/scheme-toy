(test (fill! (vector 1 2) 4) 4)

(test (let ((v (vector 1 2 3))) (vector-fill! v 0) v) '#(0 0 0))
(test (let ((v (vector))) (vector-fill! v #f) v) '#())
(let ((v (make-vector 8 #f)))
  (for-each
   (lambda (arg)
     (vector-fill! v arg)
     (test (vector-ref v 1) arg))
   (list #\a 1 () (list 1) '(1 . 2) #f "hi" 'a-symbol abs _ht_ quasiquote macroexpand (log 0) 
	 3.14 3/4 1.0+1.0i #t (vector 1 2 3) (lambda (a) (+ a 1)))))

(test (let ((str "hi") (v (make-vector 3))) (vector-fill! v str) (string-set! (vector-ref v 0) 1 #\a) str) "ha")
(test (let ((lst (list 1 2)) (v (make-vector 3))) (vector-fill! v lst) (list-set! (vector-ref v 0) 1 #\a) lst) '(1 #\a))

(test (let ((v (vector 1 2 3))) (vector-set! v -1 0)) 'error)
(test (let ((v (vector 1 2 3))) (vector-set! v 3 0)) 'error)
(test (vector-fill! '#(1 2) 2) 2)
(test (vector-fill! #() 0) 0)
(test (vector-fill! (vector) 0) 0)
(test (let ((v (vector 1))) (vector-fill! v 32) (v 0)) 32)
(test (let ((v (make-vector 11 0))) (vector-fill! v 32) (v 10)) 32)
(test (let ((v (make-vector 16 0))) (vector-fill! v 32) (v 15)) 32)
(test (let ((v (make-vector 3 0))) (vector-fill! v 32) (v 1)) 32)
(test (let ((v (make-vector 3 0))) (fill! v 32) (v 1)) 32)
(test (let ((v #2d((1 2 3) (4 5 6)))) (vector-fill! (v 1) 12) v) #2D((1 2 3) (12 12 12)))

(for-each
 (lambda (arg)
   (test (vector-fill! arg 0) 'error))
 (list "hi" #\a '() 1 '(1 . 2) (cons #\a #\b) #f 'a-symbol abs _ht_ quasiquote macroexpand 1/0 (log 0) 
       3.14 3/4 1.0+1.0i #t :hi (if #f #f) (lambda (a) (+ a 1))))

(if with-bignums
    (let ((v (make-vector 2 0.0)))
      (vector-fill! v 1180591620717411303424)
      (num-test (v 1) (expt 2 70))
      (vector-fill! v 3/1180591620717411303424)
      (num-test (v 0) 3/1180591620717411303424)
      (vector-fill! v 1180591620717411303424.0)
      (num-test (v 1) 1180591620717411303424.0)
      (vector-fill! v (make-rectangular (expt 2 70) 1.0))
      (num-test (v 0) (make-rectangular (expt 2 70) 1.0))))

(let ((v (make-vector 3)))
  (vector-fill! v v)
  (test (v 0) v)
  (set! (v 1) 32)
  (test ((v 0) 1) 32))
  

(test (let ((sum 0)) (for-each (lambda (n) (set! sum (+ sum n))) (vector 1 2 3)) sum) 6)
(test (let ((sum 0)) (for-each (lambda (n m) (set! sum (+ sum n (- m)))) (vector 1 2 3) (vector 4 5 6)) sum) -9)
(test (let () (for-each (lambda (n) (error "oops")) (vector)) #f) #f)
(test (let ((sum 0)) (for-each (lambda (n m p) (set! sum (+ sum n (- m) (* 2 p)))) (vector 1 2 3) (vector 4 5 6) (vector 6 7 8)) sum) 33)
(test (let ((sum 0)) (for-each (lambda (n) (for-each (lambda (m) (set! sum (+ sum (* m n)))) (vector 1 2 3))) (vector 4 5 6)) sum) 90)
(test (call/cc (lambda (return) (for-each (lambda (n) (return "oops")) (vector 1 2 3)))) "oops")
(test (call/cc (lambda (return) (for-each (lambda (n) (if (even? n) (return n))) (vector 1 3 8 7 9 10)))) 8)

(for-each
 (lambda (data)
   (let ((v data)
	 (c #f)
	 (y 0))
     
     (do ((i 0 (+ i 1)))
	 ((= i 10))
       (set! (v i) i))
     
     (let ((tag 
	    (call/cc
	     (lambda (exit)
	       
	       (for-each
		(lambda (x)
		  
		  (call/cc
		   (lambda (return)
		     (set! c return)))
		  
		  (if (and (even? (inexact->exact x))
			   (> x y) 
			   (< x 10)) 
		      (begin 
			(set! (v (inexact->exact y)) 100)
			(set! y x) 
			(exit x))
		      (set! y x)))
		v)))))
       
       (if (and (number? tag) (< tag 10))
	   (c)))
     
     (let ((correct (vector 0 100 2 100 4 100 6 100 8 9)))
       (do ((i 0 (+ i 1)))
	   ((= i (length v)))
	 (if (not (= (correct i) (inexact->exact (v i))))
	     (format #t ";for-each call/cc data: ~A~%" v))))))
 
 (list (make-vector 10)
;       (make-vct 10)
       (make-list 10)))


(test (map (lambda (n) (+ 1 n)) (vector 1 2 3)) '(2 3 4))
(test (map (lambda (n m) (- n m)) (vector 1 2 3) (vector 4 5 6)) '(-3 -3 -3))
(test (map (lambda (n m p) (+ n m p)) (vector 1 2 3) (vector 4 5 6) (vector 6 7 8)) '(11 14 17))
(test (map (lambda (n) (map (lambda (m) (* m n)) (vector 1 2 3))) (vector 4 5 6)) '((4 8 12) (5 10 15) (6 12 18)))
(test (call/cc (lambda (return) (map (lambda (n) (return "oops")) (vector 1 2 3)))) "oops")
(test (call/cc (lambda (return) (map (lambda (n) (if (even? n) (return n))) (vector 1 3 8 7 9 10)))) 8)


(test (vector? (symbol-table)) #t)
(let* ((st (symbol-table))
       (len (length st))
       (loc -1))
  (do ((i 0 (+ i 1)))
      ((or (>= loc 0) 
	   (= i len)))
    (if (pair? (st i))
	(set! loc i)))
  (if (>= loc 0)
      (begin
	(test (symbol? (((symbol-table) loc) 0)) #t)
	(let ((old-table (symbol-table))
	      (old-list ((symbol-table) loc)))
	  ;; try to clobber it...
	  (vector-fill! (symbol-table) #())
	  (set! ((symbol-table) loc) 1)
	  (test (list? ((symbol-table) loc)) #t)
	  (test (symbol? (((symbol-table) loc) 0)) #t)
	  (test (equal? old-list ((symbol-table) loc)) #t)))))

(let ((v (make-vector 3 (vector 1 2))))
  (test (equal? (v 0) (v 1)) #t)
  (test (eq? (v 0) (v 1)) #t)
  (test (eqv? (v 0) (v 1)) #t))

(let ((v (vector (vector 1 2) (vector 1 2) (vector 1 2))))
  (test (equal? (v 0) (v 1)) #t)
  (test (eq? (v 0) (v 1)) #f)
  (test (eqv? (v 0) (v 1)) #f))

(let ((v (vector (vector (vector (vector 1 2) 3) 4) 5)))
  (test (v 0) #(#(#(1 2) 3) 4))
  (test (v 1) 5)
  (test (((v 0) 0) 1) 3)
  (test ((((v 0) 0) 0) 1) 2))

(test (make-vector 1 (make-vector 1 (make-vector 1 0))) #(#(#(0))))


(let ((v1 (make-vector 3 1)))
  (num-test (v1 1) 1)
  (set! (v1 1) 2)
  (num-test (v1 1) 2)
  (let ((i0 0)
	(i2 2))
    (num-test (v1 i0) 1)
    (num-test (vector-ref v1 i2) 1)
    (set! (v1 i0) 0)
    (num-test (v1 0) 0)
    (set! (v1 i0) i2)
    (num-test (v1 i0) i2))
  (test (vector-dimensions v1) '(3))
  (set! v1 (make-vector '(3 2)))
  (test (vector-dimensions v1) '(3 2))
  (vector-set! v1 1 1 0)
  (num-test (vector-ref v1 1 1) 0)
  (let ((i0 1)
	(i1 1)
	(i2 32))
    (set! (v1 i0 i1) i2)
    (num-test (vector-ref v1 1 1) 32)
    (num-test (v1 i0 i1) i2)
    (vector-set! v1 0 1 3)
    (num-test (v1 0 1) 3)
    (num-test (v1 1 1) 32))
  (set! v1 (make-vector '(2 4 3) 1))
  (test (vector-dimensions v1) '(2 4 3))      
  (num-test (vector-ref v1 1 1 1) 1)
  (vector-set! v1 0 0 0 32)
  (num-test (v1 0 0 0) 32)
  (set! (v1 0 1 1) 3)
  (num-test (v1 0 1 1) 3))

(for-each
 (lambda (arg)
   (test (vector-dimensions arg) 'error))
 (list "hi" -1 0 #\a 'a-symbol '(1 . 2) '(1 2 3) 3.14 3/4 1.0+1.0i #t abs #<eof> #<unspecified> (lambda () 1)))
(test (vector-dimensions) 'error)
(test (vector-dimensions #() #()) 'error)
(test (vector-dimensions #()) '(0))
(test (vector-dimensions (vector)) '(0))
(test (vector-dimensions (vector 0)) '(1))
(test (vector-dimensions (vector-ref #2d((1 2 3) (3 4 5)) 0)) '(3))
(test (vector-dimensions (vector-ref #3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 2))) 0)) '(2 3))
(test (vector-dimensions (vector-ref #3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 2))) 0 1)) '(3))
(test (set! (vector-dimensions #(1 2)) 1) 'error)
(test (let ((v #(1 2 3))) (set! (car (vector-dimensions v)) 0) v) #(1 2 3))

(let ((old-len *vector-print-length*))
  (let ((vect1 #3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 2))))
	(vect2 #2d((1 2 3 4 5 6) (7 8 9 10 11 12)))
	(vect3 #(1 2 3 4 5 6 7 8 9 10 11 12 13 14))
	(vect4 #3D(((1 2) (3 4) (5 6)) ((7 8) (9 10) (11 12)))))
    (do ((i 1 (+ i 1)))
	((= i 15))
      (set! *vector-print-length* i)
      (let ((str (object->string vect1)))
	(test str (case i
		    ((1) "#3D(((1 ...)...)...)")
		    ((2) "#3D(((1 2 ...)...)...)")
		    ((3) "#3D(((1 2 3)...)...)")
		    ((4) "#3D(((1 2 3) (3 ...))...)")
		    ((5) "#3D(((1 2 3) (3 4 ...))...)")
		    ((6) "#3D(((1 2 3) (3 4 5))...)")
		    ((7) "#3D(((1 2 3) (3 4 5)) ((5 ...)...))")
		    ((8) "#3D(((1 2 3) (3 4 5)) ((5 6 ...)...))")
		    ((9) "#3D(((1 2 3) (3 4 5)) ((5 6 1)...))")
		    ((10) "#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 ...)))")
		    ((11) "#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 ...)))")
		    ((12) "#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 2)))")
		    ((13) "#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 2)))")
		    ((14) "#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 2)))"))))

      (let ((str (object->string vect4)))
	(test str (case i
		    ((1) "#3D(((1 ...)...)...)")
		    ((2) "#3D(((1 2)...)...)")
		    ((3) "#3D(((1 2) (3 ...)...)...)")
		    ((4) "#3D(((1 2) (3 4)...)...)")
		    ((5) "#3D(((1 2) (3 4) (5 ...))...)")
		    ((6) "#3D(((1 2) (3 4) (5 6))...)")
		    ((7) "#3D(((1 2) (3 4) (5 6)) ((7 ...)...))")
		    ((8) "#3D(((1 2) (3 4) (5 6)) ((7 8)...))")
		    ((9) "#3D(((1 2) (3 4) (5 6)) ((7 8) (9 ...)...))")
		    ((10) "#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10)...))")
		    ((11) "#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10) (11 ...)))")
		    ((12) "#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10) (11 12)))")
		    ((13) "#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10) (11 12)))")
		    ((14) "#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10) (11 12)))"))))

      (let ((str (object->string vect2)))
	(test str (case i
		    ((1) "#2D((1 ...)...)")
		    ((2) "#2D((1 2 ...)...)")
		    ((3) "#2D((1 2 3 ...)...)")
		    ((4) "#2D((1 2 3 4 ...)...)")
		    ((5) "#2D((1 2 3 4 5 ...)...)")
		    ((6) "#2D((1 2 3 4 5 6)...)")
		    ((7) "#2D((1 2 3 4 5 6) (7 ...))")
		    ((8) "#2D((1 2 3 4 5 6) (7 8 ...))")
		    ((9) "#2D((1 2 3 4 5 6) (7 8 9 ...))")
		    ((10) "#2D((1 2 3 4 5 6) (7 8 9 10 ...))")
		    ((11) "#2D((1 2 3 4 5 6) (7 8 9 10 11 ...))")
		    ((12) "#2D((1 2 3 4 5 6) (7 8 9 10 11 12))")
		    ((13) "#2D((1 2 3 4 5 6) (7 8 9 10 11 12))")
		    ((14) "#2D((1 2 3 4 5 6) (7 8 9 10 11 12))"))))

      (let ((str (object->string vect3)))
	(test str (case i
		    ((1) "#(1 ...)")
		    ((2) "#(1 2 ...)")
		    ((3) "#(1 2 3 ...)")
		    ((4) "#(1 2 3 4 ...)")
		    ((5) "#(1 2 3 4 5 ...)")
		    ((6) "#(1 2 3 4 5 6 ...)")
		    ((7) "#(1 2 3 4 5 6 7 ...)")
		    ((8) "#(1 2 3 4 5 6 7 8 ...)")
		    ((9) "#(1 2 3 4 5 6 7 8 9 ...)")
		    ((10) "#(1 2 3 4 5 6 7 8 9 10 ...)")
		    ((11) "#(1 2 3 4 5 6 7 8 9 10 11 ...)")
		    ((12) "#(1 2 3 4 5 6 7 8 9 10 11 12 ...)")
		    ((13) "#(1 2 3 4 5 6 7 8 9 10 11 12 13 ...)")
		    ((14) "#(1 2 3 4 5 6 7 8 9 10 11 12 13 14)")))))

    (let ((vect5 (make-vector '(2 3))))
      (set! (vect5 0 0) vect1)
      (set! (vect5 0 1) vect2)
      (set! (vect5 0 2) vect3)
      (set! (vect5 1 0) vect4)
      (set! (vect5 1 1) (vector 1 2 3))
      (set! (vect5 1 2) #2d())

      (do ((i 1 (+ i 1)))
	  ((= i 15))
	(set! *vector-print-length* i)
	(let ((str (object->string vect5)))
	  (test str (case i

		      ((1) "#2D((#3D(((1 ...)...)...) ...)...)")
		      ((2) "#2D((#3D(((1 2 ...)...)...) #2D((1 2 ...)...) ...)...)")
		      ((3) "#2D((#3D(((1 2 3)...)...) #2D((1 2 3 ...)...) #(1 2 3 ...))...)")
		      ((4) "#2D((#3D(((1 2 3) (3 ...))...) #2D((1 2 3 4 ...)...) #(1 2 3 4 ...)) (#3D(((1 2) (3 4)...)...) ...))")
		      ((5) "#2D((#3D(((1 2 3) (3 4 ...))...) #2D((1 2 3 4 5 ...)...) #(1 2 3 4 5 ...)) (#3D(((1 2) (3 4) (5 ...))...) #(1 2 3) ...))")
		      ((6) "#2D((#3D(((1 2 3) (3 4 5))...) #2D((1 2 3 4 5 6)...) #(1 2 3 4 5 6 ...)) (#3D(((1 2) (3 4) (5 6))...) #(1 2 3) #2D()))")
		      ((7) "#2D((#3D(((1 2 3) (3 4 5)) ((5 ...)...)) #2D((1 2 3 4 5 6) (7 ...)) #(1 2 3 4 5 6 7 ...)) (#3D(((1 2) (3 4) (5 6)) ((7 ...)...)) #(1 2 3) #2D()))")
		      ((8) "#2D((#3D(((1 2 3) (3 4 5)) ((5 6 ...)...)) #2D((1 2 3 4 5 6) (7 8 ...)) #(1 2 3 4 5 6 7 8 ...)) (#3D(((1 2) (3 4) (5 6)) ((7 8)...)) #(1 2 3) #2D()))")
		      ((9) "#2D((#3D(((1 2 3) (3 4 5)) ((5 6 1)...)) #2D((1 2 3 4 5 6) (7 8 9 ...)) #(1 2 3 4 5 6 7 8 9 ...)) (#3D(((1 2) (3 4) (5 6)) ((7 8) (9 ...)...)) #(1 2 3) #2D()))")
		      ((10) "#2D((#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 ...))) #2D((1 2 3 4 5 6) (7 8 9 10 ...)) #(1 2 3 4 5 6 7 8 9 10 ...)) (#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10)...)) #(1 2 3) #2D()))")
		      ((11) "#2D((#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 ...))) #2D((1 2 3 4 5 6) (7 8 9 10 11 ...)) #(1 2 3 4 5 6 7 8 9 10 11 ...)) (#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10) (11 ...))) #(1 2 3) #2D()))")
		      ((12) "#2D((#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 2))) #2D((1 2 3 4 5 6) (7 8 9 10 11 12)) #(1 2 3 4 5 6 7 8 9 10 11 12 ...)) (#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10) (11 12))) #(1 2 3) #2D()))")
		      ((13) "#2D((#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 2))) #2D((1 2 3 4 5 6) (7 8 9 10 11 12)) #(1 2 3 4 5 6 7 8 9 10 11 12 13 ...)) (#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10) (11 12))) #(1 2 3) #2D()))")
		      ((14) "#2D((#3D(((1 2 3) (3 4 5)) ((5 6 1) (7 8 2))) #2D((1 2 3 4 5 6) (7 8 9 10 11 12)) #(1 2 3 4 5 6 7 8 9 10 11 12 13 14)) (#3D(((1 2) (3 4) (5 6)) ((7 8) (9 10) (11 12))) #(1 2 3) #2D()))")))))))

  (set! *vector-print-length* old-len))
  
(let ((v (make-vector '(2 2))))
  (set! (v 0 0) 1)
  (set! (v 0 1) 2)
  (set! (v 1 0) 3)
  (set! (v 1 1) 4)
  (set! (v 0 1) #2d((1 2) (3 4)))
  (test (object->string v) "#2D((1 #2D((1 2) (3 4))) (3 4))"))

(let ((v #2d((1 2) (3 4)))) 
  (set! (v 0 1) #2d((1 2) (3 4))) 
  (test (object->string v) "#2D((1 #2D((1 2) (3 4))) (3 4))"))

(let ((v (make-vector '(2 3))))
  (do ((i 0 (+ i 1)))
      ((= i 2))
    (do ((j 0 (+ j 1)))
	((= j 3))
      (set! (v i j) (list i j))))
  (test (v 0 0) '(0 0))
  (test ((v 1 2) 0) 1)
  (test (v 1 2 0) 1)
  (test (v 1 2 0 0) 'error)
  (test (object->string v) "#2D(((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)))"))

(test (let ((v1 (make-vector '(3 2) 1))
	    (v2 (make-vector '(3 2) 2))
	    (sum 0))
	(for-each (lambda (n m) (set! sum (+ sum n m))) v1 v2)
	sum)
      18)
(test (vector->list (make-vector '(2 3) 1)) '(1 1 1 1 1 1))
(test (vector->list #2d((1 2) (3 4))) '(1 2 3 4))
(test (list->vector '((1 2) (3 4))) #((1 2) (3 4)))
(test (vector->list (make-vector (list 2 0))) '())
(test (vector-dimensions #2d((1 2 3))) '(1 3))

(test (#2d((1 2 3) (4 5 6)) 0 0) 1)
(test (#2d((1 2 3) (4 5 6)) 0 1) 2)
(test (#2d((1 2 3) (4 5 6)) 1 1) 5)
(test (#3D(((1 2) (3 4)) ((5 6) (7 8))) 0 0 0) 1)
(test (#3D(((1 2) (3 4)) ((5 6) (7 8))) 1 1 0) 7)
(test (#4d((((1) (2)) ((3) (4)) ((5) (6)))) 0 0 0 0) 1)
(test (vector? #2d((1 2) (3 4))) #t)
(test ((#2d((1 #2d((2 3) (4 5))) (6 7)) 0 1) 1 0) 4)
(test ((((((((((#10D((((((((((1) (1))) (((1) (1))))) (((((1) (1))) (((1) (1))))))) (((((((1) (1))) (((1) (1))))) (((((1) (1))) (((1) (1))))))))) (((((((((1) (1))) (((1) (1))))) (((((1) (1))) (((1) (1))))))) (((((((1) (1))) (((1) (1))))) (((((1) (1))) (((1) (1)))))))))) 0) 0) 0) 0) 0) 0) 0) 0) 0) 0) 1)
(test (#10D((((((((((1) (1))) (((1) (1))))) (((((1) (1))) (((1) (1))))))) (((((((1) (1))) (((1) (1))))) (((((1) (1))) (((1) (1))))))))) (((((((((1) (1))) (((1) (1))))) (((((1) (1))) (((1) (1))))))) (((((((1) (1))) (((1) (1))))) (((((1) (1))) (((1) (1)))))))))) 0 0 0 0 0 0 0 0 0 0) 1)
(let ((v (make-vector (make-list 100 1) 0)))
  (test (equal? v #100D((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) #t)
  (test (apply v (make-list 100 0)) 0)
  (test (v 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) 0))

;; eval-string here else these are read errors
(test (eval-string "#3D(((1 2) (3 4)) ((5 6) (7)))") 'error)
(test (eval-string "#3D(((1 2) (3 4)) ((5) (7 8)))") 'error)
(test (eval-string "#3D(((1 2) (3 4)) (() (7 8)))") 'error)
(test (eval-string "#3D(((1 2) (3 4)) ((5 6) (7 8 9)))") 'error)
(test (eval-string "#3D(((1 2) (3 4)) (5 (7 8 9)))") 'error)
(test (eval-string "#3D(((1 2) (3 4)) ((5 6) (7 . 8)))") 'error)
(test (eval-string "#3D(((1 2) (3 4)) ((5 6) (7 8 . 9)))") 'error)
(test (eval-string "#3D(((1 2) (3 4)) ((5 6) ()))") 'error)
(test (eval-string "#3D(((1 2) (3 4)) ((5 6)))") 'error)

(test (vector-dimensions #3D(((1 2) (3 4)) ((5 6) (7 8)))) '(2 2 2))
(test (vector-dimensions #2d((1 2 3) (4 5 6))) '(2 3))
(test (vector-dimensions #4d((((1) (2)) ((3) (4)) ((5) (6))))) '(1 3 2 1))

(test (vector-length #3D(((1 2) (3 4)) ((5 6) (7 8)))) 8)
(test (length #2d((1 2 3) (4 5 6))) 6)

(test (#2d((1 (2) 3) (4 () 6)) 0 1) '(2))
(test (#2d((1 (2) 3) (4 () 6)) 1 1) '())
(test (#2d((1 (2) 3) (4 6 ())) 1 2) '())
(test (#2d((() (2) ()) (4 5 6)) 0 2) '())

(test (equal? (make-vector 0) (make-vector '(0))) #t)
(test (equal? #() (make-vector '(0))) #t)

(test (equal? #2d((1 2) (3 4)) #2D((1 2) (3 4))) #t)
(test (eq? #2d((1 2) (3 4)) #2D((1 2) (3 4))) #f)
(test (eqv? #2d((1 2) (3 4)) #2D((1 2) (3 4))) #f)
(test (make-vector (1 . 2) "hi") 'error)
(test (make-vector (cons 1 2) "hi") 'error)
(test (equal? (make-vector 0) (vector)) #t)
(test (equal? #() (vector)) #t)

(let ((v (make-vector '(2 3) 0)))
  (num-test (vector-length v) 6)
  (test (vector-dimensions v) '(2 3))
  (num-test (v 0 0) 0)
  (num-test (v 1 2) 0)
  (test (v 2 2) 'error)
  (test (v 2 -1) 'error)
  (test (v 2 0) 'error)
  (set! (v 0 1) 1)
  (num-test (v 0 1) 1)
  (num-test (v 1 0) 0)
  (set! (v 1 2) 2)
  (num-test (v 1 2) 2)
  (test (set! (v 2 2) 32) 'error)
  (test (set! (v 1 -1) 0) 'error)
  (test (set! (v 2 0) 0) 'error)
  (num-test (vector-ref v 0 1) 1)
  (num-test (vector-ref v 1 2) 2)
  (test (vector-ref v 2 2) 'error)
  (test (vector-ref v 1 -1) 'error)
  (vector-set! v 1 1 64)
  (num-test (vector-ref v 1 1) 64)
  (num-test (vector-ref v 0 0) 0)
  (test (vector-ref v 1 2 3) 'error)
  (test (vector-set! v 1 2 3 4) 'error)
  (test (v 1 1 1) 'error)
  (test (set! (v 1 1 1) 1) 'error))


(let ((v1 (make-vector '(3 2) 0))
      (v2 (make-vector '(2 3) 0))
      (v3 (make-vector '(2 3 4) 0))
      (v4 (make-vector 6 0))
      (v5 (make-vector '(2 3) 0)))
  (test (equal? v1 v2) #f)
  (test (equal? v1 v3) #f)
  (test (equal? v1 v4) #f)
  (test (equal? v2 v2) #t)
  (test (equal? v3 v2) #f)
  (test (equal? v4 v2) #f)
  (test (equal? v5 v2) #t)
  (test (equal? v4 v3) #f)
  (test (vector-dimensions v3) '(2 3 4))
  (test (vector-dimensions v4) '(6))
  (num-test (v3 1 2 3) 0)
  (set! (v3 1 2 3) 32)
  (num-test (v3 1 2 3) 32)
  (num-test (vector-length v3) 24)
  (num-test (vector-ref v3 1 2 3) 32)
  (vector-set! v3 1 2 3 -32)
  (num-test (v3 1 2 3) -32)
  (test (v3 1 2) '#(0 0 0 -32))
  (test (set! (v3 1 2) 3) 'error)
  (test (vector-ref v3 1 2) '#(0 0 0 -32))
  (test (vector-set! v3 1 2 32) 'error))

(test (let ((v #2d((1 2) (3 4)))) (vector-fill! v #t) v) #2D((#t #t) (#t #t)))

(test (eval-string "#2d((1 2) #2d((3 4) 5 6))") 'error)
(test (string=? (object->string #2d((1 2) (3 #2d((3 4) (5 6))))) "#2D((1 2) (3 #2D((3 4) (5 6))))") #t)
(test (string=? (object->string #3d(((#2d((1 2) (3 4)) #(1)) (#3d(((1))) 6)))) "#3D(((#2D((1 2) (3 4)) #(1)) (#3D(((1))) 6)))") #t)

(test (make-vector '(2 -2)) 'error)
(test (make-vector '(2 1/2)) 'error)
(test (make-vector '(2 1.2)) 'error)
(test (make-vector '(2 2+i)) 'error)
(test (make-vector '(2 "hi")) 'error)

(let ((v (make-vector '(1 1 1) 32)))
  (test (vector? v) #t)
  (test (equal? v #()) #f)
  (test (vector->list v) '(32))
  (test (vector-ref v 0) '#2D((32)))
  (test (vector-set! v 0 0) 'error)
  (test (vector-ref v 0 0) #(32))
  (test (vector-set! v 0 0 0) 'error)
  (test (vector-ref v 0 0 0) 32)
  (test (let () (vector-set! v 0 0 0 31) (vector-ref v 0 0 0)) 31)
  (test (vector-length v) 1)
  (test (vector-dimensions v) '(1 1 1))
  (test (object->string v) "#3D(((31)))")
  )

(test (vector? #3D(((32)))) #t)
(test (equal? #3D(((32))) #()) #f)
(test (vector->list #3D(((32)))) '(32))
(test (#3D(((32))) 0) '#2D((32)))
(test (set! (#3D(((32))) 0) 0) 'error)
(test (#3D(((32))) 0 0) '#(32))
(test (set! (#3D(((32))) 0 0) 0) 'error)
(test (#3D(((32))) 0 0 0) 32)
(test (vector-length #3D(((32)))) 1)
(test (vector-dimensions #3D(((32)))) '(1 1 1))
(test (object->string #3D(((32)))) "#3D(((32)))")


(let ((v1 (make-vector '(1 0))))
  (test (vector? v1) #t)
  (test (equal? v1 #()) #f)
  (test (vector->list v1) '())
  (test (vector-ref v1 0) 'error)
  (test (vector-set! v1 0 0) 'error)
  (test (vector-ref v1 0 0) 'error)
  (test (vector-set! v1 0 0 0) 'error)
  (test (vector-length v1) 0)
  (test (vector-dimensions v1) '(1 0))
  (test (object->string v1) "#2D()")
  )

(let ((v2 (make-vector '(10 3 0))))
  (test (vector? v2) #t)
  (test (equal? v2 #()) #f)
  (test (vector->list v2) '())
  (test (vector-ref v2) 'error)
  (test (vector-set! v2 0) 'error)
  (test (vector-ref v2 0) 'error)
  (test (vector-set! v2 0 0) 'error)
  (test (vector-ref v2 0 0) 'error)
  (test (vector-set! v2 0 0 0) 'error)
  (test (vector-ref v2 1 2 0) 'error)
  (test (vector-set! v2 1 2 0 0) 'error)
  (test (vector-length v2) 0)
  (test (vector-dimensions v2) '(10 3 0))
  (test (object->string v2) "#3D()")
  )

(let ((v3 (make-vector '(10 0 3))))
  (test (vector? v3) #t)
  (test (equal? v3 #()) #f)
  (test (vector->list v3) '())
  (test (vector-ref v3) 'error)
  (test (vector-set! v3 0) 'error)
  (test (vector-ref v3 0) 'error)
  (test (vector-set! v3 0 0) 'error)
  (test (vector-ref v3 0 0) 'error)
  (test (vector-set! v3 0 0 0) 'error)
  (test (vector-ref v3 1 0 2) 'error)
  (test (vector-set! v3 1 0 2 0) 'error)
  (test (vector-length v3) 0)
  (test (vector-dimensions v3) '(10 0 3))
  (test (object->string v3) "#3D()")
  )

(test (((#(("hi") ("ho")) 0) 0) 1) #\i)
(test (string-ref (list-ref (vector-ref #(("hi") ("ho")) 0) 0) 1) #\i)

(test (equal? #2D() (make-vector '(0 0))) #t)
(test (equal? #2D() (make-vector '(1 0))) #f)
(test (equal? (make-vector '(2 2) 2) #2D((2 2) (2 2))) #t)
(test (equal? (make-vector '(2 2) 2) #2D((2 2) (1 2))) #f)
(test (equal? (make-vector '(1 2 3) 0) (make-vector '(1 2 3) 0)) #t)
(test (equal? (make-vector '(1 2 3) 0) (make-vector '(1 3 2) 0)) #f)
(test (make-vector '1 2 3) 'error)

(test (set! (vector) 1) 'error)
(test (set! (make-vector 1) 1) 'error)
(test (equal? (make-vector 10 '()) (make-hash-table 10)) #f)
(test (equal? #() (copy #())) #t)
(test (equal? #2d() (copy #2d())) #t)
(test (fill! #() 1) 1)
(test (fill! #2d() 1) 1)

(test (equal? #2d((1 2) (3 4)) (copy #2d((1 2) (3 4)))) #t)
(test (equal? #3d() #3d(((())))) #f)
(test (equal? #3d() #3d()) #t)
(test (equal? #1d() #1d()) #t)
(test (equal? #3d() #2d()) #f)
(test (equal? #3d() (copy #3d())) #t)
(test (equal? #2d((1) (2)) #2d((1) (3))) #f)
(test (equal? #2d((1) (2)) (copy #2d((1) (2)))) #t)
(test (equal? (make-vector '(3 0 1)) (make-vector '(3 0 2))) #f)
(test (eval-string "#0d()") 'error)

(let ((v #2d((1 2 3) (4 5 6))))
  (let ((v1 (v 0))
	(v2 (v 1)))
    (if (not (equal? v1 #(1 2 3)))
	(format #t ";(v 0) subvector: ~A~%" v1))
    (if (not (equal? v2 #(4 5 6)))
	(format #t ";(v 1) subvector: ~A~%" v2))
    (let ((v3 (copy v1)))
      (if (not (equal? v3 #(1 2 3)))
	  (format #t ";(v 0) copied subvector: ~A~%" v3))
      (if (not (= (length v3) 3))
	  (format #t ";(v 0) copied length: ~A~%" (length v3)))
      (if (not (equal? v3 (copy (v 0))))
	  (format #t ";(v 0) copied subvectors: ~A ~A~%" v3 (copy (v 0)))))))

(let ((v1 (make-vector '(3 2 1) #f))
      (v2 (make-vector '(3 2 1) #f)))
  (test (equal? v1 v2) #t)
  (set! (v2 0 0 0) 1)
  (test (equal? v1 v2) #f))
(test (equal? (make-vector '(3 2 1) #f) (make-vector '(1 2 3) #f)) #f)

(test (map (lambda (n) n) #2d((1 2) (3 4))) '(1 2 3 4))
(test (let ((vals '())) (for-each (lambda (n) (set! vals (cons n vals))) #2d((1 2) (3 4))) vals) '(4 3 2 1))
(test (map (lambda (x y) (+ x y)) #2d((1 2) (3 4)) #1d(4 3 2 1)) '(5 5 5 5))
(test (let ((vals '())) (for-each (lambda (x y) (set! vals (cons (+ x y) vals))) #2d((1 2) (3 4)) #1d(4 3 2 1)) vals) '(5 5 5 5))

(let ((v #2D((#(1 2) #(3 4)) (#2d((5 6) (7 8)) #2D((9 10 11) (12 13 14))))))
  (test (v 0 0) #(1 2))
  (test (v 0 1) #(3 4))
  (test (v 1 0) #2d((5 6) (7 8)))
  (test (v 1 1) #2D((9 10 11) (12 13 14)))
  (test ((v 1 0) 0 1) 6)
  (test ((v 0 1) 1) 4)
  (test ((v 1 1) 1 2) 14))

(let ((v #2D((#((1) #(2)) #(#(3) (4))) (#2d(((5) #(6)) (#(7) #(8))) #2D((#2d((9 10) (11 12)) (13)) (14 15))))))
  (test (v 0 0) #((1) #(2)))
  (test (v 0 1) #(#(3) (4)))
  (test (v 1 0) #2D(((5) #(6)) (#(7) #(8))))
  (test (v 1 1) #2D((#2D((9 10) (11 12)) (13)) (14 15)))
  (test ((v 1 0) 0 1) #(6))
  (test (((v 1 0) 0 1) 0) 6)
  (test ((v 0 1) 1) '(4))
  (test (((v 1 1) 0 0) 1 0) 11))


(test (let ((V #2D((1 2 3) (4 5 6)))) (V 0)) '#(1 2 3))
(test (let ((V #2D((1 2 3) (4 5 6)))) (V 1)) '#(4 5 6))
(test (let ((V #2D((1 2 3) (4 5 6)))) (V 2)) 'error)
(test (let ((V #2D((1 2 3) (4 5 6)))) (set! (V 1) 0)) 'error)
(test (let ((V #2D((1 2 3) (4 5 6)))) (let ((V1 (V 0))) (set! (V1 1) 32) V)) '#2D((1 32 3) (4 5 6)))
(test (let ((V #2D((1 2 3) (4 5 6)))) (let ((V1 (V 0))) (set! (V1 3) 32) V)) 'error)

(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (V 1)) '#2D((7 8 9) (10 11 12)))
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (V 1 1)) '#(10 11 12))
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (V 0 1)) '#(4 5 6))
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (V 2 1)) 'error)
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) ((V 0) 1)) '#(4 5 6))
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (set! (((V 0) 1) 1) 32) V) '#3D(((1 2 3) (4 32 6)) ((7 8 9) (10 11 12))))
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (vector-set! V 0 1 1 32) V) '#3D(((1 2 3) (4 32 6)) ((7 8 9) (10 11 12))))
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (vector-set! V 1 1 0 32) V) '#3D(((1 2 3) (4 5 6)) ((7 8 9) (32 11 12))))
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (vector-length (V 1))) 6)
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (vector-dimensions (V 1))) '(2 3))
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (vector-length (V 0 1))) 3)
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12))))) (vector-dimensions (V 0 1))) '(3))
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12)))) (one 1) (zero 0)) 
	(let ((V1 (V one zero))
	      (sum 0))
	  (for-each (lambda (n) (set! sum (+ sum n))) V1)
	  sum))
      24) ; 7 8 9
(test (let ((V '#3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12)))) (two 2) (one 1) (zero 0)) 
	(let ((V10 (V one zero))
	      (V00 (V zero zero))
	      (V01 (V zero one))
	      (V11 (V one one))
	      (sum 0))
	  (for-each (lambda (n0 n1 n2 n3) (set! sum (+ sum n0 n1 n2 n3))) V00 V01 V10 V11)
	  sum))
      78)

(let ((old-vlen *vector-print-length*))
  (set! *vector-print-length* 32)
  (test (object->string (make-vector '(8 8) 0)) "#2D((0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0) (0 0 0 0 0 0 0 0)...)")
  (test (object->string (make-vector 64 0)) "#(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...)")
  (test (object->string (make-vector 32 0)) "#(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)")
  (test (object->string (make-vector 33 0)) "#(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...)")
  (test (object->string (make-vector '(8 4) 0)) "#2D((0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0))")
  (set! *vector-print-length* old-vlen))

(let ((old-vlen *vector-print-length*))
  (set! *vector-print-length* 1024) ; check the many-() case
  (test (object->string (make-vector '(2 1 2 1 2 1 2 1 2 1 2 1 2 1) 0)) "#14D((((((((((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))) (((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))))) (((((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))) (((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))))))) (((((((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))) (((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))))) (((((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))) (((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))))))))) (((((((((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))) (((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))))) (((((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))) (((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))))))) (((((((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))) (((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))))) (((((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))) (((((((0) (0))) (((0) (0))))) (((((0) (0))) (((0) (0))))))))))))))")

  (test (object->string (make-vector '(16 1 1 1 1 1 1 1 1 1 1 1 1 1) 0)) "#14D((((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))) (((((((((((((0))))))))))))))")

;;; now see if our shared vector has survived...
  (test (and (vector? check-shared-vector-after-gc)
	     (= (length check-shared-vector-after-gc) 6)
	     (do ((i 0 (+ i 1))
		  (happy #t))
		 ((= i 6) happy)
	       (if (or (not (pair? (check-shared-vector-after-gc i)))
		       (not (equal? (check-shared-vector-after-gc i) (cons 3 i))))
		   (set! happy #f))))
	#t)
  (set! check-shared-vector-after-gc #f)

  (set! *vector-print-length* old-vlen))  




;;; -------- circular structures --------

(let ((lst (list 1 2 3)))
   (set! (cdr (cddr lst)) lst)
   (test (apply + lst) 'error))

(let ((l1 (list 1)))
  (test (object->string (list l1 1 l1)) "(#1=(1) 1 #1#)"))

(let ((lst (list 1 2 3)))
   (set! (cdr (cddr lst)) lst)
   (test (object->string (append '(1) lst)) "(1 . #1=(1 2 3 . #1#))"))
(let ((lst (list 1 2 3)))
   (set! (cdr (cddr lst)) lst)
   (test (append lst '()) 'error)) 

(let ((lst (list 1 2 3)))
   (set! (cdr (cddr lst)) lst)
   (test (sort! lst <) 'error))

(let ((lst (list 1 2 3)))
   (set! (cdr (cddr lst)) lst)
   (test (object->string (list lst)) "(#1=(1 2 3 . #1#))"))

(let ((lst (list 1 2 3)))
   (set! (cdr (cddr lst)) lst)
   (test (object->string (make-list 4 lst)) "(#1=(1 2 3 . #1#) #1# #1# #1#)"))

(let ((lst (list 1 2 3)))
   (set! (cdr (cddr lst)) lst)
   (test (object->string (vector lst lst)) "#(#1=(1 2 3 . #1#) #1#)"))

(let ((lst `(+ 1 2 3)))
   (set! (cdr (cdddr lst)) (cddr lst)) 
   (test (object->string lst) "(+ 1 . #1=(2 3 . #1#))"))


(let ((x (list 1 2)))
  (test (equal? x x) #t)
  (test (equal? x (cdr x)) #f)
  (test (equal? x '()) #f))
(let ((x (list 1 (list 2 3) (list (list 4 (list 5)))))
      (y (list 1 (list 2 3) (list (list 4 (list 5))))))
  (test (equal? x y) #t))
(let ((x (list 1 (list 2 3) (list (list 4 (list 5)))))
      (y (list 1 (list 2 3) (list (list 4 (list 5) 6)))))
  (test (equal? x y) #f))

(test (length '()) 0)
(test (length (cons 1 2)) -1)
(test (length '(1 2 3)) 3)

(let ((lst1 (list 1 2))) 
  (test (length lst1) 2)
  (list-set! lst1 0 lst1)
  (test (length lst1) 2) ; its car is a circular list, but it isn't
  (test (list->string lst1) 'error)
  (let ((lst2 (list 1 2)))
    (set-car! lst2 lst2)
    (test (equal? lst1 lst2) #t)
    (test (eq? lst1 lst2) #f)
    (test (eqv? lst1 lst2) #f)
    (test (pair? lst1) #t)
    (test (null? lst1) #f)
    (test (car lst2) lst2)
    (test (car lst1) lst1)
    (test (let ()
	    (fill! lst1 32)
	    lst1)
	  '(32 32))))

(let ((lst1 (list 1))) 
  (test (length lst1) 1)
  (set-cdr! lst1 lst1)
  (test (infinite? (length lst1)) #t)
  (test (null? lst1) #f)
  (test (pair? lst1) #t)
  (let ((lst2 (cons 1 '())))
    (set-cdr! lst2 lst2)
    (test (equal? lst1 lst2) #t)
    (set-car! lst2 0)
    (test (equal? lst1 lst2) #f)
    (test (infinite? (length lst2)) #t)))

(let ((lst1 (list 1))) 
  (set-cdr! lst1 lst1)
  (test (list-tail lst1 0) lst1)
  (test (list-tail lst1 3) lst1)
  (test (list-tail lst1 10) lst1))

(let ((lst1 (let ((lst (list 'a))) 
	      (set-cdr! lst lst)
	      lst)))
  (test (apply lambda lst1 (list 1)) 'error)) ; lambda parameter 'a is used twice in the lambda argument list !

(let ((lst1 (list 1))
      (lst2 (list 1)))
  (set-car! lst1 lst2)
  (set-car! lst2 lst1)
  (test (equal? lst1 lst2) #t)
  (test (length lst1) 1)
  (let ((lst3 (list 1)))
    (test (equal? lst1 lst3) #f)
    (set-cdr! lst3 lst3)
    (test (equal? lst1 lst3) #f)))

(let ((lst1 (list 'a 'b 'c)))
  (set! (cdr (cddr lst1)) lst1)
  (test (infinite? (length lst1)) #t)
  (test (memq 'd lst1) #f)
  (test (memq 'a lst1) lst1)
  (test (memq 'b lst1) (cdr lst1)))

(let ((lst1 (list 1 2 3)))
  (list-set! lst1 1 lst1)
  (test (object->string lst1) "#1=(1 #1# 3)"))

(let ((lst1 (let ((lst (list 1))) 
	      (set-cdr! lst lst)
	      lst)))
  (test (list-ref lst1 9223372036854775807) 'error)
  (test (list-set! lst1 9223372036854775807 2) 'error)
  (test (list-tail lst1 9223372036854775807) 'error)
  (test (make-vector lst1 9223372036854775807) 'error)
  (test (map (lambda (x) x) lst1) 'error)
  (test (map (lambda (x y) x) lst1 lst1) 'error)
  (test (for-each (lambda (x) x) lst1) 'error)
  (test (for-each (lambda (x y) x) lst1 lst1) 'error)
  (test (map (lambda (x y) (+ x y)) lst1 '(1 2 3)) '(2 3 4))
  )

(test (let ((lst '(a b c)))
	(set! (cdr (cddr lst)) lst)
	(map cons lst '(0 1 2 3 4 5)))
      '((a . 0) (b . 1) (c . 2) (a . 3) (b . 4) (c . 5)))

(test (object->string (let ((l1 (list 0 1))) (set! (l1 1) l1) (copy l1))) "(0 #1=(0 #1#))")
(test (object->string (let ((lst (list 1 2))) (set! (cdr lst) lst) (copy lst))) "(1 . #1=(1 . #1#))")
(test (object->string (let ((l1 (list 1 2))) (copy (list l1 4 l1)))) "(#1=(1 2) 4 #1#)")
(test (object->string (let ((lst (list 1 2 3))) (set! (cdr (cddr lst)) (cdr lst)) (copy lst))) "(1 2 3 . #1=(2 3 . #1#))")

(test (reverse '(1 2 (3 4))) '((3 4) 2 1))
(test (reverse '(1 2 3)) '(3 2 1))
(test (reverse '()) '())
(test (let ((lst (list 1 2 3))) (set! (lst 2) lst) (object->string (reverse lst))) "(#1=(1 2 #1#) 2 1)")
(test (let ((l1 (cons 1 '()))) (set-cdr! l1 l1) (object->string (reverse l1))) "(#1=(1 . #1#) 1 1 1)")


(test (equal? (vector 0) (vector 0)) #t)
(test (equal? (vector 0 #\a "hi" (list 1 2 3)) (vector 0 #\a "hi" (list 1 2 3))) #t)
(test (let ((v (vector 0))) (equal? (vector v) (vector v))) #t)

(let ((v1 (make-vector 1 0)))
  (set! (v1 0) v1)
  (test (vector? v1) #t)
  (let ((v2 (vector 0)))
    (vector-set! v2 0 v2)
    (test (vector-length v1) 1)
    (test (equal? v1 v2) #t)
    (test (equal? (vector-ref v1 0) v1) #t)
    (test (equal? (vector->list v1) (list v1)) #t)
    (vector-fill! v1 0)
    (test (equal? v1 (vector 0)) #t)
    (let ((v3 (copy v2)))
      (test (equal? v2 v3) #t)
      (vector-set! v3 0 0)
      (test (equal? v3 (vector 0)) #t))
    ))

(let ((v1 (make-vector 1 0))
      (v2 (vector 0)))
  (set! (v1 0) v2)
  (set! (v2 0) v1)
  (test (equal? v1 v2) #t)) 

(let* ((l1 (list 1 2))
       (v1 (vector 1 2))
       (l2 (list 1 l1 2))
       (v2 (vector l1 v1 l2)))
  (vector-set! v1 0 v2)
  (list-set! l1 1 l2)
  (test (equal? v1 v2) #f))

(let ((v1 (make-vector 1 0)))
  (set! (v1 0) v1)
  (let ((v2 (vector 0)))
    (vector-set! v2 0 v2)
    (test (equal? v1 v2) #t)))

(let ((v1 (make-vector 1 0)))
  (set! (v1 0) v1)
  (test (object->string v1) "#1=#(#1#)"))

(let ((l1 (cons 0 '()))) 
  (set-cdr! l1 l1) 
  (test (list->vector l1) 'error))

(let ((lst (list "nothing" "can" "go" "wrong")))
  (let ((slst (cddr lst))
	(result '()))
    (set! (cdr (cdddr lst)) slst)
    (test (do ((i 0 (+ i 1))
	       (l lst (cdr l)))
	      ((or (null? l) (= i 12))
	       (reverse result))
	    (set! result (cons (car l) result)))
	  '("nothing" "can" "go" "wrong" "go" "wrong" "go" "wrong" "go" "wrong" "go" "wrong"))))

#|
;;; here is a circular function
(let ()
  (define (cfunc)
    (begin
      (display "cfunc! ")
      #f))

  (let ((clst (procedure-source cfunc)))
    (set! (cdr (cdr (car (cdr (cdr clst)))))
	  (cdr (car (cdr (cdr clst))))))

  (cfunc))
|#

(test (let ((l (list 1 2))) 
	(list-set! l 0 l) 
	(string=? (object->string l) "#1=(#1# 2)")) 
      #t)
(test (let ((lst (list 1)))
	(set! (car lst) lst)
	(set! (cdr lst) lst)
	(string=? (object->string lst) "#1=(#1# . #1#)"))
      #t)
(test (let ((lst (list 1)))
	(set! (car lst) lst)
	(set! (cdr lst) lst)
	(equal? (car lst) (cdr lst)))
      #t)
(test (let ((lst (cons 1 2))) 
	(set-cdr! lst lst)
	(string=? (object->string lst) "#1=(1 . #1#)"))
      #t)
(test (let ((lst (cons 1 2))) 
	(set-car! lst lst)
	(string=? (object->string lst) "#1=(#1# . 2)"))
      #t)
(test (let ((lst (cons (cons 1 2) 3))) 
	(set-car! (car lst) lst)
	(string=? (object->string lst) "#1=((#1# . 2) . 3)"))
      #t)
(test (let ((v (vector 1 2))) 
	(vector-set! v 0 v) 
	(string=? (object->string v) "#1=#(#1# 2)")) 
      #t)
(test (let* ((l1 (list 1 2)) (l2 (list l1))) 
	(list-set! l1 0 l1) 
	(string=? (object->string l2) "(#1=(#1# 2))")) 
      #t)

(test (let ((lst (list 1 2 3))) (set! (cdr (cdr (cdr lst))) lst) (object->string lst)) "#1=(1 2 3 . #1#)")
(test (let ((lst (list 1 2 3))) (set! (cdr (cdr (cdr lst))) (cdr lst)) (object->string lst)) "(1 . #1=(2 3 . #1#))")
(test (let ((lst (list 1 2 3))) (set! (cdr (cdr (cdr lst))) (cdr (cdr lst))) (object->string lst)) "(1 2 . #1=(3 . #1#))")
(test (let ((lst (list 1 2 3))) (set! (car lst) (cdr lst)) (object->string lst)) "(#1=(2 3) . #1#)")
(test (let ((lst (list 1 2 3))) (set! (car (cdr lst)) (cdr lst)) (object->string lst)) "(1 . #1=(#1# 3))")
(test (let ((lst (list 1 2 3))) (set! (car (cdr lst)) lst) (object->string lst)) "#1=(1 #1# 3)")
(test (let ((l1 (list 1))) (let ((l2 (list l1 l1))) (object->string l2))) "(#1=(1) #1#)")

(test (let* ((v1 (vector 1 2)) (v2 (vector v1))) 
	(vector-set! v1 1 v1) 
	(string=? (object->string v2) "#(#1=#(1 #1#))")) 
      #t)
(test (let ((v1 (make-vector 3 1))) 
	(vector-set! v1 0 (cons 3 v1)) 
	(string=? (object->string v1) "#1=#((3 . #1#) 1 1)")) 
      #t)
(test (let ((h1 (make-hash-table 11))
	    (old-print-length *vector-print-length*))
	(set! *vector-print-length* 32)
	(hash-table-set! h1 "hi" h1)
	(let ((result (object->string h1)))
	  (set! *vector-print-length* old-print-length)
	  (let ((val (string=? result "#1=#<hash-table (\"hi\" . #1#)>")))
	    (if (not val)
		(format #t ";hash display:~%  ~A~%" (object->string h1)))
	    val)))
      #t)

(test (let* ((l1 (list 1 2))
	     (v1 (vector 1 2))
	     (l2 (list 1 l1 2))
	     (v2 (vector l1 v1 l2)))
	(vector-set! v1 0 v2)
	(list-set! l1 1 l2)
	(string=? (object->string v2) "#2=#(#1=(1 #3=(1 #1# 2)) #(#2# 2) #3#)"))
      #t)

(test (let ((l1 (list 1 2))
	    (l2 (list 1 2)))
	(set! (car l1) l2)
	(set! (car l2) l1)
	(object->string (list l1 l2)))
      "(#1=(#2=(#1# 2) 2) #2#)")

(test (let* ((l1 (list 1 2)) 
	     (l2 (list 3 4)) 
	     (l3 (list 5 l1 6 l2 7)))
	(set! (cdr (cdr l1)) l1) 
	(set! (cdr (cdr l2)) l2)
	(string=? (object->string l3) "(5 #1=(1 2 . #1#) 6 #2=(3 4 . #2#) 7)"))
      #t)
(test (let* ((lst1 (list 1 2))
	     (lst2 (list (list (list 1 (list (list (list 2 (list (list (list 3 (list (list (list 4 lst1 5))))))))))))))
	(set! (cdr (cdr lst1)) lst1)
	(string=? (object->string lst2) "(((1 (((2 (((3 (((4 #1=(1 2 . #1#) 5))))))))))))"))
      #t)


(test (equal? '(a) (list 'a)) #t)
(test (equal? '(a b . c) '(a b . c)) #t)
(test (equal? '(a b (c . d)) '(a b (c . d))) #t)
(test (equal? (list "hi" "hi" "hi") '("hi" "hi" "hi")) #t)
(let ((l1 (list "hi" "hi" "hi"))
      (l2 (list "hi" "hi" "hi")))
  (fill! l1 "ho")
  (test (equal? l1 l2) #f)
  (fill! l2 (car l1))
  (test (equal? l1 l2) #t))
(let ((lst (list 1 2 3 4))) 
  (fill! lst "hi") 
  (test (equal? lst '("hi" "hi" "hi" "hi")) #t))
(let ((vect (vector 1 2 3 4)))
  (fill! vect "hi")
  (test (equal? vect #("hi" "hi" "hi" "hi")) #t))
(let ((lst (list 1 2 (list 3 4) (list (list 5) 6))))
  (test (equal? lst '(1 2 (3 4) ((5) 6))) #t)
  (fill! lst #f)
  (test (equal? lst '(#f #f #f #f)) #t))
(let ((lst (list 1 2 3 4)))
  (set! (cdr (cdddr lst)) lst)
  (test (equal? lst lst) #t)
  (test (eq? lst lst) #t)
  (test (eqv? lst lst) #t)
  (fill! lst #f)
  (test (object->string lst) "#1=(#f #f #f #f . #1#)")
  (let ((l1 (copy lst)))
    (test (equal? lst l1) #t)
    (test (eq? lst l1) #f)
    (test (eqv? lst l1) #f)))


(let ((lst '(#\( #\) #\* #\+ #\, #\- #\. #\/ #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\: #\; #\< #\= #\> #\? #\@ #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z #\[ #\\ #\] #\^ #\_ #\` #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z #\{ #\| #\} #\~)))
  (let ((str (apply string lst)))
    (let ((lstr (list->string lst)))
      (let ((strl (string->list str)))
	(test (eq? str str) #t)
	(test (eq? str lstr) #f)
	(test (eqv? str str) #t)
	(test (eqv? str lstr) #f)
	(test (equal? str lstr) #t)
	(test (equal? str str) #t)
	(test (eq? lst strl) #f)	
	(test (eqv? lst strl) #f)	
	(test (equal? lst strl) #t)
	(let ((l2 (copy lst))
	      (s2 (copy str)))
	  (test (eq? l2 lst) #f)
	  (test (eq? s2 str) #f)
	  (test (eqv? l2 lst) #f)
	  (test (eqv? s2 str) #f)
	  (test (equal? l2 lst) #t)
	  (test (equal? s2 str) #t))))))


(let ((vect #(#\( #\) #\* #\+ #\, #\- #\. #\/ #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\: #\; #\< #\= #\> #\? #\@ #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z #\[ #\\ #\] #\^ #\_ #\` #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z #\{ #\| #\} #\~)))
  (let ((lst (vector->list vect)))
    (let ((vect1 (list->vector lst)))
	(test (eq? lst lst) #t)
	(test (eq? lst vect) #f)
	(test (eqv? lst lst) #t)
	(test (eqv? lst vect) #f)
	(test (equal? vect1 vect) #t)
	(test (equal? lst lst) #t)
	(test (eq? vect vect1) #f)	
	(test (eqv? vect vect1) #f)	
	(test (equal? vect vect1) #t)
	(let ((l2 (copy vect))
	      (s2 (copy lst)))
	  (test (eq? l2 vect) #f)
	  (test (eq? s2 lst) #f)
	  (test (eqv? l2 vect) #f)
	  (test (eqv? s2 lst) #f)
	  (test (equal? l2 vect) #t)
	  (test (equal? s2 lst) #t)))))

(let* ((vals (list "hi" #\A 1 'a #(1) abs _ht_ quasiquote macroexpand (log 0) 
		   3.14 3/4 1.0+1.0i #\f '(1 . 2)))
       (vlen (length vals)))
  (do ((i 0 (+ i 1)))
      ((= i 20))
    (let* ((size (max 1 (random 20)))
	   (vect (make-vector size '())))
      (do ((n 0 (+ n 1)))
	  ((= n size))
	(let ((choice (random 4))
	      (len (random 4)))
	  (if (= choice 0)
	      (let ((v (make-vector len)))
		(do ((k 0 (+ k 1)))
		    ((= k len))
		  (vector-set! v k (list-ref vals (random vlen))))
		(vector-set! vect n v))
	      (if (= choice 1)
		  (let ((lst (make-list len #f)))
		    (do ((k 0 (+ k 1)))
			((= k len))
		      (list-set! lst k (list-ref vals (random vlen))))
		    (vector-set! vect n lst))
		  (vector-set! vect n (list-ref vals (random vlen)))))))
      (test (eq? vect vect) #t)
      (test (eqv? vect vect) #t)
      (test (equal? vect vect) #t)
      (let ((lst1 (vector->list vect)))
	(let ((lst2 (copy lst1)))
	  (test (eq? lst1 lst2) #f)
	  (test (eqv? lst1 lst2) #f)
	  (test (equal? lst1 lst2) #t))))))

(let* ((lst1 (list 1 2 3))
       (vec1 (vector 1 2 lst1)))
  (list-set! lst1 2 vec1)
  (let* ((lst2 (list 1 2 3))
	 (vec2 (vector 1 2 lst2)))
    (list-set! lst2 2 vec2)
    (test (equal? lst1 lst2) #t)
    (test (equal? vec1 vec2) #t)
    (vector-set! vec1 1 vec1)
    (test (equal? lst1 lst2) #f)
    (test (equal? vec1 vec2) #f)
    ))
  
(let* ((base (list #f))
       (lst1 (list 1 2 3))
       (vec1 (vector 1 2 base)))
  (list-set! lst1 2 vec1)
  (let* ((lst2 (list 1 2 3))
	 (vec2 (vector 1 2 base)))
    (list-set! lst2 2 vec2)
    (set! (car lst1) lst1)
    (set! (car lst2) lst2)
    (set! (cdr (cddr lst1)) base)
    (set! (cdr (cddr lst2)) base)
    (test (equal? lst1 lst2) #t)
    (test (equal? vec1 vec2) #t)
    (test (object->string lst1) "#1=(#1# 2 #(1 2 #2=(#f)) . #2#)")))

(let ((base (list 0 #f)))
  (let ((lst1 (list 1 base 2))
	(lst2 (list 1 base 2)))
    (set! (cdr (cdr base)) base)
    (test (equal? lst1 lst2) #t)))

(let ((base1 (list 0 #f))
      (base2 (list 0 #f)))
  (let ((lst1 (list 1 base1 2))
	(lst2 (list 1 base2 2)))
    (set! (cdr (cdr base1)) lst2)
    (set! (cdr (cdr base2)) lst1)
    (test (equal? lst1 lst2) #t)
    (test (object->string lst1) "#1=(1 (0 #f 1 (0 #f . #1#) 2) 2)")))

(let ()
  (define-macro (c?r path)

  (define (X-marks-the-spot accessor tree)
    (if (pair? tree)
	(or (X-marks-the-spot (cons 'car accessor) (car tree))
	    (X-marks-the-spot (cons 'cdr accessor) (cdr tree)))
	(if (eq? tree 'X) accessor #f)))

  (let ((body 'lst))
    (for-each
     (lambda (f)
       (set! body (list f body)))
     (reverse (X-marks-the-spot '() path)))

    `(make-procedure-with-setter
      (lambda (lst) 
	,body)
      (lambda (lst val)
	(set! ,body val)))))

  (define (copy-tree lis)
    (if (pair? lis)
	(cons (copy-tree (car lis))
	      (copy-tree (cdr lis)))
	lis))

  (let* ((l1 '(0 (1 (2 (3 (4 (5 (6 (7 (8))))))))))
	 (l2 (list 0 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 (list 7 (list 8))))))))))
	 (l3 (copy-tree l1))
	 (cxr (c?r (0 (1 (2 (3 (4 (5 (6 (7 (X))))))))))))
    (set! (cxr l1) 3)
    (set! (cxr l2) 4)
    (test (equal? l1 l2) #f)
    (test (equal? l1 l3) #f)
    (set! (cxr l2) 3)
    (test (cxr l2) 3)
    (test (cxr l1) 3)
    (test (cxr l3) 8)
    (test (equal? l1 l2) #t)
    (test (equal? l2 l3) #f))

  (let* ((l1 '(0 (1 (2 (3 (4 (5 (6 (7 (8))))))))))
	 (l2 (list 0 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 (list 7 (list 8))))))))))
	 (l3 (copy-tree l1))
	 (cxr (c?r (0 (1 (2 (3 (4 (5 (6 (7 (8 . X))))))))))))
    (set! (cxr l1) l1)
    (set! (cxr l2) l2)
    (test (equal? l1 l2) #t)
    (test (equal? l1 l3) #f)
    (test (object->string l2) "#1=(0 (1 (2 (3 (4 (5 (6 (7 (8 . #1#)))))))))"))

  (let* ((l1 '(0 ((((((1))))))))
	 (l2 (copy-tree l1))
	 (cxr (c?r (0 ((((((1 . X))))))))))
    (set! (cxr l1) l2)
    (set! (cxr l2) l1)
    (test (equal? l1 l2) #t))

  (let* ((l1 '(0 1 (2 3) 4 5))
	 (cxr (c?r (0 1 (2 3 . X) 4 5))))
    (set! (cxr l1) (cdr l1))
    (test (object->string l1) "(0 . #1=(1 (2 3 . #1#) 4 5))"))

  (let* ((l1 '(0 1 (2 3) 4 5))
	 (l2 '(6 (7 8 9) 10))
	 (cxr1 (c?r (0 1 (2 3 . X) 4 5)))
	 (cxr2 (c?r (6 . X)))
	 (cxr3 (c?r (6 (7 8 9) 10 . X)))
	 (cxr4 (c?r (0 . X))))
    (set! (cxr1 l1) (cxr2 l2))
    (set! (cxr3 l2) (cxr4 l1))
    (test (object->string l1) "(0 . #1=(1 (2 3 (7 8 9) 10 . #1#) 4 5))")
    (test (cadr l1) 1)
    (test (cadddr l1) 4)
    )

  (let ((l1 '((a . 2) (b . 3) (c . 4)))
	(cxr (c?r ((a . 2) (b . 3) (c . 4) . X))))
    (set! (cxr l1) (cdr l1))
    (test (assq 'a l1) '(a . 2))
    (test (assv 'b l1) '(b . 3))
    (test (assoc 'c l1) '(c . 4))
    (test (object->string l1) "((a . 2) . #1=((b . 3) (c . 4) . #1#))")
    (test (assq 'asdf l1) #f)
    (test (assv 'asdf l1) #f)
    (test (assoc 'asdf l1) #f)
    )

  (let ((l1 '(a b c d e))
	(cxr (c?r (a b c d e . X))))
    (set! (cxr l1) (cddr l1))
    (test (memq 'b l1) (cdr l1))
    (test (memv 'c l1) (cddr l1))
    (test (member 'd l1) (cdddr l1))
    (test (object->string l1) "(a b . #1=(c d e . #1#))")
    (test (memq 'asdf l1) #f)
    (test (memv 'asdf l1) #f)
    (test (member 'asdf l1) #f)
    (test (pair? (member 'd l1)) #t) ; #1=(d e c . #1#)
    )

  (let ((ctr 0)
	(x 0))
    (let ((lst `(call-with-exit (lambda (return) (set! x (+ x 1)) (if (> x 10) (return x) 0)))))
      (let ((acc1 (c?r (call-with-exit (lambda (return) . X))))
	    (acc2 (c?r (call-with-exit (lambda (return) (set! x (+ x 1)) (if (> x 10) (return x) 0) . X)))))
	(set! (acc2 lst) (acc1 lst))
	(test (eval lst) 11))))
  )
  
(let ((v #2d((1 2) (3 4))))
  (set! (v 1 0) v)
  (test (object->string v) "#1=#2D((1 2) (#1# 4))")
  (test (length v) 4)
  (test ((((v 1 0) 1 0) 1 0) 0 0) 1))

(let ((lst (list 1 2 3)))
  (set! (cdr (cddr lst)) lst)
  (test (lst 100) 2)
  (test ((cdddr (cdddr (cdddr lst))) 100) 2)
  (set! (lst 100) 32)
  (test (object->string lst) "#1=(1 32 3 . #1#)"))

(let* ((l1 (list 1 2))
       (l2 (list l1 l1)))
  (set! (l1 0) 32)
  (test (equal? l2 '((32 2) (32 2))) #t))

(let ((q (list 1 2 3 4)))
  (set! (cdr (cdddr q)) q) 
  (test (car q) 1)
  (set! (car q) 5)
  (set! q (cdr q))
  (test (car q) 2)
  (test (object->string q) "#1=(2 3 4 5 . #1#)"))

(let ()
  (define make-node vector)
  (define prev (make-procedure-with-setter (lambda (node) (node 0)) (lambda (node val) (set! (node 0) val))))
  (define next (make-procedure-with-setter (lambda (node) (node 2)) (lambda (node val) (set! (node 2) val))))
  (define data (make-procedure-with-setter (lambda (node) (node 1)) (lambda (node val) (set! (node 1) val))))
  (let* ((head (make-node () 0 ()))
	 (cur head))
    (do ((i 1 (+ i 1)))
	((= i 8))
      (let ((next-node (make-node cur i ())))
	(set! (next cur) next-node)
	(set! cur (next cur))))
    (set! (next cur) head)
    (set! (prev head) cur)
    (test (object->string head) "#1=#(#7=#(#6=#(#5=#(#4=#(#3=#(#2=#(#8=#(#1# 1 #2#) 2 #3#) 3 #4#) 4 #5#) 5 #6#) 6 #7#) 7 #1#) 0 #8#)")
#|
    ;; in CL:
    (let* ((head (vector nil 0 nil))
	   (cur head))
      (do ((i 1 (+ i 1)))
	  ((= i 8))
	(let ((node (vector nil i nil)))
	  (setf (aref node 0) cur)
	  (setf (aref cur 2) node)
	  (setf cur node)))
      (setf (aref head 0) cur)
      (setf (aref cur 2) head)
      (format t "~A~%" head)) -> "#1=#(#2=#(#3=#(#4=#(#5=#(#6=#(#7=#(#8=#(#1# 1 #7#) 2 #6#) 3 #5#) 4 #4#) 5 #3#) 6 #2#) 7 #1#) 0 #8#)"
|#
    (let ((ahead (do ((cur head (next cur))
		      (dat '() (cons (data cur) dat)))
		     ((member (data cur) dat)
		      (reverse dat)))))
      (let ((behind (do ((cur (prev head) (prev cur))
			 (dat '() (cons (data cur) dat)))
			((member (data cur) dat)
			 dat))))
	(test (equal? ahead behind) #t)))))

(let ()
  (define make-node list)
  (define prev (make-procedure-with-setter (lambda (node) (node 0)) (lambda (node val) (set! (node 0) val))))
  (define next (make-procedure-with-setter (lambda (node) (node 2)) (lambda (node val) (set! (node 2) val))))
  (define data (make-procedure-with-setter (lambda (node) (node 1)) (lambda (node val) (set! (node 1) val))))
  (let* ((head (make-node () 0 ()))
	 (cur head))
    (do ((i 1 (+ i 1)))
	((= i 8))
      (let ((next-node (make-node cur i ())))
	(set! (next cur) next-node)
	(set! cur (next cur))))
    (set! (next cur) head)
    (set! (prev head) cur)
    (test (object->string head) "#1=(#7=(#6=(#5=(#4=(#3=(#2=(#8=(#1# 1 #2#) 2 #3#) 3 #4#) 4 #5#) 5 #6#) 6 #7#) 7 #1#) 0 #8#)")
    (let ((ahead (do ((cur head (next cur))
		      (dat '() (cons (data cur) dat)))
		     ((member (data cur) dat)
		      (reverse dat)))))
      (let ((behind (do ((cur (prev head) (prev cur))
			 (dat '() (cons (data cur) dat)))
			((member (data cur) dat)
			 dat))))
	(test (equal? ahead behind) #t))))
  (let* ((head (make-node () 0 ()))
	 (cur head))
    (do ((i 1 (+ i 1)))
	((= i 32))
      (let ((next-node (make-node cur i ())))
	(set! (next cur) next-node)
	(set! cur (next cur))))
    (set! (next cur) head)
    (set! (prev head) cur)
    (test (object->string head) "#1=(#31=(#30=(#29=(#28=(#27=(#26=(#25=(#24=(#23=(#22=(#21=(#20=(#19=(#18=(#17=(#16=(#15=(#14=(#13=(#12=(#11=(#10=(#9=(#8=(#7=(#6=(#5=(#4=(#3=(#2=(#32=(#1# 1 #2#) 2 #3#) 3 #4#) 4 #5#) 5 #6#) 6 #7#) 7 #8#) 8 #9#) 9 #10#) 10 #11#) 11 #12#) 12 #13#) 13 #14#) 14 #15#) 15 #16#) 16 #17#) 17 #18#) 18 #19#) 19 #20#) 20 #21#) 21 #22#) 22 #23#) 23 #24#) 24 #25#) 25 #26#) 26 #27#) 27 #28#) 28 #29#) 29 #30#) 30 #31#) 31 #1#) 0 #32#)")))

(test (let ((lst (list 1 2 3))) (set! (cdr (cddr lst)) lst) (append lst lst ())) 'error)
(test (let ((lst (list 1 2 3))) (set! (cdr (cddr lst)) lst) (object->string (append (list lst) (list lst) ()))) "(#1=(1 2 3 . #1#) #1#)")

(let ((ht (make-hash-table 3)))
  (set! (ht "hi") ht)
  (test (object->string ht) "#1=#<hash-table (\"hi\" . #1#)>")
  (test (equal? (ht "hi") ht) #t))

(let ((l1 '(0)) (l2 '(0))) 
  (set! (car l1) l1) (set! (cdr l1) l1) (set! (car l2) l2) (set! (cdr l2) l2)
  (test (object->string l1) "#1=(#1# . #1#)")
  (test (equal? l1 l2) #t)
  (set! (cdr l1) l2)
  (test (object->string l1) "#1=(#1# . #2=(#2# . #2#))")
  (test (equal? l1 l2) #t)
  (set! (cdr l1) '())
  (test (equal? l1 l2) #f))

(let ((lst (list 1 2 3)))
  (set! (cdr (cddr lst)) lst)
  (test (map (lambda (a b)
	       (+ a b))
	     (list 4 5 6)
	     lst)
	'(5 7 9)))
(test (let ((lst (list 1 2 3)) 
	    (result '()))
	(set! (cdr (cddr lst)) lst)
	(for-each (lambda (a b)
		    (set! result (cons (+ a b) result)))
		  (list 4 5 6)
		  lst)
	result)
      '(9 7 5))
(let ((lst (list 1 2 3)))
  (set! (cdr (cddr lst)) lst)
  (test (map (lambda (a b)
	       (+ a b))
	     (vector 4 5 6)
	     lst)
	'(5 7 9)))
(test (let ((lst (list 1 2 3)))
	(set! (cdr (cddr lst)) lst)
	(map (lambda (a b)
	       (+ a b))
	     (vector 4 5 6 7 8 9 10)
	     lst))
      '(5 7 9 8 10 12 11))
(test (map (lambda (a) a) '(0 1 2 . 3)) '(0 1 2))
(test (let ((ctr 0)) (for-each (lambda (a) (set! ctr (+ ctr a))) '(1 2 . 3)) ctr) 3)
(let ((lst (list 1 2 3)))
  (set! (cdr (cddr lst)) lst)
  (test (map (lambda (a b)
	       (+ a b))
	     '()
	     lst)
	'()))
(test (let ((lst (list 1 2 3))
	    (ctr 0))
	(set! (cdr (cddr lst)) lst)
	(for-each (lambda (a b)
		    (set! ctr (+ ctr (+ a b))))
		  lst '())
	ctr)
      0)

(test (let ((lst (list 1))) (set! (cdr lst) (car lst)) (object->string lst)) "(1 . 1)")
(test (let ((lst (list 1))) (set! (car lst) (cdr lst)) (object->string lst)) "(())")

(let ((ctr 0) (lst `(let ((x 3)) (set! ctr (+ ctr 1)) (set! (cdr (cddr lst)) `((+ x ctr))) (+ x 1))))
  (test (eval lst) 4)
  (test (eval lst) 5)
  (test (eval lst) 6))
  

(let ()
  (define fact         ; Reini Urban, http://autocad.xarch.at/lisp/self-mod.lsp.txt
    (let ((old '())
	  (result '()))
      
      (define (last lst)
	(list-tail lst (- (length lst) 1)))
      
      (define (butlast lis)
	(let ((len (length lis)))
	  (if (<= len 1) '()
	      (let ((result '()))
		(do ((i 0 (+ i 1))
		     (lst lis (cdr lst)))
		    ((= i (- len 1)) (reverse result))
		  (set! result (cons (car lst) result)))))))
      
      (lambda (n)
	(cond ((zero? n) 1)
	      (#t 
	       (set! old (procedure-source fact))
	       (set! fact (apply lambda '(n)
				 `((cond 
				    ,@(butlast (cdr (car (cdr (cdr old)))))
				    ((= n ,n) ,(let ()
						 (set! result (* n (fact (- n 1))))
						 result))
				    ,@(last (cdr (car (cdr (cdr old)))))))))
	       result)))))

  (test (fact 3) 6)
  (test (fact 5) 120)
  (test (fact 2) 2))

(test (let ((f #f))
	(set! f (lambda () 
		  (let* ((code (procedure-source f))
			 (pos (- (length code) 1)))
		    (set! (code pos) (+ (code pos) 1)))
		  1))
	(f) (f) (f))
      4)

(let* ((x (list 1 2 3)) ; from Lambda the Ultimate I think -- I lost the reference
       (y (list 4 5))	
       (z (cons (car x) (cdr y)))
       (w (append y z))
       (v (cons (cdr x) (cdr y))))
  (set-car! x 6)
  (set-car! y 7)
  (set-cdr! (cdr x) (list 8))
  (test (object->string (list x y z w v)) "((6 . #3=(2 8)) (7 . #1=(5)) #2=(1 . #1#) (4 5 . #2#) (#3# . #1#))"))
;; guile gets this result, but prints it as: ((6 2 8) (7 5) (1 5) (4 5 1 5) ((2 8) 5))

#|
(define (for-each-permutation func vals)          ; for-each-combination -- use for-each-subset below
  "(for-each-permutation func vals) applies func to every permutation of vals"
  ;;   (for-each-permutation (lambda args (format #t "~{~A~^ ~}~%" args)) '(1 2 3))
  (define (pinner cur nvals len)
    (if (= len 1)
	(apply func (cons (car nvals) cur))
	(do ((i 0 (+ i 1)))                       ; I suppose a named let would be more Schemish
	    ((= i len))
	  (let ((start nvals))
	    (set! nvals (cdr nvals))
	    (let ((cur1 (cons (car nvals) cur)))  ; add (car nvals) to our arg list
	      (set! (cdr start) (cdr nvals))      ; splice out that element and 
	      (pinner cur1 (cdr start) (- len 1)) ;   pass a smaller circle on down
	      (set! (cdr start) nvals))))))       ; restore original circle
  (let ((len (length vals)))
    (set-cdr! (list-tail vals (- len 1)) vals)    ; make vals into a circle
    (pinner '() vals len)
    (set-cdr! (list-tail vals (- len 1)) '())))   ; restore its original shape
|#

#|
;; a slightly faster version (avoids consing and some recursion)
(define (for-each-permutation func vals)          ; for-each-combination -- use for-each-subset below
  "(for-each-permutation func vals) applies func to every permutation of vals"
  ;;   (for-each-permutation (lambda args (format #t "~A~%" args)) '(1 2 3))
  (let ((cur (make-list (length vals))))

    (define (pinner nvals len)
      (if (= len 2)
	  (begin
	    (set! (cur 0) (car nvals))
	    (set! (cur 1) (cadr nvals))
	    (apply func cur)
	    (set! (cur 1) (car nvals))
	    (set! (cur 0) (cadr nvals))
	    (apply func cur))
		
	(do ((i 0 (+ i 1)))                       ; I suppose a named let would be more Schemish
	    ((= i len))
	  (let ((start nvals))
	    (set! nvals (cdr nvals))
	    (set! (cur (- len 1)) (car nvals)) 
	    (set! (cdr start) (cdr nvals))        ; splice out that element and 
	    (pinner (cdr start) (- len 1))        ;   pass a smaller circle on down
	    (set! (cdr start) nvals)))))          ; restore original circle

  (let ((len (length vals)))
    (set-cdr! (list-tail vals (- len 1)) vals)    ; make vals into a circle
    (pinner vals len)
    (set-cdr! (list-tail vals (- len 1)) '()))))  ; restore its original shape
|#

;; and continuing down that line...
(define (for-each-permutation func vals)          ; for-each-combination -- use for-each-subset below
  "(for-each-permutation func vals) applies func to every permutation of vals"
  ;;   (for-each-permutation (lambda args (format #t "~A~%" args)) '(1 2 3))
  (let ((cur (make-list (length vals))))

    (define (pinner nvals len)
      (if (= len 3)
	  (let ((a0 (car nvals))
		(a1 (cadr nvals))
		(a2 (caddr nvals)))
	    (set! (cur 0) a2)
	    (set! (cur 1) a0)
	    (set! (cur 2) a1)
	    (apply func cur)
	    (set! (cur 0) a0)
	    (set! (cur 1) a2)
	    ;(set! (cur 2) a1)
	    (apply func cur)
	    ;(set! (cur 0) a0)
	    (set! (cur 1) a1)
	    (set! (cur 2) a2)
	    (apply func cur)
	    (set! (cur 0) a1)
	    (set! (cur 1) a0)
	    ;(set! (cur 2) a2)
	    (apply func cur)
	    ;(set! (cur 0) a1)
	    (set! (cur 1) a2)
	    (set! (cur 2) a0)
	    (apply func cur)
	    (set! (cur 0) a2)
	    (set! (cur 1) a1)
	    ;(set! (cur 2) a0)
	    (apply func cur)
	    )
		
	(do ((i 0 (+ i 1)))                       
	    ((= i len))
	  (let ((start nvals))
	    (set! nvals (cdr nvals))
	    (list-set! cur (- len 1) (car nvals)) 
	    (set! (cdr start) (cdr nvals))        ; splice out that element and 
	    (pinner (cdr start) (- len 1))        ;   pass a smaller circle on down
	    (set! (cdr start) nvals)))))          ; restore original circle

  (let ((len (length vals)))
    (if (< len 2)
	(apply func vals)
	(if (= len 2)
	    (begin
	      (set! (cur 0) (car vals))
	      (set! (cur 1) (cadr vals))
	      (apply func cur)
	      (set! (cur 1) (car vals))
	      (set! (cur 0) (cadr vals))
	      (apply func cur))
	    (begin
	      (set-cdr! (list-tail vals (- len 1)) vals)    ; make vals into a circle
	      (pinner vals len)
	      (set-cdr! (list-tail vals (- len 1)) '())))))))  ; restore its original shape




  ;; t224 applies this to +/*

(let ((perms '((3 1 2) (1 3 2) (1 2 3) (2 1 3) (2 3 1) (3 2 1)))
      (pos '()))
  (for-each-permutation
   (lambda args
     (call-with-exit
      (lambda (ok)
	(let ((ctr 0))
	  (for-each
	   (lambda (a)
	     (if (equal? a args)
		 (begin
		   (set! pos (cons ctr pos))
		   (ok)))
	     (set! ctr (+ ctr 1)))
	   perms)))))
   '(1 2 3))
  (test pos '(5 4 3 2 1 0)))

(test (let ((v1 (make-vector 16 0)) 
	    (v2 (make-vector 16 0))) 
	(set! (v2 12) v2) 
	(set! (v1 12) v1) 
	(equal? v1 v2))        ; hmmm -- not sure this is correct
      #t)
(test (let ((lst1 (list 1)) 
	    (lst2 (list 1))) 
	(set-cdr! lst1 lst1) 
	(set-cdr! lst2 lst2) 
	(equal? lst1 lst2))
      #t)


(test (let ((hi 3))
	(let ((e (current-environment)))
	  (set! hi (current-environment)) 
	  (object->string e)))
      "#1=#<environment
  #<slot: hi #<environment
  #<slot: e #1#>>>>")
