(test (call-with-values (lambda () (values 1 2 3)) +) 6)
(test (call-with-values (lambda () (values 4 5)) (lambda (a b) b))  5)
(test (call-with-values (lambda () (values 4 5)) (lambda (a b) (+ a b))) 9)
(test (call-with-values * -) -1) ; yeah, right... (- (*))
(test (values 1) 1)
(test (call-with-values (lambda () (values 1 2 3 4)) list) (list 1 2 3 4))
(test (+ (values 1) (values 2)) 3)
(test (+ (values '1) (values '2)) 3)
(test (if (values #t) 1 2) 1)
(test (if (values '#t) 1 2) 1)
(test (if (values #f) 1 2) 2)
(test (if (values #f #f) 1 2) 1)
(test (equal? (values #t #t)) #t)
(test (call-with-values (lambda () 4) (lambda (x) x)) 4)
(test (let () (values 1 2 3) 4) 4)
(test (apply + (values '())) 0)
(test (+ (values 1 2 3)) 6)
(test (let ((f (lambda () (values 1 2 3)))) (+ (f))) 6)
(num-test (log (values 8 2)) 3)
(test (* (values 2 (values 3 4))) 24)
(test (* (values (+ (values 1 2)) (- (values 3 4)))) -3)
(test (list (values 1 2) (values 3) 4) '(1 2 3 4))
(test (let ((f1 (lambda (x) (values x (+ x 1)))) (f2 (lambda () (values 2)))) (+ (f1 3) (* 2 (f2)))) 11)
(test (+ (let () (values 1 2)) 3) 6)
(test (let () (values 1 2) 4) 4)
(test (let () + (values 1 2) 4) 4)
(test (string-ref (values "hiho" 2)) #\h)
(test (vector-ref (values (vector 1 2 3)) 1) 2)
(test (+ (values (+ 1 (values 2 3)) 4) 5 (values 6) (values 7 8 (+ (values 9 10) 11))) 66)
(test (+ (if (values) (values 1 2) (values 3 4)) (if (null? (values)) (values 5 6) (values 7 8))) 18) ; (values) is now #<unspecified> (sort of)
(test (+ (cond (#f (values 1 2)) (#t (values 3 4))) 5) 12)
(test (+ (cond (#t (values 1 2)) (#f (values 3 4))) 5) 8)
(test (apply + (list (values 1 2))) 3)
(test (apply + (list ((lambda (n) (values n (+ n 1))) 1))) 3)
(test (+ (do ((i 0 (+ i 1))) ((= i 3) (values i (+ i 1))))) 7)
(test (+ (with-input-from-string "(values 1 2 3)" (lambda () (eval (read)))) 2) 8)
(test (< (values 1 2 3)) #t)
(test (apply (values + 1 2) '(3)) 6)
(test (let () (define-macro (hi a) `(+ 1 ,a)) (hi (values 1 2 3))) 7)
(test (+ 1 (eval-string "(values 2 3 4)")) 10)
(test (+ 1 (eval '(values 2 3 4))) 10)
(test (or (values #t) #f) #t)
(test (and (values #t) #f) #f)
(test (let ((x 1)) (set! x (values 32)) x) 32)
(test (let ((x #(32 33))) ((values x) 0)) 32)
(test (let ((x #(32 33))) (set! ((values x) 0) 123) x) #(123 33))
(test (list-ref '(1 (2 3)) (values 1 1)) 3)
(test (list-ref (values '(1 (2 3)) 1 1)) 3)
(test (list-ref ((lambda () (values '(1 (2 3)) 1 1)))) 3)
(test (set! (values) 1) 'error)
(test (+ (values (begin (values 1 2)) (let ((x 1)) (values x (+ x 1))))) 6)
(test (vector 1 (values 2 3) 4) #(1 2 3 4))
(test (vector (values 1 (values 2 3) (values (values 4)))) #(1 2 3 4))
(test(+ 1 (values (values (values 2) 3) (values (values (values 4)) 5) 6) 7) 28)
(test (map (values values #(1 2))) '(1 2))
(test ((values values) (values 0)) 0)
(test (((values values values) 0)) 0)
(test ((apply (values values values '((1 2))))) '(1 2))
(test (apply begin (values (list 1))) 1)
(test (apply begin (values '(values "hi"))) (apply (values begin '(values "hi"))))
(test ((object->string values) (abs 1)) #\a)
(test (list? (values 1 2 3)) 'error)
(test (list? (values 1)) #f)
(test (list? (values (list 1 2 3))) #t)

(test (let ((x 1)) (set! x (values)) x) 'error)
(test (let ((x 1)) (set! x (values 1 2 3)) x) 'error)
(test (let ((x 1)) (set! x (values 2)) x) 2)
(test (let ((x 1)) (set! (values x) 2) x) 'error) ; (no generalized set for values, so (values x) is not the same as x
(test (let ((x #(0 1))) (set! (values x 0 32)) x) 'error)
(test (let ((var (values 1 2 3))) var) 'error)
(test (let* ((var (values 1 2 3))) var) 'error)
(test (letrec ((var (values 1 2 3))) var) 'error)
(test (let ((x ((lambda () (values 1 2))))) x) 'error)
(test (+ 1 ((lambda () ((lambda () (values 2 3)))))) 6)
(test (let () (define (hi) (symbol? (values 1 2 3))) (hi)) 'error)
(test (let () (define (hi) (symbol? (values))) (hi)) #f) ; this is consistent with earlier such cases: (boolean? (values))
(test (let () (define (hi) (symbol? (values 'a))) (hi)) #t)
(test (let () (define (hi) (symbol? (values 1))) (hi)) #f)
(test (let () (define (hi a) (log (values 1 2) a)) (hi 2)) 'error)
(test (let () (define (arg2 a) (let ((b 1)) (set! b (+ a b)) (values b a))) (define (hi c) (expt (abs c) (arg2 2))) (hi 2)) 'error)
(test (let () (define (arg2 a) (let ((b 1)) (set! b (+ a b)) (values b))) (define (hi c) (expt (abs c) (arg2 2))) (hi 2)) 8)
(test (let () (define (hi) (+ (values 1 2) (values 3 4))) (hi)) 10)

(test (let ((str "hi")) (string-set! (values str 0 #\x)) str) "xi")
(test (values if) if)
(test (values quote) quote)

(test ((values '(1 (2 3)) 1 1)) 3)
(test (let ((x #(32 33))) ((values x 0))) 32)
(test (+ 1 (apply values '(2 3 4))) 10)
(test (eq? (values) (apply values '())) #t)
(test (+ 1 ((lambda args (apply values args)) 2 3 4)) 10)
(test (apply begin '(1 2 3)) 3)
(test (let ((x 1)) ((values set!) x 32) x) 32)
(let ((x 0)) (test (list (set! x 10)) (call-with-values (lambda () (set! x 10)) list))) ; from r7rs discussion

(let ()
  (define (curry function . args) 
    (lambda more-args 
      (function (apply values args) (apply values more-args)))) ; unfortunately this doesn't handle 0 args
  (test ((curry + 1 2) 3 4) 10))

(let ()
  (define (curry function . args)
    (if (null? args)
	function
	(lambda more-args
	  (if (null? more-args)
	      (apply function args)
	      (function (apply values args) (apply values more-args))))))
  (test ((curry + 1 2) 3 4) 10)
  (test ((curry + 2) 3 4) 9)
  (test ((curry +) 3 4) 7)
  (test ((curry +)) 0)
  (test ((curry + 1 2)) 3)
  (test ((curry + 1)) 1)
  (test ((curry +) 1) 1))

(test (or (values #t #f) #f) #t)
(test (or (values #f #f) #f) #f)
(test (or (values #f #t) #f) #t)
(test (or (values #f #f) #t) #t)
(test (or (values 1 2) #f) 1)
(test (+ 1 (or (values 2 3) 4)) 3)
(test (+ 1 (and 2 (values 3 4)) 5) 13)
(test (and (values) 1) 1)
(test (and (values 1 2 #f) 4) #f)
(test (and (values 1 2 3) 4) 4)
(test (length (values '())) 0)
(test (length (values #(1 2 3 4))) 4)
(test (vector? (values #())) #t)
(test (map + (values '(1 2 3) #(1 2 3))) '(2 4 6))
(test (map + (values '(1 2 3)) (values #(1 2 3))) '(2 4 6))
(test (map + (values '(1 2 3) #(4 5 6)) (values '(7 8 9))) '(12 15 18))

(test (let ((x 1)) 
	(and (let () (set! x 2) #f) 
	     (let () (set! x 3) #f)) 
	x) 2)
(test (let ((x 1)) 
	(and (values (let () (set! x 2) #f) 
		     (let () (set! x 3) #f)))
	x) 3)

(test (+ (values 1 2) 3) 6)
(test (+ (values 1 (values 2))) 3)
(test (list (values 1 2)) '(1 2))
(test (+ 6 (values 1 (values 2 3) 4 ) 5) 21)
(test (+ ((lambda (x) (values (+ 1 x))) 2) 3) 6)
(test (list ((lambda (x) (values (+ 1 x))) 2)) '(3))
(test (+ (begin (values 1 2))) 3)
(test (+ 1 (let () (values 1 2))) 4)
(test (apply (values + 1 2) (list 3)) 6)
(test ((lambda* ((a 1) (b 2)) (list a b)) (values :a 3)) '(3 2))
(test (+ (values (values 1 2) (values 4 5))) 12)
(test (+ (begin 3 (values 1 2) 4)) 4)
(test (map (lambda (x) (if #f x (values))) (list 1 2)) '())
(test (map (lambda (x) (if #f x (begin (values)))) (list 1 2)) '())
(test (map (lambda (x) (if (odd? x) (values x (* x 20)) (values))) (list 1 2 3 4)) '(1 20 3 60))
(test (map (lambda (x) (if (odd? x) (values x (* x 20)) (if #f #f))) (list 1 2 3 4)) '(1 20 #<unspecified> 3 60 #<unspecified>))
(test (map (lambda (x) (if (odd? x) (apply values '(1 2 3)) (values))) (list 1 2 3 4)) '(1 2 3 1 2 3))
(test (object->string (map (lambda (x) (if (odd? x) (values x (* x 20)) (values))) (list 1 2 3 4))) "(1 20 3 60)") ; make sure no "values" floats through
(test (map (lambda (x) (if (odd? x) (values x (* x 20) (cons x (+ x 1))) (values))) (list 1 2 3 4 5 6)) '(1 20 (1 . 2) 3 60 (3 . 4) 5 100 (5 . 6)))
(test (* 2 (case 1 ((2) (values 3 4)) ((1) (values 5 6)))) 60)
(test (* 2 (case 1 ((2) (values 3 4)) (else (values 5 6)))) 60)
(test (* 2 (case 1 ((1) (values 3 4)) (else (values 5 6)))) 24)
(test (+ (values (* 3 2) (abs (values -1)))) 7)
(test (+ (let ((x 1)) (values x (+ x 1))) (if #f #f (values 2 3))) 8)

(test (let ((sum 0)) (for-each (lambda (n m p) (set! sum (+ sum n m p))) (values (list 1 2 3) (list 4 5 6) (list 7 8 9))) sum) 45)
(test (map (lambda (n m p) (+ n m p)) (values (list 1 2 3) (list 4 5 6) (list 7 8 9))) '(12 15 18))
(test (string-append (values "123" "4" "5") "6" (values "78" "90")) "1234567890")
(test (+ (dynamic-wind (lambda () #f) (lambda () (values 1 2 3)) (lambda () #f)) 4) 10)

(for-each
 (lambda (arg)
   (test (values arg) arg))
 (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))

(for-each
 (lambda (arg)
   (test (apply values arg) 'error)
   (test (apply values (list arg)) arg))
 (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t '(1 . 2)))

(for-each
 (lambda (arg)
   (test (call-with-values (lambda () (values arg arg)) (lambda (a b) b)) arg))
 (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))

(test (call-with-values (lambda () (values "hi" 1 3/2 'a)) (lambda (a b c d) (+ b c))) 5/2)
					;(test (call-with-values values (lambda arg arg)) '())
(test (string-ref (values "hi") 1) #\i)
(test ((lambda (a b) (+ a b)) ((lambda () (values 1 2)))) 3)

(test (list (letrec ((split (lambda (ls)
			      (if (or (null? ls) (null? (cdr ls)))
				  (values ls '())
				  (call-with-values
				      (lambda () (split (cddr ls)))
				    (lambda (odds evens)
				      (values (cons (car ls) odds)
					      (cons (cadr ls) evens))))))))
	      (split '(a b c d e f))))
      '((a c e) (b d f)))

(let ()
  (define (f1 . args)
    (apply values (+ (car args) (cadr args)) (cddr args)))
  (test (* (f1 2 3 4)) 20)
  (test (* (f1 2 3 4) (f1 1 2 3)) 180)
  (test (- (f1 2 3 4) (f1 1 2 3)) -5))

(test (call-with-values (lambda () (call/cc (lambda (k) (k 2 3)))) (lambda (x y) (list x y))) '(2 3))
(test (+ (call/cc (lambda (return) (return (values 1 2 3)))) 4) 10)

(test (let ((values 3)) (+ 2 values)) 5)
(test (let ((a (values 1))) a) 1)

(test (call-with-values (lambda () 2) (lambda (x) x)) 2)
(test (call-with-values (lambda () -1) abs) 1)
(test (call-with-values (lambda () (values -1)) abs) 1)
(test (call-with-values (lambda () (values -1)) (lambda (a) (abs a))) 1)

(test (call-with-values 
	  (lambda ()
	    (values
	     (call-with-values (lambda () (values 1 2 3)) +)
	     (call-with-values (lambda () (values 1 2 3 4)) *)))
	(lambda (a b)
	  (- a b)))
      -18)

(test (call-with-values 
	  (lambda ()
	    (values
	     (call-with-values (lambda () (values 1 2 3)) +)
	     (call-with-values (lambda () (values 1 2 3 4)) *)))
	(lambda (a b)
	  (+ (* a (call-with-values (lambda () (values 1 2 3)) +))
	     (* b (call-with-values (lambda () (values 1 2 3 4)) *)))))
      612)

(test (call-with-values (lambda (x) (+ x 1)) (lambda (y) y)) 'error)
(test (+ (values . 1)) 'error)
(for-each
 (lambda (arg)
   (test (call-with-values arg arg) 'error))
 (list "hi" -1 #\a 1 'a-symbol 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))
(test (call-with-values (lambda () (values -1 2)) abs) 'error)

(test (multiple-value-bind (a b) (values 1 2) (+ a b)) 3)
(test (multiple-value-bind (a) 1 a) 1)
(test (multiple-value-bind (a . rest) (values 1 2 3) (+ a (apply + rest))) 6)
(test (multiple-value-bind a (values 1 2 3) a) '(1 2 3))

(test (let ((a 1)
	    (b 2))
	(multiple-value-set! (a b) (values 32 64))
	(+ a b))
      96)
(test (let ((add (lambda (a b) (values (+ a 1) (+ b 1))))) (+ 1 (add 2 3))) 8)
(test (min (values 1 2) (values 3 0)) 0)
(test ((lambda* ((a 1) (b 2)) (list a b)) (values :b 231)) '(1 231))
(test (cons (values 1 2) (values 3 4)) 'error)

(test (cond ((values) 3) (#t 4)) 3)          ; an error in Guile "zero values returned"
(test (cond ((values (values)) 3) (#t 4)) 3) ; same
(test (+ (cond (#t (values 1 2)))) 3)        ; 1 in guile
(test (+ (cond ((values 3 4) => (lambda (a) a)))) 'error)
(test (+ (cond ((values 3 4) => (lambda (a b) (values a b))))) 7)
(test (+ 1 (cond ((values 2 3))) 4) 10)
(test (+ 1 (values)) 'error)

(test (case (values 1) ((1) 2) (else 3)) 2)
(test (case (values 1 2) ((1) 2) (else 3)) 3)
(test (case (values 1) (((values 1)) 2) (else 3)) 3)
(test (case (values 1 2) (((values 1 2)) 2) (else 3)) 3)

(test ((values) 0) 'error)
(test ((values "hi") 1) #\i)
(test (string-ref (values "hi") 0) #\h)
(test (string-ref (values "hi" "ho") 0) 'error)
(test (let ((str "hi")) (set! ((values str) 0) #\x) str) "xi")
(test (let ((str "hi")) (string-set! (values str) 0 #\x) str) "xi")
(test (let ((str "hi")) (set! (values str 0) #\x) str) 'error)
(test (let ((str "hi")) (string-set! (values str 0) #\x) str) "xi")

(test ((values 1 2 3) 0) 'error)
(test ((values "hi" "ho") 1) 'error)
(test ((values + 1 2 3)) 6)
(test ((values + 1 2) 3) 6)
(test ((values +) 1 2 3) 6)
(test ((values "hi" 0)) #\h)
(test ((values + 1) (values 2 3) 4) 10)
(test ((values - 10)) -10)
(test ((values - -10) 0) -10) ; looks odd but it's (- -10 0) that is (- a) != (- a 0)
(test ((values - 2 3) 0) -1)
(test ((values - 2 3) 1) -2)
(test ((values - 2 3) 2) -3)  ; it's actually (- 2 3 2) -> -3

(test (let ((str "hi")) (set! ((values str 0) 0) #\x) str) 'error)
(test (let ((str "hi")) (set! ((values str) 0) #\x) str) "xi")
(test (+ (let ((x 0)) (do ((i (values 0) (+ i 1))) (((values = i 10)) (values x 2 3)) (set! x (+ x i)))) 4) 54)

(test (map values (list (values 1 2) (values 3 4))) '(1 2 3 4))
(test (let () (define-macro (hi a) `(+ 1 ,a)) (hi (values 2 3 4))) 10)
(test (let () (+ 4 (let () (values 1 2 3)) 5)) 15)
(test (let* () (+ 4 (let () (values 1 2 3)) 5)) 15)
(test (let () (+ 4 (let* () (values 1 2 3)) 5)) 15)
(test (letrec () (+ 4 (let () (values 1 2 3)) 5)) 15)
(test (let () (+ 4 (letrec () (values 1 2 3)) 5)) 15)
(test (letrec* () (+ 4 (let () (values 1 2 3)) 5)) 15)
(test (let* () (+ 4 (letrec* () (values 1 2 3)) 5)) 15)

(test (cons (values 1 2)) '(1 . 2))
(test (number->string (values 1 2)) "1")
(test (object->string (values)) "#<unspecified>")
(test (equal? (values) #<unspecified>) #t)
(test (equal? (begin) (begin (values))) #f) ; () but #<unspecified>
(test (map (lambda (x) (if #f x #<unspecified>)) (list 1 2)) '(#<unspecified> #<unspecified>))
(test (equal? (values) (if #f #f)) #t)
(test (substring (values "hi") (values 1 2)) "i")
(test (cond (call-with-exit (values "hi"))) "hi")
(test (procedure-arity (cond (values))) '(0 0 #t)) ; values as a procedure here
(test (procedure-arity 'values) '(0 0 #t))
(test (values (begin (values "hi"))) "hi")
(test (< (values (values 1 2))) #t)

(test (let ((lst (list 0)))
	(set-cdr! lst lst)
	(format (values #f "~A" lst)))
      "#1=(0 . #1#)")

(let ()
  (define (mv n)
    (define (mv-1 a)
      (values a (+ a 1)))
    (define (mv-2 b)
      (values b (* b 2)))
    (values n (mv-1 n) (mv-2 n)))
  (test (list (mv 2)) '(2 2 3 2 4))
  (test (+ (mv 1) (mv 3)) 26))

(let ()
  (define (fib n)
    (define (1st a b) 
      a)
    (define (fib-1 n)
      (if (< n 3)
	  (values 1 1)
	  (values (+ (fib-1 (- n 1))) 
		  (1st (fib-1 (- n 1))))))
    (1st (fib-1 n)))
  (test (fib 8) 21)
  (test (fib 13) 233))

(let ()
  (define (fib n)
    (define (1st a b) 
      a)
    (define (2nd a b) 
      (values (+ a b) a))
    (define (fib-1 n)
      (if (< n 3)
	  (2nd 1 0)
	  (2nd (fib-1 (- n 1)))))
    (1st (fib-1 n)))

  (define (real-fib n)
    (let ((phi (/ (+ 1 (sqrt 5)) 2)))
      (floor (/ (- (expt phi n)        ; "floor" to return an integer
		   (expt (- 1 phi) n)) 
		(sqrt 5)))))

  (test (fib 8) (real-fib 8))
  (test (fib 13) (real-fib 13)))

(let ()
  (define (cfib z) ; wikipedia "generalized fibonacci numbers"
    (let ((phi (/ (+ 1 (sqrt 5)) 2))) 
      (/ (- (expt phi z) 
	    (* (expt phi (- z)) (cos (* pi z))))
	 (sqrt 5))))
  
  (num-test (cfib 3) 2.0)
  (num-test (cfib 8) 21.0)
  (num-test (cfib 3+4i) -5248.5113072837-14195.962288353i))

(num-test (let ((f- -) (f+ +)) (define (fb n) (if (< n 2.0) n (f+ (fb (f- n 1.0)) (fb (f- n 2.0))))) (fb 12.0)) 144.0)

(let ()
  (define (flatten lst) ; flatten via values and map
    (define (flatten-1 lst)
      (cond ((null? lst) (values))
	    ((not (pair? lst)) lst)
	    (#t (values (flatten-1 (car lst))
			(flatten-1 (cdr lst))))))
    (map values (list (flatten-1 lst))))

  (test (flatten '(1 2 3)) '(1 2 3))
  (test (flatten '()) '())
  (test (flatten '((1) 2 (3 4) (6 (7)))) '(1 2 3 4 6 7))
  (test (flatten '(1 ((((2)) 3)))) '(1 2 3))
  (test (flatten '(1 () 2)) '(1 2))
  (test (flatten '((1 () 2) ())) '(1 2))
  (test (flatten '(() 1 ((2 (3)) () 4))) '(1 2 3 4))
  (test (flatten '((1) 2 ((3 4) 5) ((())) (((6))) 7 8 ())) '(1 2 3 4 5 6 7 8))
  (test (flatten '(() 1 () ((2 (1)) 4) (3 2) ())) '(1 2 1 4 3 2))
  )

(let ()
  (define (flatten! lst) ; in-place flatten
    (if (not (pair? lst))
	lst
	(let loop ((L lst))
	  (if (pair? (car L))
	      (let ((end (cdr L))
		    (p (car L)))
		(set! (car L) (car p))
		(set! (cdr L) (cdr p))
		(set! (cdr (list-tail L (- (length p) 1))) end)
		(loop L))
	      (if (not (null? (cdr L)))
		  (if (null? (car L))
		      (begin
			(set! (car L) (cadr L))
			(set! (cdr L) (cddr L))
			(loop L))
		      (loop (cdr L)))))
	  (if (equal? lst '(()))
	      '()
	      (let ((len (length lst)))
		(if (null? (car (list-tail lst (- len 1))))
		    (set! (cdr (list-tail lst (- len 2))) '()))
		lst)))))

  (test (flatten! '(1 2 3)) '(1 2 3))
  (test (flatten! '()) '())
  (test (flatten! '((1) 2 (3 4) (6 (7)))) '(1 2 3 4 6 7))
  (test (flatten! '(1 ((((2)) 3)))) '(1 2 3))
  (test (flatten! '(1 () 2)) '(1 2))
  (test (flatten! '((1 () 2) ())) '(1 2))
  (test (flatten! '(() 1 ((2 (3)) () 4))) '(1 2 3 4))
  (test (flatten! '((1) 2 ((3 4) 5) ((())) (((6))) 7 8 ())) '(1 2 3 4 5 6 7 8))
  (test (flatten! '(() 1 () ((2 (1)) 4) (3 2) ())) '(1 2 1 4 3 2))
  )

(let ()
  (define (flatten x) ; standard flatten
    (cond ((null? x) '())
          ((not (pair? x)) (list x))
          (#t (append (flatten (car x))
		      (flatten (cdr x))))))

  (test (flatten '(1 2 3)) '(1 2 3))
  (test (flatten '()) '())
  (test (flatten '((1) 2 (3 4) (6 (7)))) '(1 2 3 4 6 7))
  (test (flatten '(1 ((((2)) 3)))) '(1 2 3))
  (test (flatten '(1 () 2)) '(1 2))
  (test (flatten '((1 () 2) ())) '(1 2))
  (test (flatten '(() 1 ((2 (3)) () 4))) '(1 2 3 4))
  (test (flatten '((1) 2 ((3 4) 5) ((())) (((6))) 7 8 ())) '(1 2 3 4 5 6 7 8))
  (test (flatten '(() 1 () ((2 (1)) 4) (3 2) ())) '(1 2 1 4 3 2))
  )

(test (let () (define (hi a) (+ (abs a) (values 1 2 3))) (hi -4)) 10)
(let ()
  (define (hi a)
    (let ((x 0)
	  (again #f))
      (let ((y (+ (abs a) (call/cc (lambda (r) (set! again r) 1)))))
	(set! x (+ x y))
	(if (< x 3) (again 1))
	x)))
  (test (hi 0) 3))

(let ()
  (define-macro (define-values vars . body)
    `(apply begin (map (lambda (var val) `(define ,var ,val)) ',vars (list (begin ,@body)))))

  (define-macro (let*-values vars . body)
    `(let () 
       ,@(map (lambda (nvars . nbody)
	        `(apply define-values ',nvars ',@nbody))
	      (map car vars) (map cdr vars))
       ,@body))

  (let ()
    (define-values (a b) (values 3 2))
    (test (* a b) 6))

  (let ()
    (test (let*-values (((a b) (values 3 2))) (* a b)) 6)))

(define __p__ 123)
(define current-global-environment (current-environment))

(let ((__p__ 321))
  (set! __p__ 432))

(if (not (= __p__ 123)) (format #t "__p__: ~A~%" __p__))

(let ()
  (define (args) (values __p__ (* __p__ 2)))
  (let ((__p__ 0)
	(q 1))
    (call-with-values args (lambda (a b) (set! __p__ a) (set! q b)))
    (if (not (= __p__ 123)) (format #t "    local __p__: ~A~%" __p__))
    (set! __p__ 432)
    (call-with-values args (lambda (__p__ q) (set! __p__ 321)))
    (if (not (= __p__ 432)) (format #t "    local __p__: ~A~%" __p__))))

(if (not (= __p__ 123)) (format #t "__p__: ~A~%" __p__))

(let ()
  (define-macro (args a b) `(values ,a ,b))
  (define (sp a b)
    (set! a 121))
  (define (pq __p__ q) 
    (set! __p__ q))
  (sp (args __p__ __p__))
  (pq (args __p__ 567)))

(if (not (= __p__ 123)) (format #t "__p__: ~A~%" __p__))

(let ((__p__ 321))
  (eval '(set! __p__ 432) current-global-environment)
  (if (not (= __p__ 321)) (format #t "    local __p__: ~A~%" __p__))
  (eval '(set! __p__ 123))
  (if (not (= __p__ 123)) (format #t "    local __p__: ~A~%" __p__)))

(if (not (= __p__ 432)) (format #t "__p__: ~A~%" __p__))

(let ()
  (eval '(let ((__p__ 321)) (set! __p__ 456)) current-global-environment))

(if (not (= __p__ 432)) (format #t "__p__: ~A~%" __p__))

(let ((__p__ (values __p__)))
  (if (not (= __p__ 432)) (format #t "    local __p__: ~A~%" __p__))
  (set! __p__ 123))

(if (not (= __p__ 432)) (format #t "__p__: ~A~%" __p__))

(let ()
  (define (sp __p__ q) (values __p__ q))
  (call-with-values (lambda () (sp __p__ (* __p__ 2))) (let ((__p__ 1)) (lambda (a b) (set! __p__ a)))))

(if (not (= __p__ 432)) (format #t "__p__: ~A~%" __p__))

(let ((lst (list __p__ (* __p__ 2))))
  (define-macro (sp a) `(set! __p__ ,a))
  (let ((__p__ 0)
	(q 1))
    (define (pq a) (set! __p__ a))
    (map sp (list __p__ q))
    (if (not (= __p__ 1)) (format #t "    local __p__: ~A~%" __p__))
    (for-each sp (list __p__ q))
    (if (not (= __p__ 1)) (format #t "    local __p__: ~A~%" __p__))
    (map sp lst)
    (if (not (= __p__ (* 432 2))) (format #t "    local __p__: ~A~%" __p__))
    (for-each sp lst)
    (if (not (= __p__ (* 432 2))) (format #t "    local __p__: ~A~%" __p__))
    (set! __p__ 0)
    (set! q 1)
    (map pq (list __p__ q))
    (if (not (= __p__ 1)) (format #t "    local __p__: ~A~%" __p__))
    (for-each pq (list __p__ q))
    (if (not (= __p__ 1)) (format #t "    local __p__: ~A~%" __p__))
    (map pq lst)
    (if (not (= __p__ (* 432 2))) (format #t "    local __p__: ~A~%" __p__))
    (for-each pq lst)
    (if (not (= __p__ (* 432 2))) (format #t "    local __p__: ~A~%" __p__))))

(if (not (= __p__ 432)) (format #t "__p__: ~A~%" __p__))

(if (eq? (current-environment) (global-environment)) (begin 
(let ((__p__ 1))
  (eval `(define (__p__ a) (+ a ,__p__)) current-global-environment)
  (if (not (= __p__ 1)) (format #t "    local __p__: ~A~%" __p__)))

(if (not (procedure? __p__)) (format #t "__p__: ~A~%" __p__))
(if (not (= (__p__ 2) 3)) (format #t "(__p__ 2): ~A~%" (__p__ 2)))

(let ((__p__ 1))
  (eval `(define __p__ 32))
  (if (not (= __p__ 32)) (format #t "    local __p__: ~A~%" __p__)))

(if (not (procedure? __p__)) (format #t "__p__: ~A~%" __p__))
(if (not (= (__p__ 2) 3)) (format #t "(__p__ 2): ~A~%" (__p__ 2)))

(let ((__p__ 1))
  (eval `(define __p__ 32) (current-environment))
  (if (not (= __p__ 32)) (format #t "    local __p__: ~A~%" __p__)))

(if (not (procedure? __p__)) (format #t "__p__: ~A~%" __p__))
(if (not (= (__p__ 2) 3)) (format #t "(__p__ 2): ~A~%" (__p__ 2)))
))
