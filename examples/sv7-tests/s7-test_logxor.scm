(num-test (logxor 0 1) 1)
(num-test (logxor #b101 #b10001) 20)
(num-test (logxor 1 3 6) 4)
(num-test (logxor -6 1) -5)
(num-test (logxor -6 3) -7)
(num-test (logxor #b1 #b11 #b111 #b1111) #b1010)
(num-test (logxor 12341234 10001111) 2413861)
(num-test (logxor 1 3 7 15) 10)
(num-test (logxor 0 1/1) 1)
(num-test (logxor 1/1 0) 1)
(num-test (logxor 0 1 -1) -2)
(num-test (logxor -1 -1 -1) -1) 
;; to get the bits that are on in just 1 argument? (logxor (logxor a b c) (logand a b c))
(num-test (logxor 1 2 3 4) 4)
(num-test (logxor 1 3 5 7) 0)
(num-test (logxor -1 8 8) -1)
(num-test (logxor 8 8 8) 8)
(num-test (logxor -1 most-positive-fixnum) most-negative-fixnum)
(num-test (logxor most-negative-fixnum most-positive-fixnum) -1)
(num-test (logxor -100 -100 -100) -100)
(num-test (logxor -100 -100 -100 -1) 99)
(num-test (logxor -100 -100 -100 -1 -1) -100)
(num-test (logxor 4/2 11/11) 3)
(num-test (logxor -9223372036854775808 -9223372036854775808) 0)
(num-test (logxor -9223372036854775808 9223372036854775807 -9223372036854775808) 9223372036854775807)
(num-test (logxor 9223372036854775807 -9223372036854775808) -1)
(num-test (logxor 9223372036854775807 9223372036854775807) 0)
(num-test (logxor) 0)

(if with-bignums
    (begin
      (test (logxor 37788155234994016485376 (+ (expt 2 63) 1)) (+ 1 (expt 2 75)))
      (num-test (logxor (+ (expt 2 48) (expt 2 46)) (expt 2 48)) 70368744177664)
      (test (logxor 0+92233720368547758081.0i) 'error)
      (test (logxor 92233720368547758081.0) 'error)
      ))

(test (logxor 0 1.0) 'error)
(test (logxor 0 1/2) 'error)
(test (logxor 1.0 0) 'error)
(test (logxor 1/2 0) 'error)


;;; log-n-of
(let ((top-checked-bit (if with-bignums 64 63)))

  (define (log-none-of . ints)  ; bits on in none of ints
    (lognot (apply logior ints)))

  (define (log-all-of . ints)   ; bits on in all of ints
    (apply logand ints))

  (define (log-any-of . ints)   ; bits on in at least 1 of ints
    (apply logior ints))

  (define (log-1-of . ints)     ; bits on in exactly 1 of ints
    (let ((len (length ints)))
      (cond ((= len 0) 
	     0)
	    ((= len 1) 
	     (car ints))
	    ((= len 2) 
	     (apply logxor ints))
	    ((= len 3) 
	     (logxor (apply logxor ints) (apply logand ints)))
	    (#t 
	     (do ((iors '())
		  (i 0 (+ i 1)))
		 ((= i len) (apply logior iors))
	       (let ((cur (ints i)))
		 (set! (ints i) 0)
		 (set! iors (cons (logand cur (lognot (apply logior ints))) iors))
		 (set! (ints i) cur)))))))

  (test (log-1-of 1 1) 0)
  (test (log-1-of 1 2) 3)
  (test (log-1-of 1 2 2) 1)
  (test (log-1-of 1 2 2 1) 0)
  (test (log-1-of 1 2 3 4 8 9) 4)
  (test (log-1-of -1 1 2 3) -4)
  (test (log-1-of 1 2 3 5) 4)
  (test (log-1-of -6 -31 -19 -9) 0)
  (test (log-1-of -45 -15 -7 -3) 6)
  (test (log-1-of -1 most-positive-fixnum -1) 0)
  (test (log-1-of -1 most-negative-fixnum -1) 0)
  (test (log-1-of 1 most-negative-fixnum 1) most-negative-fixnum)
  (test (log-1-of 31 11 27 -38) -60)
  (test (log-1-of -254) #b-11111110) ; (-254)
  (test (log-1-of 406 26 439 -361 -133 -480 312) #b1000000) ; (64)
  (test (log-1-of 47 110) #b1000001) ; (65)
  (test (log-1-of) 0)
  (test (log-1-of -52 108 97 48) #b-1101111) ; (-111)
  (test (log-1-of -113 -391 -129 -58 -374 -297 -498) #b0) ; (0)
  (test (log-1-of -251 138 418 494 -300 -224) #b10001) ; (17)
  (test (log-1-of 385 364 372) #b10011001) ; (153)
  (test (log-1-of -221 -56 173) #b1000110) ; (70)
  (test (log-1-of 31 -309 244 -478 396 -352 162 -479 -500) #b100000000) ; (256)
  (test (log-1-of -152 495 80 -403 -439 387) #b10000) ; (16)
  (test (log-1-of 115 71 110 568 10 382 124 378 23) #b1000000000) ; (512)
  (test (log-1-of 766 332 285 280 489 229) #b1000000010) ; (514)
  (test (log-1-of 424 935) #b1000001111) ; (527)
  (test (log-1-of 788 268 388) #b1010011000) ; (664)
  (test (log-1-of 389 237 398 530) #b1001110000) ; (624)
  (test (log-1-of 554 550 215 44 892 668) #b100000001) ; (257)
  (test (log-1-of 562 171 772 480 6 211 542 678) #b0) ; (0)

  (do ((i 0 (+ i 1)))
      ((= i 10))
    
    (let ((len (+ 1 (random 10)))
	  (ints '()))
      (do ((k 0 (+ k 1)))
	  ((= k len))
	(set! ints (cons (- (random 1000) 500) ints)))
      
      (let ((result (apply log-1-of ints)))
	;;(format #t "(test (log-1-of ~{~D~^ ~}) #b~B) ; (~D)~%" ints result result)
	
	(do ((b 0 (+ b 1)))
	    ((= b top-checked-bit))
	  (let ((counts 0))
	    (for-each
	     (lambda (int)
	       (if (logbit? int b) ;(not (zero? (logand int (ash 1 b))))
		   (set! counts (+ counts 1))))
	     ints)
	    
	    (if (logbit? result b) ;(not (zero? (logand result (ash 1 b))))
		(if (not (= counts 1))
		    (format #t ";(log-1-of ~{~D~^ ~}) -> ~A,  [#b~B, counts: ~D but we're on]~%" ints result (ash 1 b) counts))
		(if (= counts 1)
		    (format #t ";(log-1-of ~{~D~^ ~}) -> ~A,  [#b~B, counts = 1 but we're off]~%" ints result (ash 1 b)))))))))
  

  (define (log-n-1-of . ints) ; bits on in exactly n-1 of ints
    (let ((len (length ints)))
      (cond ((= len 0) 
	     0)
	    ((= len 1) 
	     0)
	    ((= len 2) 
	     (apply logxor ints))
	    ((= len 3) 
	     (logand (lognot (apply logxor ints)) (apply logior ints)))
	    (#t 
	     (do ((iors '())
		  (i 0 (+ i 1)))
		 ((= i len) (apply logior iors))
	       (let ((cur (ints i)))
		 (set! (ints i) -1)
		 (set! iors (cons (logand (lognot cur) (apply logand ints)) iors))
		 (set! (ints i) cur)))))))
  
  (test (log-n-1-of 1 1) 0)
  (test (log-n-1-of 1 2) 3)
  (test (log-n-1-of 1 2 2) 2)
  (test (log-n-1-of 1 2 2 3) 2)
  (test (log-n-1-of -336 -225 275) #b-11111101) ; (-253)
  (test (log-n-1-of -35 32 -17 -310 256 -360 171 -370) #b0) ; (0)
  (test (log-n-1-of 311 237) #b111011010) ; (474)
  (test (log-n-1-of 32 348 -340 147) #b0) ; (0)
  (test (log-n-1-of -334 -267 -478 -93 239 423 18 496) #b100000) ; (32)
  (test (log-n-1-of -347 149 135 107 -436) #b101) ; (5)
  (test (log-n-1-of -181 406 480 390 207 13 0) #b0) ; (0)
  (test (log-n-1-of 348) #b0) ; (0)
  (test (log-n-1-of -498 226) #b-100010100) ; (-276)
  (test (log-n-1-of 259 -171 146 -344 63 -240 290 -418) #b0) ; (0)
  (test (log-n-1-of 86 -74 61 -138 215 -277 358) #b110) ; (6)
  (test (log-n-1-of -144 425 -356 -341 211 -390) #b0) ; (0)
  (test (log-n-1-of -223 390 195 265) #b100000001) ; (257)
  (test (log-n-1-of 103 263 -92 -7) #b100100101) ; (293)
  (test (log-n-1-of -78 -199 68 218 -98 -464 307 301) #b0) ; (0)
  (test (log-n-1-of -355 258 -134 -371 211) #b0) ; (0)
  (test (log-n-1-of -222 -39 408 -50 -207 58) #b100000000) ; (256)
  (test (log-n-1-of 66 93 484) #b100) ; (4)
  (test (log-n-1-of 36 -384 3 49 359 -284 -284 -133 268) #b0) ; (0)
  (test (log-n-1-of -339 -50 243 -159 -159) #b-110011111) ; (-415)
  (test (log-n-1-of 154 -260 -219 400 -196 -236 421 -277 375 -67) #b0) ; (0)
  (test (log-n-1-of 45 112) #b1011101) ; (93)
  (test (log-n-1-of -493 131 48 45 311 197 491 -86 164) #b0) ; (0)
  (test (log-n-1-of 371 -75 -107 -348 -9 7 -129) #b101) ; (5)
  (test (log-n-1-of 349 -219 -160) #b-110011011) ; (-411)
  (test (log-n-1-of 412 456 407 -13 352 467 327 147) #b100000000) ; (256)
  (test (log-n-1-of 133 -133 -471 -284 -58 -266) #b-1000000000) ; (-512)
  (test (log-n-1-of 43 -339 22 150 49 259) #b0) ; (0)
  (test (log-n-1-of 258 -138 185 400 -476 -312 69 380) #b0) ; (0)
  (test (log-n-1-of 260 -85 -208 -21) #b-111100000) ; (-480)
  (test (log-n-1-of -294 177 -78) #b-111011110) ; (-478)
  (test (log-n-1-of -40 81 445 -300) #b11000000) ; (192)
  (test (log-n-1-of -325 -393 411 -441 -221 -43 -231 -283 -223) #b-1000000000) ; (-512)
  (test (log-n-1-of 18 -36 -351 -160 211 412) #b0) ; (0)
  
  (do ((i 0 (+ i 1)))
      ((= i 10))
    
    (let ((len (+ 1 (random 10)))
	  (ints '()))
      (do ((k 0 (+ k 1)))
	  ((= k len))
	(set! ints (cons (- (random 1000) 500) ints)))
      
      (let ((result (apply log-n-1-of ints)))
	;;(format #t "(test (log-n-1-of ~{~D~^ ~}) #b~B) ; (~D)~%" ints result result)
	
	(do ((b 0 (+ b 1)))
	    ((= b top-checked-bit))
	  (let ((counts 0))
	    (for-each
	     (lambda (int)
	       (if (logbit? int b) ;(not (zero? (logand int (ash 1 b))))
		   (set! counts (+ counts 1))))
	     ints)
	    
	    (if (logbit? result b) ;(not (zero? (logand result (ash 1 b))))
		(if (not (= counts (- len 1)))
		    (format #t ";(log-n-1-of ~{~D~^ ~}) -> ~A,  [#b~B, counts: ~D but we're on]~%" ints result (ash 1 b) counts))
		(if (and (> len 1) (= counts (- len 1)))
		    (format #t ";(log-n-1-of ~{~D~^ ~}) -> ~A,  [#b~B, counts: ~D but we're off]~%" ints result (ash 1 b) counts))))))))
  
  (define (log-n-of n . ints) ; bits on in exactly n of ints
    (let ((len (length ints)))
      (cond ((= len 0)
	     (if (= n 0) -1 0))
	    
	    ((= n 0)
	     (apply log-none-of ints))
	    
	    ((= n len)
	     (apply log-all-of ints))
	    
	    ((> n len)
	     0)
	    
	    ((= n 1)
	     (apply log-1-of ints))
	    
	    ((= n (- len 1))
	     (apply log-n-1-of ints))
	    
	    ;; now n is between 2 and len-2, and len is 3 or more
	    ;;   I think it would be less inefficient here to choose either this or the n-1 case based on n<=len/2
	    (#t 
	     (do ((1s '())
		  (prev ints)
		  (i 0 (+ i 1)))
		 ((= i len) (apply logior 1s))
	       (let ((cur (ints i)))
		 (if (= i 0)
		     (set! 1s (cons (logand cur (apply log-n-of (- n 1) (cdr ints))) 1s))
		     (let* ((mid (cdr prev))
			    (nxt (if (= i (- len 1)) '() (cdr mid))))
		       (set! (cdr prev) nxt)
		       (set! 1s (cons (logand cur (apply log-n-of (- n 1) ints)) 1s))
		       (set! (cdr prev) mid)
		       (set! prev mid)))))))))

  (test (log-n-of 1) 0)
  (test (log-n-of 0) -1)
  (test (log-n-of 0 -2) 1)
  (test (log-n-of 0 92 -451 317 -269 -300 245 461 -64) #b0)
  (test (log-n-of 0 287) #b-100100000) ; (-288)
  (test (log-n-of 0 -180 441 -487) #b10) ; (2)
  (test (log-n-of 0 274 150) #b-110010111) ; (-407)
  (test (log-n-of 0 140 -307 8 216 -392 8 -486 147 -469) #b100000000) ; (256)

  (test (log-n-of 1 1 1) 0)
  (test (log-n-of 1 1 2) 3)
  (test (log-n-of 2 1 2) 0)
  (test (log-n-of 2 2 2) 2)
  (test (log-n-of 2 2 2 2) 0)
  (test (log-n-of 3 2 2 2) 2)
  (test (log-n-of 3 2 2 3) 2)
  (test (log-n-of 3 2 1 3 3) 3)

  (test (log-n-of 1 158 172 -4 432 147 497 -236 85 -454 -447) #b0) ; (0)
  (test (log-n-of 1 377 -232 295) #b-110111010) ; (-442)
  (test (log-n-of 1 -110) #b-1101110) ; (-110)
  (test (log-n-of 1 304 -36 64 -140 -165 -85) #b0) ; (0)
  (test (log-n-of 1 226 -135 -392 55 -358 260 -447) #b0) ; (0)
  (test (log-n-of 1 -241 454 178 107 312) #b-1000000000) ; (-512)
  (test (log-n-of 1 -122 419 -121) #b100000) ; (32)
  (test (log-n-of 1 378 -233 -332 -308) #b1) ; (1)
  (test (log-n-of 1 -381 44 -99 -161 338) #b100000) ; (32)
  
  (test (log-n-of 2 6 -45 331 339 156 207 -308) #b-1000000000) ; (-512)
  (test (log-n-of 2 -483) #b0) ; (0)
  (test (log-n-of 2 -113 75 465 -434 -164 291) #b10010000) ; (144)
  (test (log-n-of 2 -95 -314 187 40) #b-111110101) ; (-501)
  (test (log-n-of 2 126 -254) #b10) ; (2)
  (test (log-n-of 2 -228) #b0) ; (0)
  (test (log-n-of 2 -472 163 6 -185 -208 -481 -60 -331 479) #b0) ; (0)
  (test (log-n-of 2 357 -468 490 -423 33) #b-11111100) ; (-252)
  (test (log-n-of 2 13 343 -276 148 -425 -116 361 -305 344 -361) #b100000) ; (32)
  (test (log-n-of 2 -79) #b0) ; (0)
  
  (test (log-n-of 3 268 134 46 -207 414) #b100001010) ; (266)
  (test (log-n-of 3 455 -138 58 -225 -250) #b-111110000) ; (-496)
  (test (log-n-of 3 -267 154 -217 468 -455 43 307 364) #b-101000000) ; (-320)
  (test (log-n-of 3 14 197 65 -327 -86 -438) #b-100111101) ; (-317)
  (test (log-n-of 3 229 452 434 -75 -405 440 -420 40) #b-111111111) ; (-511)
  (test (log-n-of 3 -24 -450 437 -467 -487 -479 14 394 -433 53) #b110000000) ; (384)
  (test (log-n-of 3 474 442 303 -203 -59) #b10111111) ; (191)
  (test (log-n-of 3 -401 104 66) #b1000000) ; (64)
  (test (log-n-of 3 -129 79 215 -272 -259) #b-101010110) ; (-342)
  (test (log-n-of 3 -139 36 -489 352 -364 498 -11) #b10000001) ; (129)
  
  (test (log-n-of 4 23) #b0) ; (0)
  (test (log-n-of 4 407 225 417 269 -174 181 -332) #b100110100) ; (308)
  (test (log-n-of 4 439 480 -278 168 189) #b0) ; (0)
  (test (log-n-of 4 -206 295) #b0) ; (0)
  (test (log-n-of 4 -260 24 -320) #b0) ; (0)
  (test (log-n-of 4 354 -463 -66 137 -364) #b0) ; (0)
  (test (log-n-of 4 -117 -68 -343 -285) #b-110000000) ; (-384)
  (test (log-n-of 4 -206 -449 118 -211 -125 391 232) #b-11111011) ; (-251)
  (test (log-n-of 4 -164 -499 -291 325 -143 -268 135 103) #b10000) ; (16)
  
  (do ((i 0 (+ i 1)))
      ((= i 10))
    
    (let ((len (+ 1 (random 10)))
	  (ints '())
	  (n (random 5)))
      
      (do ((k 0 (+ k 1)))
	  ((= k len))
	(set! ints (cons (- (random 1000) 500) ints)))
      
      (let ((result (apply log-n-of n ints)))
	;;(format #t "(test (log-n-of ~D ~{~D~^ ~}) #b~B) ; (~D)~%" n ints result result)
	
	(do ((b 0 (+ b 1)))
	    ((= b top-checked-bit))
	  (let ((counts 0))
	    (for-each
	     (lambda (int)
	       (if (logbit? int b) ;(not (zero? (logand int (ash 1 b))))
		   (set! counts (+ counts 1))))
	     ints)
	    
	    (if (logbit? result b) ;(not (zero? (logand result (ash 1 b))))
		(if (not (= counts n))
		    (format #t ";(log-n-of ~D ~{~D~^ ~}) -> ~A,  [#b~B, counts: ~D but we're on]~%" n ints result (ash 1 b) counts))
		(if (and (> len 1) (= counts n))
		    (format #t ";(log-n-of ~D ~{~D~^ ~}) -> ~A,  [#b~B, counts: ~D but we're off]~%" n ints result (ash 1 b) counts))))))))


  (define (simple-log-n-of n . ints)     ; bits on in exactly n of ints
    (let ((len (length ints)))
      (cond ((= len 0) (if (= n 0) -1 0))
	    ((= n 0)   (lognot (apply logior ints)))
	    ((= n len) (apply logand ints))
	    ((> n len) 0)
	    (#t 
	     (do ((1s 0)
		  (prev ints)
		  (i 0 (+ i 1)))
		 ((= i len) 1s)
	       (let ((cur (ints i)))
		 (if (= i 0)
		     (set! 1s (logior 1s (logand cur (apply simple-log-n-of (- n 1) (cdr ints)))))
		     (let* ((mid (cdr prev))
			    (nxt (if (= i (- len 1)) '() (cdr mid))))
		       (set! (cdr prev) nxt)
		       (set! 1s (logior 1s (logand cur (apply simple-log-n-of (- n 1) ints))))
		       (set! (cdr prev) mid)
		       (set! prev mid)))))))))

  (num-test (simple-log-n-of 1 0 0 -1 0) -1)
  (num-test (simple-log-n-of 1 0 -1 -1 0) 0)
  (num-test (simple-log-n-of 2 0 -1 -1 0) -1)
  (num-test (simple-log-n-of 2 0 -1 -1 -1) 0)
  (num-test (simple-log-n-of 3 0 -1 -1 -1) -1)
  (num-test (simple-log-n-of 4 0 -1 -1 -1) 0)
  
  (do ((i 0 (+ i 1)))
      ((= i 10))
    
    (let ((len (+ 1 (random 10)))
	  (ints '())
	  (n (random 5)))
      
      (do ((k 0 (+ k 1)))
	  ((= k len))
	(set! ints (cons (- (random 1000) 500) ints)))
      
      (let ((result (apply simple-log-n-of n ints)))
	(do ((b 0 (+ b 1)))
	    ((= b top-checked-bit))
	  (let ((counts 0))
	    (for-each
	     (lambda (int)
	       (if (logbit? int b) ;(not (zero? (logand int (ash 1 b))))
		   (set! counts (+ counts 1))))
	     ints)
	    
	    (if (logbit? result b) ;(not (zero? (logand result (ash 1 b))))
		(if (not (= counts n))
		    (format #t ";(simple-log-n-of ~D ~{~D~^ ~}) -> ~A,  [#b~B, counts: ~D but we're on]~%" n ints result (ash 1 b) counts))
		(if (and (> len 1) (= counts n))
		    (format #t ";(simple-log-n-of ~D ~{~D~^ ~}) -> ~A,  [#b~B, counts: ~D but we're off]~%" n ints result (ash 1 b) counts)))))))))
