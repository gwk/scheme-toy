(test (member (list 'a) '(b (a) c)) '((a) c))
(test (member "b" '("a" "c" "b")) '("b"))
(test (member 1 '(3 2 1 4)) '(1 4))
(test (member 1 (list 3 2 1 4)) '(1 4))
(test (member car (list abs car modulo)) (list car modulo))
(test (member do (list quote map do)) (list do))
(test (member 5/2 (list 1/3 2/4 5/2)) '(5/2))
(test (member 'a '(a b c d)) '(a b c d))
(test (member 'b '(a b c d)) '(b c d))
(test (member 'c '(a b c d)) '(c d))
(test (member 'd '(a b c d)) '(d))
(test (member 'e '(a b c d)) #f)
(test (member 1 (cons 1 2)) '(1 . 2))
(test (member 'a (list a b . c)) 'error)
(test (member 1 '(1 2 . 3)) '(1 2 . 3))
(test (member 2 '(1 2 . 3)) '(2 . 3))
(test (member 3 '(1 2 . 3)) #f)
(test (member 4 '(1 2 . 3)) #f)
(test (member 1/2 (list (/ 2.0) .5 1/2)) '(1/2))
(test (member) 'error)
(test (member 'a) 'error)
(test (member 'a 'b) 'error)
(test (member '() '(1 2 3)) #f)
(test (member '() '(1 2 ())) '(()))
(test (member #() '(1 () 2 #() 3)) '(#() 3))
(test (member #2d((1 2) (3 4)) '(1 #() #2d((1 2) (1 2)))) #f)
(test (member #2d((1 2) (3 4)) '(1 #() #2d((1 2) (3 4)))) '(#2d((1 2) (3 4))))
(test (let ((x (cons 1 2))) (member x (list (cons 1 2) (cons 3 4)))) '((1 . 2) (3 . 4)))
(test (let ((x (list 1 2))) (member x (list (cons 1 2) (list 1 2)))) '((1 2)))
(test (member ''a '('a b c)) '('a b c))
(test (member 'a '(a a a)) '(a a a)) ;?
(test (member 'a '(b a a)) '(a a))
(test (member (member 3 '(1 2 3 4)) '((1 2) (2 3) (3 4) (4 5))) '((3 4) (4 5)))
(test (member "hi" '(1 "hi" 2)) '("hi" 2))
(test (member #\a '(1 #f #\a 2)) '(#\a 2))
(test (let* ((x (vector 1 2 3)) (lst (list 1 "hi" x (vector 1 2)))) (member x lst)) '(#(1 2 3) #(1 2)))
(test (let* ((x (vector 1 2 3)) (lst (list 1 "hi" (vector 1 2 3)))) (member x lst)) '(#(1 2 3)))

(for-each
 (lambda (arg)
   (test (member arg (list 1 2 arg 3)) (list arg 3)))
 (list "hi" (integer->char 65) #f 'a-symbol abs 3/4 #\f #t (if #f #f) '(1 2 (3 (4))) most-positive-fixnum))

(test (member 3 . (1 '(2 3))) 'error)
(test (member 3 '(1 2 3) = =) 'error)
(test (member 3 . ('(1 2 3))) '(3))
(test (member 3 . ('(1 2 3 . 4))) '(3 . 4))
(test (member . (3 '(1 2 3))) '(3))
(test (member '(1 2) '(1 2)) #f)
(test (member '(1 2) '((1 2))) '((1 2)))
(test (member . '(quote . ((quote)))) #f)
(test (member . '(quote . ((quote) .()))) #f)
(test (member '(((1))) '((((1).()).()).())) '((((1)))))
(test (member '((1)) '(1 (1) ((1)) (((1))))) '(((1)) (((1)))))
(test (member member (list abs car memq member +)) (list member +))

(let ((odd '(3 a 3.0 b 3/4 c #(1) d))
      (even '(e 3 a 3.0 b 3/4 c #(1) d)))
  (test (member 'a odd) '(a 3.0 b 3/4 c #(1) d))
  (test (member 'a even) '(a 3.0 b 3/4 c #(1) d))
  (test (member 3/4 odd) '(3/4 c #(1) d))
  (test (member 3/4 even) '(3/4 c #(1) d))
  (test (member 3.0 odd) '(3.0 b 3/4 c #(1) d))
  (test (member 3.0 even) '(3.0 b 3/4 c #(1) d))
  (test (member #(1) odd) '(#(1) d))
  (test (member #(1) even) '(#(1) d)))

(test (member 3 '(1 2 3 4) =) '(3 4))
(test (member 3 '() =) #f)
(test (member 3 '(1 2 4 5) =) #f)
(test (member 4.0 '(1 2 4 5) =) '(4 5))
(test (member #\a '(#\b #\A #\c) char=?) #f)
(test (member #\a '(#\b #\A #\c) char-ci=?) '(#\A #\c))
(test (member #\a '(#\b #\A #\c) (lambda (a b) (char-ci=? a b))) '(#\A #\c))
(test (char=? (car (member #\a '(#\b #\a))) #\a) #t)
(test (char=? (car (member #\a '(#\b #\a) (lambda (a b) (char=? a b)))) #\a) #t)
(test (member 3 '(1 2 3 4) <) '(4))
(test (member 3 '((1 2) (3 4)) member) '((3 4)))
(test (member 3 '(((1 . 2) (4 . 5)) ((3 . 4))) assoc) '(((3 . 4))))
(test (member '(#f #f #t) '(0 1 2) list-ref) '(2))
(test (let ((v (vector 1 2 3))) (member v (list 0 v) vector-fill!)) '(0 #(0 0 0)))

(test (member 3 '(1 2 3) abs) 'error)
(test (member 3 '(1 2 3) quasiquote) 'error)
(test (member 3 '(1 2 3) (lambda (a b c) (= a b))) 'error)
(test (member 3 '(1 2 3) (lambda* (a b c) (= a b))) '(3))
(test (member 3 '(1 2 3 4) (make-procedure-with-setter = =)) '(3 4))
(test (catch #t (lambda () (member 3 '(1 2 3) (lambda (a b) (error 'member a)))) (lambda args (car args))) 'member)
(test (call-with-exit (lambda (go) (member 3 '(1 2 3) (lambda (a b) (go 'member))))) 'member)
(test (member 'a '(a a a) eq?) '(a a a))
(test (member 'a '(b a a) eqv?) '(a a))
(test (member 3.0 '(1 #\a (3 . 3) abs #() 3+i)) #f)
(test (member 3.0 '(1 #\a (3 . 3) abs #() 3+i) (lambda (a b) (= (real-part a) b))) 'error)
(test (member 3.0 '(1 #\a (3 . 3) abs #() 3+i) (lambda (a b) (and (number? b) (= (real-part b) a)))) '(3+i))
;; is it guaranteed that in the comparison function the value is 1st and the list member 2nd?
(test (member 4 '((1 2 3) (4 5 6) (7 8 9)) member) '((4 5 6) (7 8 9)))
(test (member 4 '(1 2 3) member) 'error)
(test (member 4 '((1 2) (3 5) 7) (lambda (a b) (member a (map (lambda (c) (+ c 1)) b)))) '((3 5) 7))
(test (member 4 '((1 2) (3 5) 7) (lambda (a b) (assoc a (map (lambda (c) (cons (+ c 1) c)) b)))) '((3 5) 7))
(test (let ((f #f)) (member 'a '(a b c) (lambda (a b) (if (eq? b 'a) (set! f (lambda () b))) (eq? a 123))) (f)) 'a)
(test (let ((i 0) (f (make-vector 3))) (member 'a '(a b c) (lambda (a b) (vector-set! f i b) (set! i (+ i 1)) (eq? a 123))) f) #(a b c))
(test (member 1 '(0 1 2) (lambda (a b . c) (= a b))) '(1 2))
(test (member 1 '(0 1 2) (lambda* (a b c) (= a b))) '(1 2))
(test (member 1 '(0 1 2) (lambda (a) (= a b))) 'error)
(test (member 1 '(0 1 2) (lambda a (= (car a) (cadr a)))) '(1 2))

(test (member 'a '(c 3 a 1 b 2) (lambda (a) (eq? a b))) 'error)
(test (member 'a '(c 3 a 1 b 2) (lambda (a b) (eq? a b))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda (a b c) (eq? a b))) 'error)
(test (member 'a '(c 3 a 1 b 2) (lambda (a b c . d) (eq? a b))) 'error)
(test (member 'a '(c 3 a 1 b 2) (lambda (a b . c) (eq? a b))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda a (apply eq? a))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda (a . b) (eq? a (car b)))) '(a 1 b 2))

(test (member 'a '(c 3 a 1 b 2) (lambda* (a) (eq? a b))) 'error)
(test (member 'a '(c 3 a 1 b 2) (lambda* (a b) (eq? a b))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda* (a b c) (eq? a b))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda* (a b c . d) (eq? a b))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda* (a b . c) (eq? a b))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda* a (apply eq? a))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda* (a . b) (eq? a (car b)))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda* (a :rest b) (eq? a (car b)))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda* (a :rest b :rest c) (eq? a (car b)))) '(a 1 b 2))
(test (member 'a '(c 3 a 1 b 2) (lambda* (:rest a) (apply eq? a))) '(a 1 b 2))

(test (member 4 '(1 2 3 4 . 5)) '(4 . 5))
(test (member 4 '(1 2 3 4 . 5) =) '(4 . 5))
(test (member 4 '(1 2 3 . 4)) #f)
(test (member 4 '(1 2 3 . 4) =) #f)
(test (let ((lst (list 1 2 3))) (and (member 2 lst =) lst)) '(1 2 3))
(test (pair? (let ((lst (list 1 2 3))) (set! (cdr (cdr lst)) lst) (member 2 lst))) #t)
(test (pair? (let ((lst (list 1 2 3))) (set! (cdr (cdr lst)) lst) (member 2 lst =))) #t)
(test (let ((lst (list 1 2 3))) (set! (cdr (cdr lst)) lst) (member 4 lst)) #f)
(test (let ((lst (list 1 2 3))) (set! (cdr (cdr lst)) lst) (member 4 lst =)) #f)
(test (pair? (let ((lst (list 1 2 3))) (set! (cdr (cdr (cdr lst))) lst) (member 3 lst =))) #t)
(test (pair? (let ((lst (list 1 2 3 4))) (set! (cdr (cdr (cdr lst))) (cdr (cdr lst))) (member 3 lst =))) #t)
(test (let ((lst (list 1 2 3 4))) (set! (cdr (cdr (cdr lst))) (cdr (cdr lst))) (member 5 lst =)) #f)
(test (let ((lst (list 1 2 3 4))) (set! (cdr (cdr (cdr lst))) (cdr lst)) (member 4 lst =)) #f)
(test (let ((lst '(1 2 3 5 6 9 10))) (member 3 lst (let ((last (car lst))) (lambda (a b) (let ((result (= (- b last) a))) (set! last b) result))))) '(9 10))
(test (let ((lst '(1 2 3 5 6 9 10))) (member 2 lst (let ((last (car lst))) (lambda (a b) (let ((result (= (- b last) a))) (set! last b) result))))) '(5 6 9 10))
(test (member 1 '() =) #f)
(test (member 1 #(1) =) 'error)
(test (member 3 '(5 4 3 2 1) >) '(2 1))
(test (member 3 '(5 4 3 2 1) >=) '(3 2 1))
(test (member '(1 2) '((1) (1 . 2) (1 2 . 3) (1 2 3) (1 2) 1 . 2)) '((1 2) 1 . 2))
(test (member '(1 2 . 3) '((1) (1 . 2) (1 2 . 3) (1 2 3) (1 2) 1 . 2)) '((1 2 . 3) (1 2 3) (1 2) 1 . 2))

(let ()
  (define-macro (do-list lst . body) 
    `(member #t ,(cadr lst) (lambda (a b) 
			      (let ((,(car lst) b)) 
				,@body 
				#f))))
  (let ((sum 0))
    (do-list (x '(1 2 3)) (set! sum (+ sum x)))
    (test (= sum 6) #t)))

(let ()
  (define (tree-member a lst) 
    (member a lst (lambda (c d) 
		    (if (pair? d) 
			(tree-member c d) 
			(equal? c d)))))
  (test (tree-member 1 '(2 3 (4 1) 5)) '((4 1) 5))
  (test (tree-member -1 '(2 3 (4 1) 5)) #f)
  (test (tree-member 1 '(2 3 ((4 (1) 5)))) '(((4 (1) 5)))))

(let ((lst (list 1 2 3)))
  (set! (cdr (cdr (cdr lst))) lst)
  (test (member 2 lst) (member 2 lst equal?)))

(let ((lst (list 1 2 3)))
  (set! (cdr (cdr (cdr lst))) lst)
  (test (member 4 lst) (member 4 lst equal?)))

(let ((lst (list 1 2 3 4)))
  (set! (cdr (cdr (cdr (cdr lst)))) lst)
  (test (member 4 lst) (member 4 lst equal?)))

(let ((lst (list 1 2 3 4)))
  (set! (cdr (cdr (cdr (cdr lst)))) (cdr lst))
  (test (member 4 lst) (member 4 lst equal?)))

(for-each
  (lambda (arg lst)
    (test (member arg lst eq?) (memq arg lst))
    (test (member arg lst eqv?) (memv arg lst))
    (test (member arg lst equal?) (member arg lst)))
  (list 'a #f (list 'a) 'a 1 3/4 #(1) "hi")
  (list '(a b c) '(1 "hi" #t #f 2) '(b (a) c) '(d a b . c) '(1 3/4 23) '(1 3/4 23) '(a 1 #(1) 23) '(1 "hi" 23)))

(for-each
 (lambda (op)
   (test (op) 'error)
   (for-each
    (lambda (arg)
      (let ((result (catch #t (lambda () (op arg)) (lambda args 'error))))
	(if (not (eq? result 'error))
	    (format #t ";(~A ~A) returned ~A?~%" op arg result))
	(test (op arg '() arg) 'error)
	(test (op arg) 'error)))
    (list '() "hi" (integer->char 65) #f 'a-symbol (make-vector 3) abs _ht_ quasiquote macroexpand 1/0 (log 0) 
	  3.14 3/4 1.0+1.0i #\f #t :hi (if #f #f) (lambda (a) (+ a 1)))))
 (list cons car cdr set-car! set-cdr! caar cadr cdar cddr caaar caadr cadar cdaar caddr cdddr cdadr cddar 
       caaaar caaadr caadar cadaar caaddr cadddr cadadr caddar cdaaar cdaadr cdadar cddaar cdaddr cddddr cddadr cdddar
       assq assv memq memv list-ref list-tail))

(for-each
 (lambda (op)
   (test (op '(1) '(2)) 'error))
 (list reverse car cdr caar cadr cdar cddr caaar caadr cadar cdaar caddr cdddr cdadr cddar 
       caaaar caaadr caadar cadaar caaddr cadddr cadadr caddar cdaaar cdaadr cdadar cddaar cdaddr cddddr cddadr cdddar
       list-ref list-tail list-set!))

(for-each
 (lambda (op)
   (for-each
    (lambda (arg)
      (let ((result (catch #t (lambda () (op #f arg)) (lambda args 'error))))
	(if (not (eq? result 'error))
	    (format #t ";(~A #f ~A) returned ~A?~%" op arg result))))
    (list "hi" (integer->char 65) #f 'a-symbol (make-vector 3) abs _ht_ quasiquote macroexpand 1/0 (log 0) 
	  3.14 3/4 1.0+1.0i #\f #t :hi (if #f #f) (lambda (a) (+ a 1)))))
 (list assq assv assoc memq memv member))
