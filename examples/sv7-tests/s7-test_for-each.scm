(test (let ((v (make-vector 5))) (for-each (lambda (i) (vector-set! v i (* i i))) '(0 1 2 3 4)) v) '#(0 1 4 9 16))
(test (let ((ctr 0) (v (make-vector 5))) (for-each (lambda (i) (vector-set! v ctr (* i i)) (set! ctr (+ ctr 1))) '(0 1 2 3 4)) v) '#(0 1 4 9 16))
(for-each (lambda (x) (display "for-each should not have called this")) '())
(test (let ((ctr 0)) (for-each (lambda (x y) (if (= x y) (set! ctr (+ ctr 1)))) '(1 2 3 4 5 6) '(2 3 3 4 7 6)) ctr) 3)
(test (let ((ctr 0)) (for-each (lambda (x y z) (set! ctr (+ ctr x y z))) '(0 1) '(2 3) '(4 5)) ctr) 15)
(test (let ((ctr 0)) (for-each (lambda (x y z) (set! ctr (+ ctr x y z))) '(1) '(3) '(5)) ctr) 9)
(test (let ((ctr 0)) (for-each (lambda (x y z) (set! ctr (+ ctr x y z))) '() '() '()) ctr) 0)
(test (let () (for-each abs '(1 2)) 1) 1)
(test (let ((ctr 0)) (for-each (lambda (a) (for-each (lambda (b) (set! ctr (+ ctr 1))) '(0 1))) '(2 3 4)) ctr) 6)
(test (let ((sum 0)) (for-each (lambda args (set! sum (+ sum (apply + args)))) '(0 1 2) '(2 1 0) '(3 4 5) '(5 4 3) '(6 7 8) '(8 7 6)) sum) 72)
(test (let ((sum 0)) (for-each (lambda (a b . args) (set! sum (+ sum a b (apply + args)))) '(0 1 2) '(2 1 0) '(3 4 5) '(5 4 3) '(6 7 8) '(8 7 6)) sum) 72)
(test (let ((sum 0)) (for-each (lambda (a b . args) (set! sum (+ sum a b (apply + args)))) '(0 1 2) '(2 1 0)) sum) 6)
(test (let () (for-each + '(0 1 2) '(2 1 0)) 0) 0)
(test (let () () ()) '())
(test (for-each + ()) #<unspecified>)
(test (let ((sum 0)) (for-each (lambda a (set! sum (+ sum (apply + a)))) '(1 2 3)) sum) 6)
(test (let ((sum 0)) (for-each (lambda* ((a 1)) (set! sum (+ sum a))) '(1 2 3)) sum) 6)
(test (let ((sum 0)) (for-each (lambda (a . b) (set! sum (+ sum a))) '(1 2 3)) sum) 6)
(test (let ((sum 0) (lst (list 1 2 3))) (for-each (lambda (a b c) (set! sum (+ sum a b c))) lst lst lst) sum) 18)
(test (let ((sum 0) (lst (vector 1 2 3))) (for-each (lambda (a b c) (set! sum (+ sum a b c))) lst lst lst) sum) 18)
(test (let ((v (vector 1 2 3))) (for-each vector-set! (list v v v) (list 0 1 2) (list 32 33 34)) v) #(32 33 34))
(test (let () (define (hi) (for-each (lambda (x) (+ x 1)) (list 1 2 3))) (hi) (hi)) #<unspecified>)

(test (let ((d 0))
	(for-each (let ((a 0))
		    (for-each (lambda (b) (set! a (+ a b))) (list 1 2))
		    (lambda (c) (set! d (+ d c a))))
		  (list 3 4 5))
	d)
      21)
(test (let ((d 0))
	(for-each (lambda (c)
		    (let ((a 0))
		      (for-each (lambda (b) (set! a (+ a b))) (list 1 2))
		      (set! d (+ d a c))))
		  (list 3 4 5))
	d)
      21)

(test (let ((ctr 0)) 
	(let ((val (call/cc 
		    (lambda (exit) 
		      (for-each (lambda (a) 
				  (if (> a 3) (exit a)) 
				  (set! ctr (+ ctr 1))) 
				(list 0 1 2 3 4 5)))))) 
	  (list ctr val)))
      (list 4 4))

(test (call-with-current-continuation
       (lambda (exit)
	 (for-each 
	  (lambda (x) 
	    (if (negative? x) (exit x)))
	  '(54 0 37 -3 245 19))
	 #t))
      -3)

(test (let ((ctr 0)
	    (cont #f)
	    (lst '()))
	(let ((val (call/cc 
		    (lambda (exit) 
		      (for-each (lambda (a) 
				  (if (and (not cont) (= a 2))
				      (exit a)) 
				  (if (and cont (= a 5)) 
				      (exit a))
				  (call/cc (lambda (c) (set! cont c)))
				  (set! lst (cons ctr lst))
				  (set! ctr (+ ctr 1)))
				(list 0 1 2 3 4 5)))))) 
	  (if (< val 5)
	      (cont))
	  (list ctr val lst)))
      (list 5 5 (list 4 3 2 1 0)))

(test (let ((lst '())) 
	(for-each (lambda (a) (set! lst (cons a lst))) 
		  (let ((lst '())) 
		    (for-each (lambda (b) (set! lst (cons b lst))) 
			      (list 1 2 3)) 
		    lst)) 
	lst) 
      (list 1 2 3))

;;; this is an infinite loop?
					; (let ((cont #f)) (call/cc (lambda (x) (set! cont x))) (for-each cont (list 1 2 3)))
(test (call/cc (lambda (x) (for-each x (list 1 2 3)))) 1) ; map also gives 1 ... perhaps not actually legal?

(test (let ((ctr 0))
	(for-each 
	 (lambda (x)
	   (for-each
	    (lambda (x y)
	      (for-each 
	       (lambda (x y z)
		 (set! ctr (+ x y z)))
	       (list x (+ x 1))
	       (list y (+ y 2))
	       (list (+ x y) (- x y))))
	    (list (+ x 3) (+ x 4) (+ x 5))
	    (list (- x 3) (- x 4) (- x 5))))
	 (list 1 2 3 4 5))
	ctr)
      23)

(for-each
 (lambda (a)
   (if (not (string=? a "hi"))
       (format #t "yow: ~S" a)))
 (list "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi" "hi"))


;; now some mixed cases
(test (let ((sum 0)) (for-each (lambda (n m) (set! sum (+ sum n m))) (list 1 2) (vector 3 4)) sum) 10)
(test (let ((sum 0)) (for-each (lambda (n m) (set! sum (+ sum n m))) (vector 1 2) (list 3 4)) sum) 10)
(test (let ((sum 0)) (for-each (lambda (n m p) (set! sum (+ sum n m))) (vector 1 2) (list 3 4) (vector 5 6)) sum) 10)
(test (let ((sum 0)) (for-each (lambda (n m p) (if (char=? p #\x) (set! sum (+ sum n m)))) (vector 1 2 3) (list 3 4 5) "xax") sum) 12)

(test (let* ((x (list (list 1 2 3))) (y (apply for-each abs x))) x) '((1 2 3)))

(test (for-each (lambda (x) (display "for-each should not have called this"))) 'error)
(test (for-each (lambda () 1) '()) #<unspecified>)
(test (let ((ctr 0)) (for-each (lambda (x y z) (set! ctr (+ ctr x y z))) '(1) '(3) '()) ctr) 0)
(test (let ((ctr 0)) (for-each (lambda (x y z) (set! ctr (+ ctr x y z))) '(0 1) '(2 3) '(4 5 6)) ctr) 15)
(test (for-each (lambda (a b) (+ a b)) (list 1)) 'error)
(test (for-each (lambda (a b) (+ a b)) (list 1) (list)) #<unspecified>)
(test (for-each (lambda (a b) (+ a b)) (list 1)) 'error)
(test (for-each (lambda (a b) (+ a b)) (list 1) (list 2) (list 3)) 'error)
(test (for-each (lambda (a b) (+ a b)) (list 1) (list 1 2)) #<unspecified>)
(test (for-each (lambda (a b) (+ a b)) (list 1 2) (list 1)) #<unspecified>)
(test (for-each (lambda (a b) (+ a b)) (list 1 2) (list 1 2 3)) #<unspecified>)
(test (for-each (lambda (a b) (+ a b)) (list 1 2) (list 1)) #<unspecified>)
(test (for-each (lambda (a b) (+ a b)) (list 1 2) (list 1 2) (list)) #<unspecified>)
(test (for-each (lambda (a b) (+ a b)) (list 1 2) (list 1 2) (list 1 2)) 'error)
(test (for-each (lambda (a b) (+ a b)) (list 1 2) (cons 1 2)) #<unspecified>)
(test (for-each (lambda (a b) (+ a b)) (cons 1 2) (list 1 2)) #<unspecified>)
(test (for-each (lambda (a) (+ a 1)) (list 1) (list 2)) 'error)
(test (for-each (lambda (a) (+ a 1)) #\a) 'error)
(test (for-each (lambda (a) (+ a 1)) (cons 1 2)) #<unspecified>)
(test (let ((sum 0)) (for-each (lambda (a b . args) (set! sum (+ sum a b (apply + args)))) '(0 1 2)) sum) 'error)
(test (for-each (lambda (a) a) '(1 2 . 3)) #<unspecified>)
(test (for-each #(0 1 2) #(2 1 0)) #<unspecified>)
(for-each
 (lambda (arg)
   (test (for-each arg (list 1)) #<unspecified>))
 (list (list 1 2 3) #(1 2 3) "hi"))

(for-each
 (lambda (op)
   (test (for-each op '()) 'error)
   (test (for-each op "") 'error)
   (test (for-each op #(1 2 3) '()) 'error)
   (test (for-each op #() (list) (string)) 'error))
 (list 0 '() #f #t 'a-symbol :hi #\a #<eof> #<unspecified> #<undefined> 0.0 1+i 1/2 1/0 0/0 *stdout* (current-input-port)))
(for-each
 (lambda (arg)
   (test (for-each arg (list 1)) 'error))
 (list -1 #\a 1 'a-symbol 3.14 3/4 1.0+1.0i #f #t))
(for-each
 (lambda (arg)
   (test (for-each (lambda (n m) n) (list 1) arg) 'error))
 (list -1 #\a 1 'a-symbol 3.14 3/4 1.0+1.0i #f #t))
(for-each
 (lambda (arg)
   (test (for-each (lambda (a) a) arg) 'error))
 (list -1 #\a 1 'a-symbol 3.14 3/4 1.0+1.0i #f #t))

(test (for-each) 'error)
(test (for-each #t) 'error)
(test (for-each map #t) 'error)

(test (for-each abs '() abs) 'error)
(test (for-each abs '(1) '#(1)) 'error)
(test (let ((vals '())) (for-each for-each (list (lambda (a) (set! vals (cons (abs a) vals)))) (list (list -1 -2))) vals) '(2 1))
(test (let ((c #f)) (for-each (lambda (x) (set! c x)) "a") c) #\a)
(test (let ((c #f)) (for-each (lambda (x) (set! c x)) "") c) #f)
(test (let ((c #f)) (for-each (lambda (x) (set! c x)) (string #\null)) c) #\null)

(test (let ((L (list 1 2 3 4 5)) (sum 0)) (for-each (lambda (x) (set-cdr! (cddr L) 5) (set! sum (+ sum x))) L) sum) 6)
; map (below) has more tests along this line
(test (let ((f #f)) (for-each (lambda (a) (if (eq? a 'a) (set! f (lambda () a)))) '(a b c)) (f)) 'a)
(test (let ((i 0) (f (make-vector 3))) (for-each (lambda (b) (vector-set! f i b) (set! i (+ i 1))) '(a b c)) f) #(a b c))
(test (let ((i 0) (f (make-vector 3)) (lst '(a b c))) (define (hi) (for-each (lambda (b) (vector-set! f i b) (set! i (+ i 1))) lst)) (hi) f) #(a b c))
(test (let ((i 0) (f (make-vector 3)) (lst '(a b c))) (define (hi) (for-each (lambda (b) (let () (vector-set! f i b) (set! i (+ i 1)))) lst)) (hi) f) #(a b c))
(test (let ((i 0) (f (make-vector 3)) (lst (list 1 2 3))) (define (hi) (for-each (lambda (b) (vector-set! f i (let ((b (+ b 1))) b)) (set! i (+ i 1))) lst)) (hi) f) #(2 3 4))
(test (let ((i 0) (f (make-vector 3)) (lst (list 1 2 3))) (define (hi) (for-each (lambda (b) (let ((b (+ b 1))) (vector-set! f i (let ((b (+ b 1))) b)) (set! i (+ i 1)))) lst)) (hi) f) #(3 4 5))
(test (let ((f #f)) (define (hi) (for-each (lambda (a) (if (eq? a 'a) (set! f (lambda () (let () a))))) '(a b c))) (hi) (f)) 'a)
(test (let ((lst '((a b c) (1 2 3)))) (define (hi) (for-each (lambda (a) a) (apply values lst))) (hi)) 'error)

(test (for-each ="") #<unspecified>)
(test (for-each =""=) 'error)
(test (for-each = "" 123) 'error)
(test (for-each = () 123) 'error)
(test (for-each =()=) 'error)
(test (for-each abs "") #<unspecified>)
(test (for-each null? () #() "") #<unspecified>)
(test (for-each null? () #() 0 "") 'error)
(test (for-each define '(a) '(3)) #<unspecified>)
(test (for-each '(()) #()) #<unspecified>)
(test (for-each '(1 2 . 3) '(1 . 2)) #<unspecified>)
(test (for-each '(()) '()) #<unspecified>)
(test (for-each #2D((1 2) (3 4)) '(1)) #<unspecified>)
(test (for-each "a\x00b" #(1 2)) #<unspecified>)
(test (for-each #(1 (3)) '(1)) #<unspecified>)
(test (for-each '((1 (2)) (((3) 4))) '(1)) #<unspecified>)
(test (for-each "hi" '(1)) #<unspecified>)
(test (for-each #() #()) #<unspecified>)
(test (for-each '(1 . 2) #()) #<unspecified>)
(test (let ((ht (hash-table '(a . 1) '(b . 2)))) (for-each ht ht)) #<unspecified>)
(test (let ((ht (hash-table '(a . 1) '(b . 2)))) (let ((sum 0)) (for-each (lambda (c) (set! sum (+ sum (cdr c)))) ht) sum)) 3)
(test (let ((ht (hash-table '(a . 1) '(b . 2)))) (for-each ht '(a b))) #<unspecified>)
(test (for-each ''2 '(1)) #<unspecified>)
(let ((lst (list 1 2))) (set! (cdr (cdr lst)) lst) (test (for-each lst lst) 'error))
(let ((lst (list 1 2))) (set! (cdr (cdr lst)) lst) (test (for-each #() lst) 'error))
(test (for-each 1 "hi" '()) 'error)
(test (for-each 0 #() '()) 'error)
(test (for-each #\a #(1 2) '(3 4) "") 'error)
(test (for-each '2 ()) 'error)

(let ()
  (define (hi)
    (let ((lst '(1 2 3)))
      (for-each
       (lambda (x)
	 (catch #t
	   (lambda ()
	     (if (defined? 'local-x)
		 (format #t ";for-each catch local env not cleared: ~A~%" local-x))
	     (define local-x x)
	     local-x)
	   (lambda args #f)))
       lst)))
  (hi)
  (hi))

(let ((x 0))
  (let ((p1 (make-procedure-with-setter (lambda (a) (set! x (+ x a))) (lambda (a b) (+ a b)))))
    (for-each p1 '(1 2 3))
    (test x 6))
  (set! x 0)
  (for-each (lambda args (set! x (+ x (car args)))) '(1 2 3))
  (test x 6)
  (set! x 0)
  (for-each (lambda* (a (b 2)) (set! x (+ x a))) '(1 2 3))
  (test x 6)
  (set! x 0)
  (for-each (lambda args (set! x (+ x (car args) (cadr args)))) '(1 2 3) '(3 2 1))
  (test x 12)
  (set! x 0)
  (for-each (lambda* (a (b 2)) (set! x (+ x a b))) '(1 2 3) '(3 2 1))
  (test x 12)
  (set! x 0)
  (for-each (lambda* (a (b 2)) (set! x (+ x a b))) '(1 2 3))
  (test x 12))

(test (let ((lst '(1 2 3)) (sum 0)) (define-macro (hi a) `(set! sum (+ sum (+ 1 ,a)))) (for-each hi lst) sum) 9)
  
(let ((sum 0))
  (define (and-for-each func . args)
    ;; apply func to first of each arg, stopping if func returns #f
    (call-with-exit
     (lambda (quit)
       (apply for-each 
	      (lambda arglist
		(if (not (apply func arglist))
		    (quit #<unspecified>)))
	      args))))
  
  (test (and-for-each (lambda (arg) 
			(and (not (null? arg))
			     (set! sum (+ sum arg))))
		      (list 1 2 () 3 4))
	#<unspecified>)
  (test sum 3)
  (set! sum 0)
  
  (and-for-each (lambda (arg) 
		  (and (not (null? arg))
		       (set! sum (+ sum arg))))
		(list 1 2 3 4))
  (test sum 10)
  (set! sum 0)
  
  (and-for-each (lambda (arg1 arg2) 
		  (and (not (null? arg1))
		       (not (null? arg2))
		       (set! sum (+ sum arg1 arg2))))
		(list 1 2 3 4)
		(list 5 6 () 7 8))
  (test sum 14))


(define (and-map func . args)
  (call-with-exit
   (lambda (quit)
     (let ((result ()))
       (apply for-each 
	      (lambda arglist
		(let ((val (apply func arglist)))
		  (if (not val)
		      (quit (reverse result))
		      (set! result (cons val result)))))
	    args)
       (reverse result)))))

(test (and-map even? '(0 2 4 5 6)) '(#t #t #t))

(define (find-if f . args)
  (call-with-exit
   (lambda (return) 
     (apply for-each (lambda main-args 
		       (if (apply f main-args) 
			   (apply return main-args)))
	    args))))

(test (find-if even? #(1 3 5 2)) 2)
(test (* (find-if > #(1 3 5 2) '(2 2 2 3))) 6)

(define (position-if f . args)
  (let ((pos 0))
    (call-with-exit
     (lambda (return) 
       (apply for-each (lambda main-args 
			 (if (apply f main-args) 
			     (return pos))
			 (set! pos (+ pos 1)))
	    args)))))

(test (position-if even? #(1 3 5 2)) 3)
(test (position-if > #(1 3 5 2) '(2 2 2 3)) 1)

(let ((summer (lambda (v)
		(let ((sum 0))
		  (do ((i 0 (+ i 1)))
		      ((= i 10) sum)
		    (set! sum (+ sum ((v i)))))))))
		
  (test (let ((saved-args (make-vector 10))
	      (i 0))
	  (for-each
	   (lambda (arg)
	     (set! (saved-args i) arg)
	     (set! i (+ i 1)))
	   (list 0 1 2 3 4 5 6 7 8 9))
	  (set! (saved-args 0) 32)
	  saved-args)
	#(32 1 2 3 4 5 6 7 8 9))
  
  (test (let ((f #f))
	  (for-each
	   (lambda (i)
	     (let ()
	       (define (x) i)
	       (if (= i 1) (set! f x))))
	   (list 0 1 2 3))
	  (f))
	1)
  
  (test (let ((saved-args (make-vector 10))
	      (i 0))
	  (for-each
	   (lambda (arg)
	     (set! (saved-args i) (lambda () arg))
	     (set! i (+ i 1)))
	   (list 0 1 2 3 4 5 6 7 8 9))
	  (summer saved-args))
	45)
  
  (test (let ((saved-args (make-list 10))
	      (i 0))
	  (for-each
	   (lambda (arg)
	     (list-set! saved-args i (lambda () arg))
	     (set! i (+ i 1)))
	   (list 0 1 2 3 4 5 6 7 8 9))
	  (summer saved-args))
	45)
  
;;; these are the same but use map
  (test (let ((saved-args (make-vector 10))
	      (i 0))
	  (map
	   (lambda (arg)
	     (set! (saved-args i) arg)
	     (set! i (+ i 1)))
	   (list 0 1 2 3 4 5 6 7 8 9))
	  (set! (saved-args 0) 32)
	  saved-args)
	#(32 1 2 3 4 5 6 7 8 9))
  
  (test (let ((f #f))
	  (map
	   (lambda (i)
	     (let ()
	       (define (x) i)
	       (if (= i 1) (set! f x))))
	   (list 0 1 2 3))
	  (f))
	1)
  
  (test (let ((saved-args (make-vector 10))
	      (i 0))
	  (map
	   (lambda (arg)
	     (set! (saved-args i) (lambda () arg))
	     (set! i (+ i 1)))
	   (list 0 1 2 3 4 5 6 7 8 9))
	  (summer saved-args))
	45)
  
  ;; and again but with named let
  (test (let ((saved-args (make-vector 10)))
	  (let runner ((arg 0))
	    (set! (saved-args arg) arg)
	    (if (< arg 9)
		(runner (+ arg 1))))
	  (set! (saved-args 0) 32)
	  saved-args)
	#(32 1 2 3 4 5 6 7 8 9))
  
  (test (let ((f #f))
	  (let runner ((i 0))
	    (let ()
	      (define (x) i)
	      (if (= i 1) (set! f x))
	      (if (< i 3)
		  (runner (+ i 1)))))
	  (f))
	1)
  
  (test (let ((saved-args (make-vector 10)))
	  (let runner ((i 0))
	    (set! (saved-args i) (lambda () i))
	    (if (< i 9)
		(runner (+ i 1))))
	  (summer saved-args))
	45)
  
  
;;; and recursion
  (test (let ((saved-args (make-vector 10)))
	  (define (runner arg)
	    (set! (saved-args arg) arg)
	    (if (< arg 9)
		(runner (+ arg 1))))
	  (runner 0)
	  (set! (saved-args 0) 32)
	  saved-args)
	#(32 1 2 3 4 5 6 7 8 9))
  
  (test (let ((f #f))
	  (define (runner i)
	    (let ()
	      (define (x) i)
	      (if (= i 1) (set! f x))
	      (if (< i 3)
		  (runner (+ i 1)))))
	  (runner 0)
	  (f))
	1)
  
  (test (let ((saved-args (make-vector 10)))
	  (define (runner i)
	    (set! (saved-args i) (lambda () i))
	    (if (< i 9)
		(runner (+ i 1))))
	  (runner 0)
	  (summer saved-args))
	45)
  
  
;;; and member/assoc
  (test (let ((saved-args (make-vector 10)))
	  (member 'a '(0 1 2 3 4 5 6 7 8 9) 
		  (lambda (a b)
		    (set! (saved-args b) (lambda () b))
		    #f))
	  (summer saved-args))
	45)
  
  (test (let ((saved-args (make-vector 10)))
	  (assoc 'a '((0 b) (1 b) (2 b) (3 b) (4 b) (5 b) (6 b) (7 b) (8 b) (9 b))
		 (lambda (a b)
		   (set! (saved-args b) (lambda () b))
		   #f))
	  (summer saved-args))
	45)
  
  (test (let ((saved-args (make-vector 10 #f)))
	  (sort! '(3 2 1 4 6 5 9 8 7 0)
		 (lambda (a b)
		   (if (not (saved-args b))
		       (set! (saved-args b) (lambda () b)))
		   (< a b)))
	  (summer saved-args))
	45)
  
;;; and do which has never worked in this way -- maybe soon!
#|  
  (test (let ((saved-args (make-vector 10)))
	  (do ((i 0 (+ i 1)))
	      ((= i 10))
	    (set! (saved-args i) (lambda () i)))
	  (summer saved-args))
	45)
|#
  )
