;;; (define (nan? x) (and (number? x) (not (= x x))))

(test (nan? +inf.0) #f)
(test (nan? -inf.0) #f)
(test (nan? nan.0) #t)
(test (nan? pi) #f)
(test (nan? (imag-part 0+0/0i)) #t)
(test (nan? (imag-part (sinh 0+0/0i))) #t)
(test (nan? (imag-part (sinh 1-0/0i))) #t)
(test (nan? (log 10 0/0)) #t)
(test (nan? (* 0 inf.0)) #t)
(test (nan? (real-part nan+nani)) #t)
(test (nan? (imag-part nan+nani)) #t)
(test (nan? (real-part 0+nani)) #f)
(test (nan? (imag-part 0+nani)) #t)

(if with-bignums
    (begin
      (test (nan? (bignum "1/0")) #t)
      (test (nan? 7151305879464824441563197685/828567267217721441067369971) #f)
      (test (nan? 1624540914719833702142058941.4) #f)
      ))

(test (nan?) 'error)
(test (nan? 1 2) 'error)

#|
(define digits (vector #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))

(do ((i 0 (+ i 1)))
    ((= i 10000))
  (let ((int-digits (random 80))
	(frac-digits (random 80))
	(exp-digits (+ 1 (random 5)))
	(signed (> (random 10) 5))
	(signed-exponent (> (random 10) 5)))
    (let ((str (make-string (+ 1 int-digits 1 frac-digits 2 exp-digits) #\space))
	  (j 0))

      (if signed
	  (begin
	    (set! (str j) #\-)
	    (set! j (+ j 1))))

      (do ((k 0 (+ k 1)))
	  ((= k int-digits))
	(set! (str j) (digits (random 10)))
	(set! j (+ j 1)))

      (set! (str j) #\.)
      (set! j (+ j 1))

       (do ((k 0 (+ k 1)))
	  ((= k frac-digits))
	(set! (str j) (digits (random 10)))
	(set! j (+ j 1)))

      (set! (str j) #\e)
      (set! j (+ j 1))

      (if signed-exponent
	  (begin
	    (set! (str j) #\-)
	    (set! j (+ j 1))))

      (do ((k 0 (+ k 1)))
	  ((= k exp-digits))
	 (if (< k 3)
	     (set! (str j) (digits (random 10)))
	     (set! (str j) (digits (random 4))))
	 (set! j (+ j 1)))

      (let ((num (string->number (substring str 0 j))))
	(if (or (nan? num)
		(infinite? num))
	    (format #t "~A: ~S -> ~A~%" (if (infinite? num) 'inf 'nan) str num)))
      )))
|#

;;; these all relate to inf/nan

(if (not with-bignums)
    (begin
      (test (* 1e12000 1e12000) inf.0)
      (test (<= 0 inf.0 nan.0) #f)
      (test (<= 1 nan.0) #f)
      (test (<= nan.0 1) #f)
      (test (<= nan.0 inf.0) #f)
      (test (<= nan.0 nan.0) #f)
      (test (>= 1 nan.0) #f)
      (test (>= nan.0 1) #f)
      (test (>= nan.0 inf.0) #f)
      (test (>= nan.0 nan.0) #f)
      (test (floor inf.0) 'error)
      (test (inexact->exact (make-rectangular 1 inf.0)) 'error)
      (test (nan? (expt 0 nan.0)) #t)
      (test (nan? (expt 1 nan.0)) #t)
      (test (nan? (expt nan.0 inf.0)) #t)
      (test (nan? (expt nan.0 nan.0)) #t)
      (test (rationalize 1e19) 'error)
      (test (round inf.0) 'error)
      (test (truncate inf.0) 'error)
      ))

(num-test (/ -1 -inf.0 -9223372036854775808) 0.0)
(num-test (angle -inf.0) pi)
(num-test (angle inf.0) 0.0)
(num-test (atan inf.0) 1.5707963267949)
(num-test (atanh inf.0) 0+1.5707963267949i)
(num-test (tanh -inf.0) -1.0)
(num-test (tanh inf.0) 1.0)
(test (* -inf.0 inf.0) -inf.0)
(test (* inf.0) inf.0)
(test (+ 0 inf.0) inf.0)
(test (+ inf.0) inf.0)
(test (- -inf.0 inf.0) -inf.0)
(test (- 0 inf.0) -inf.0)
(test (- inf.0) -inf.0)
(test (/ 0 inf.0) 0.0)
(test (/ inf.0) 0.0)
(test (/ nan.0 0) 'error)
(test (< -inf.0 0.0) #t)
(test (< -inf.0 inf.0) #t)
(test (< -inf.0 inf.0) #t)
(test (< 0 inf.0 -inf.0) #f)
(test (< 0 inf.0) #t)
(test (< inf.0 -inf.0) #f)
(test (< nan.0 inf.0) #f)
(test (< nan.0 nan.0) #f)
(test (<= -inf.0 0.0 inf.0 inf.0) #t)
(test (<= -inf.0 inf.0) #t)
(test (<= 0 inf.0 -inf.0) #f)
(test (<= 0 inf.0) #t)
(test (= (* (+ inf.0 inf.0) -inf.0) -inf.0) #t)
(test (= (* -3.4 -inf.0) inf.0) #t)
(test (= (* -inf.0 -inf.0) inf.0) #t)
(test (= (* inf.0 -inf.0) -inf.0) #t)
(test (= (* inf.0 inf.0) inf.0) #t)
(test (= (+ 1 inf.0) inf.0) #t)
(test (= (+ inf.0 inf.0) inf.0) #t)
(test (= (- -inf.0) inf.0) #t)
(test (= (- 0.0 inf.0) -inf.0) #t)
(test (= (- inf.0) -inf.0) #t)
(test (= (/ 0.0 inf.0) 0.0) #t)
(test (= (abs -inf.0) inf.0) #t)
(test (= (abs inf.0) inf.0) #t)
(test (= (exp -inf.0) 0.0) #t)
(test (= (exp inf.0) inf.0) #t)
(test (= (exp most-negative-fixnum) 0.0) #t)
(test (= (exp most-positive-fixnum) inf.0) #t)
(test (= (expt -inf.0 0) 1.0) #t)
(test (= (expt 0.0 inf.0) 0.0) #t)
(test (= (expt 1 -inf.0) 1.0) #t)
(test (= (expt 1 inf.0) 1.0) #t)
(test (= (expt 2 -inf.0) 0.0) #t)
(test (= (expt inf.0 0) 1.0) #t)
(test (= (log inf.0) inf.0) #t)
(test (= (magnitude -inf.0) inf.0) #t)
(test (= (magnitude inf.0) inf.0) #t)
(test (= (make-polar inf.0 0) inf.0) #t)
(test (= (make-rectangular 0 inf.0) (sqrt -inf.0)) #t)   ; (sqrt -inf.0) -> 0+infi !
(test (= (make-rectangular inf.0 0) inf.0) #t)
(test (= (max -inf.0 inf.0) inf.0) #t)
(test (= (min -inf.0 inf.0) -inf.0) #t)
(test (= (sqrt inf.0) inf.0) #t)
(test (infinite? (imag-part (sqrt -inf.0))) #t)
(test (= -inf.0 -inf.0) #t)
(test (= -inf.0 inf.0) #f)
(test (= -inf.0 inf.0) #f)
(test (= 0 inf.0 -inf.0) #f)
(test (= 0 inf.0) #f)
(test (= 0.0 nan.0) #f)
(test (= inf.0 0.0) #f)
(test (= inf.0 inf.0) #t)
(test (= inf.0 most-positive-fixnum) #f)
(test (= inf.0 nan.0) #f)
(test (nan? (real-part nan+nani)) #t) 
(test (= nan.0 inf.0) #f)
(test (nan? nan+nani) #t)
(test (nan? nan.0) #t)
(test (> -inf.0 inf.0) #f)
(test (> 0 inf.0 -inf.0) #f)
(test (> 0 inf.0) #f)
(test (> inf.0 0.0) #t)
(test (> inf.0 1.0e308) #t)
(test (> inf.0 most-positive-fixnum) #t)
(test (> nan.0 inf.0) #f)
(test (> nan.0 nan.0) #f)
(test (>= -inf.0 inf.0) #f)
(test (>= 0 inf.0) #f)
(test (>= inf.0 -inf.0 0.0) #f)
(test (abs inf.0) inf.0)
(test (acosh inf.0) inf.0)
(test (angle inf.0) 0.0)
(test (ash -inf.0 inf.0) 'error)
(test (ash nan.0 inf.0) 'error)
(test (ash nan.0 nan.0) 'error)
(test (asinh inf.0) inf.0)
(test (ceiling inf.0) 'error)
(test (ceiling nan.0) 'error)
(test (complex? nan+nani) #t)
(test (cosh inf.0) inf.0)
(test (even? inf.0) 'error)
(test (exact? (make-rectangular 1 inf.0)) #f)
(test (exp inf.0) inf.0)
(test (expt nan.0) 'error)
(test (floor inf.0) 'error)
(test (floor nan.0) 'error)
(test (gcd -inf.0 inf.0) 'error)
(test (gcd nan.0 inf.0) 'error)
(test (gcd nan.0 nan.0) 'error)
(test (imag-part (make-rectangular 1 inf.0)) inf.0)
(test (imag-part nan.0) 0.0)
(test (inexact? (make-rectangular 1 inf.0)) #t)
(test (infinite? 1 2) 'error)
(test (infinite?) 'error)
(test (lcm -inf.0 inf.0) 'error)
(test (lcm nan.0 inf.0) 'error)
(test (lcm nan.0 nan.0) 'error)
(test (lcm nan.0) 'error)
(test (log 8.0 inf.0) 0.0) 
(test (log inf.0) inf.0)
(test (logand -inf.0 inf.0) 'error)
(test (logand nan.0 inf.0) 'error)
(test (logand nan.0 nan.0) 'error)
(test (logior -inf.0 inf.0) 'error)
(test (logior nan.0 inf.0) 'error)
(test (logior nan.0 nan.0) 'error)
(test (lognot -inf.0) 'error)
(test (lognot nan.0) 'error)
(test (logbit? -inf.0 inf.0) 'error)
(test (logbit? nan.0 inf.0) 'error)
(test (logbit? nan.0 nan.0) 'error)
(test (logxor -inf.0 inf.0) 'error)
(test (logxor nan.0 inf.0) 'error)
(test (logxor nan.0 nan.0) 'error)
(test (magnitude inf.0) inf.0)
(test (make-random-state inf.0) 'error)
(test (make-random-state nan.0) 'error)
(test (max -inf.0 inf.0) inf.0)
(test (max 0 inf.0 -inf.0) inf.0)
(test (max 0 inf.0) inf.0)
(test (max inf.0) inf.0)
(test (min -inf.0 inf.0) -inf.0)
(test (min 0 inf.0 -inf.0) -inf.0)
(test (min 0 inf.0) 0)
(test (min inf.0) inf.0)
(test (nan? (* 0 nan.0)) #t)
(test (nan? (+ (values inf.0 -inf.0) inf.0)) #t)
(test (nan? (- -inf.0 -inf.0)) #t)
(test (nan? (- inf.0 inf.0)) #t)
(test (nan? (- nan.0 nan.0)) #t)
(test (nan? (- nan.0)) #t)
(test (nan? (* 0 (log 0))) #t)
(test (nan? (/ -1 nan.0 -inf.0)) #t)
(test (nan? (/ -inf.0 -inf.0)) #t)
(test (nan? (/ 0 nan.0)) #t)
;(test (nan? (/ 0 (log 0))) #t) ;why not just 0.0?
(test (nan? (/ inf.0 -inf.0)) #t)
(test (nan? (/ inf.0 inf.0)) #t)
(test (nan? (/ inf.0 nan.0)) #t)
(test (nan? (/ nan.0 inf.0)) #t)
(test (nan? (/ nan.0 nan.0)) #t)
(test (nan? (/ nan.0)) #t)
(test (nan? (abs nan.0)) #t)
;(test (nan? (acos inf.0)) #t)
(test (nan? (angle nan.0)) #t)
;(test (nan? (asin inf.0)) #t)
(test (nan? (asin nan.0)) #t)
(test (nan? (exp nan.0)) #t)
(test (nan? (imag-part (make-rectangular 0 nan.0))) #t)
(test (nan? (imag-part nan+nani)) #t)
(test (nan? (imag-part nan+nani)) #t)
(test (nan? (log 8.0 nan.0)) #t)
(test (nan? (log nan.0 nan.0)) #t)
(test (nan? (magnitude nan+nani)) #t)
(test (nan? (magnitude nan.0)) #t)
(test (nan? (make-polar -inf.0 inf.0)) #t)
(test (nan? (make-polar nan.0 0)) #t)
(test (nan? (make-rectangular nan.0 0)) #t)
(test (nan? (max 0 inf.0 nan.0)) #t)
(test (nan? (max 1 nan.0)) #t)
(test (nan? (min 0 inf.0 nan.0)) #t)
(test (nan? (min 1 nan.0)) #t)
;(test (nan? (modulo 1 inf.0)) #t)
;(test (nan? (modulo 1 nan.0)) #t)
;(test (nan? (modulo inf.0 1)) #t)
;(test (nan? (modulo nan.0 1)) #t)
(test (nan? (random nan.0)) #t)
(test (nan? (real-part (exp nan+nani))) #t)
(test (nan? (real-part (log nan+nani))) #t)
(test (nan? (real-part (log nan.0))) #t)
(test (nan? (real-part (make-rectangular -inf.0 0))) #f)
(test (nan? (real-part (sqrt nan.0))) #t)
(test (nan? (real-part nan+nani)) #t)
(test (nan? (sin -inf.0)) #t)
(test (nan? (sin inf.0)) #t)
(test (nan? (sin nan.0)) #t)
(test (nan? (string->number "nan.0")) #t)
(test (nan? -inf.0) #f)
(test (nan? 1 2) 'error)
(test (nan? inf.0) #f)
(test (nan? most-negative-fixnum) #f)
(test (nan? most-positive-fixnum) #f)
(test (nan?) 'error)
(test (negative? (/ (real-part (log 0.0)) (real-part (log 0.0)))) #f) ; and yet it prints as -nan.0
(test (number? nan+nani) #t)
(test (quotient 1 nan.0) 'error)
(test (quotient nan.0 1) 'error)
(test (random nan.0 inf.0) 'error)
(test (rationalize -inf.0) 'error)
(test (rationalize 0.5 inf.0) 0)
(test (rationalize 178978.5 -inf.0) 0)
(test (rationalize 178987.5 nan.0) 'error)
(test (rationalize 198797.5 inf.0) 0)
(test (rationalize inf.0) 'error)
(test (rationalize inf.0) 'error)
(test (rationalize nan.0 nan.0) 'error)
(test (rationalize nan.0) 'error)
(test (rationalize nan.0) 'error)
(test (real-part (make-rectangular 1 inf.0)) 1.0)
(test (real? nan+nani) #f)
(test (remainder 1 nan.0) 'error)
(test (remainder nan.0 1) 'error)
(test (round inf.0) 'error)
(test (round nan.0)'error)
(test (sinh inf.0) inf.0)
(test (sqrt inf.0) inf.0)
(test (tanh inf.0) 1.0)
(test (truncate inf.0) 'error)
(test (truncate nan.0) 'error)
(test (zero? (make-rectangular 1 inf.0)) #f)
(test (zero? (real-part (make-rectangular 0 -inf.0))) #t)
(test (zero? 0/0) #f)
(test (zero? inf.0) #f)
(test (zero? nan.0) #f)
;; (test (nan? (angle nan.0)) #t)
;; but (* 0 (expt 10 310)) -> -nan if not GMP -- is this a bug?
;;(atanh -inf.0) 0+1.5707963267949i
;;(test (/ 0 inf.0 -inf.0) 0.0)
;;(test (= (expt 1 nan+nani) 1) #t) ; or maybe NaN?
;;(test (= (expt 1 nan.0) 1) #t)
;;(test (= (expt 2 inf.0) inf.0) #t)
;;(test (= (expt inf.0 -inf.0) 0.0) #t)
;;(test (= (expt inf.0 inf.0) inf.0) #t)
;;(test (= (expt nan.0 0) 1.0) #t) ;hmmm
;;(test (= (expt nan.0 nan.0) 0) #t)
;;(test (>= 0 inf.0 -inf.0) #t)
;;(test (angle (make-rectangular 1 inf.0)) 1.5707963267949)
;;(test (atanh (make-rectangular 1 inf.0)) -0+1.5707963267949i)
;;(test (nan? (atan -inf.0 inf.0)) #t) ; ??
;;(test (nan? (expt 0 inf.0)) #t)
;;(test (nan? (quotient -inf.0 inf.0)) #t)
;;(test (nan? (quotient 1 nan.0)) #t)
;;(test (nan? (quotient nan.0 1)) #t)
;;(test (nan? (quotient nan.0 inf.0)) #t)
;;(test (nan? (quotient nan.0 nan.0)) #t)
;;(test (tan (make-rectangular 1 inf.0)) 0+1i)
;;(log nan.0 0) (log 0 inf.0) (log 0 -inf.0) 

(for-each
 (lambda (x)
   (test (infinite? x) #f)
   (test (nan? x) #f))
 (list #\a "hi" #f #(1 2) '() '(1 . 2) _ht_ 'hi abs #<eof> #<unspecified>))

(for-each
 (lambda (n)
   (test (infinite? n) #f)
   (test (nan? n) #f))
 (list 0.0 -0.0 .1 1+i 0-i 1/10))

(for-each
 (lambda (op)
   (test (number? (op inf.0)) #t)
   (test (number? (op -inf.0)) #t)
   (test (number? (op nan.0)) #t))
 (list magnitude abs exp angle sin cos tan sinh cosh tanh atan sqrt log asinh acosh atanh acos asin
       real-part imag-part exact->inexact))

(for-each
 (lambda (op)
   (test (op inf.0) 'error)
   (test (op -inf.0) 'error)
   (test (op nan.0) 'error))
 (list floor ceiling truncate round))

(for-each
 (lambda (op)
   (test (number? (op inf.0 inf.0)) #t)
   (test (number? (op nan.0 -inf.0)) #t))
 (list + - * / expt make-rectangular make-polar))

(for-each
 (lambda (op)
   (test (boolean? (op inf.0)) #t)
   (test (boolean? (op nan.0)) #t)
   (test (op) 'error))
 (list number? integer? real? complex? rational? zero? positive? negative? inexact? exact?))

(for-each
 (lambda (op)
   (test (boolean? (op inf.0 -inf.0)) #t)
   (test (boolean? (op nan.0 -inf.0)) #t))
 (list  = < > <= >=))

(for-each
 (lambda (op)
   (test (op inf.0) 'error)
   (test (op nan.0) 'error))
 (list even? odd? numerator denominator lcm gcd inexact->exact
       logior logxor logand lognot logbit? ash integer-length))

(let ((d1 1e-312)
      (d2 1e-316)
      (d3 1e-320))
  (if (not (zero? d3))
      (begin
	(test (= d1 d2 d3) #f)
	(test (< d1 d2 d3) #f)
	(test (> d1 d2 d3) #t)
	(test (rationalize d1) 0)
	(test (rationalize d3) 0)
	(test (rationalize (- d1)) 0)
	(test (not (= d2 (* 2 d1))) #t)
	(num-test (string->number (number->string d1)) d1)
	
	(test (< (sin d3) (sin d2) (sin d1)) #t)
	(test (< (log d3) (log d2) (log d1)) #t)
	(test (< (abs d3) (abs d2) (abs d1)) #t)
	(test (< (sqrt d3) (sqrt d2) (sqrt d1)) #t)
	(test (<= (exp d3) (exp d2) (exp d3)) #t) ; all might be 1.0
	)))
