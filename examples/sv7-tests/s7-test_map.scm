(test (map cadr '((a b) (d e) (g h))) '(b e h))
(test (map (lambda (n) (expt n n)) '(1 2 3 4 5)) '(1 4 27 256 3125))
(test (map + '(1 2 3) '(4 5 6)) '(5 7 9))

(test (apply vector (map (lambda (i) (* i i)) '(0 1 2 3 4))) '#(0 1 4 9 16))
(map (lambda (x) (display "map should not have called this")) '())
(test (let ((ctr 0)) (map (lambda (x y) (if (= x y) (set! ctr (+ ctr 1))) ctr) '(1 2 3 4 5 6) '(2 3 3 4 7 6))) (list 0 0 1 2 2 3))
(test (let ((ctr 0)) (map (lambda (x y z) (set! ctr (+ ctr x y z)) ctr) '(0 1) '(2 3) '(4 5))) (list 6 15))
(test (let ((ctr 0)) (map (lambda (x y z) (set! ctr (+ ctr x y z)) ctr) '(1) '(3) '(5))) (list 9))
(test (let ((ctr 0)) (map (lambda (x y z) (set! ctr (+ ctr x y z)) ctr) '() '() '())) '())
(test (map (lambda (a b) (+ a b)) (list 1 2) (list 1 2)) (list 2 4))
(test (map abs '(1 -2)) (list 1 2))
(test (map + '(0 1 2) '(2 1 0) '(3 4 5) '(5 4 3) '(6 7 8) '(8 7 6)) (list 24 24 24))
(test (map (lambda (a) (cons a (map (lambda (b) (+ b 1)) (list 0 1 2)))) (list 3 4 5)) '((3 1 2 3) (4 1 2 3) (5 1 2 3)))
(test (map (lambda (a) (+ a 1)) (map (lambda (b) (+ b 1)) (map (lambda (c) (+ c 1)) (list 0 1 2)))) '(3 4 5))
(test (map (lambda args (apply + args)) '(0 1 2) '(3 4 5) '(6 7 8) '(9 10 11) '(12 13 14)) '(30 35 40))
(test (map (lambda (a b . args) (+ a b (apply + args))) '(0 1 2) '(3 4 5) '(6 7 8) '(9 10 11) '(12 13 14)) '(30 35 40))
(test (map (lambda (a b . args) (+ a b (apply + args))) '(0 1 2) '(3 4 5)) '(3 5 7))
(test (map (lambda args args) '(1 2 3)) '((1) (2) (3)))
(test (map + () ()) ())
(test (map + (#(#() #()) 1)) '())
(test (map + #(1) #(1) #(1)) '(3))
(test (map list '(a b c)) '((a) (b) (c)))
(test (map (lambda (a b) (- a b)) (list 1 2) (vector 3 4)) '(-2 -2))
(test (map (lambda (a b c) (if (char=? a #\a) (+ b c) (- b c))) "axa" (list 1 2 3) (vector 4 5 6)) '(5 -3 9))
(test (map vector (memv 1 (list 1 2 3))) '(#(1) #(2) #(3)))
(test (map append #(1 2 3)) '(1 2 3))
(test (map eval '((+ 1 2) (* 3 4))) '(3 12))
(test (map (map + (list 1 2 3)) (list 0 1 2)) '(1 2 3))

(test (let* ((x (list (list 1 2 3))) (y (apply map abs x))) (list x y)) '(((1 2 3)) (1 2 3)))
(test (let* ((x (quote ((1 2) (3 4)))) (y (apply map ash x))) (list x y)) '(((1 2) (3 4)) (8 32)))
(test (let* ((x (quote ((1 2 3) (4 5 6) (7 8 9)))) (y (apply map + x))) (list x y)) '(((1 2 3) (4 5 6) (7 8 9)) (12 15 18)))
(test (map * (map + '(1 2 3) '(4 5 6)) '(1 2 3)) '(5 14 27))
(test (apply map * (apply map + '(1 2 3) '((4 5 6))) '((1 2 3))) '(5 14 27))
(test (let* ((x (lambda () '(1 2 3))) (y (apply map - (list (x))))) (x)) '(1 2 3))

(test (let ((d 0))
	(map (let ((a 0))
	       (map (lambda (b) (set! a (+ a b))) (list 1 2))
	       (lambda (c) (set! d (+ d c a)) d))
	     (list 3 4 5)))
      (list 6 13 21))
(test (let ((d 0))
	(map (lambda (c)
	       (let ((a 0))
		 (map (lambda (b) (set! a (+ a b))) (list 1 2))
		 (set! d (+ d a c))
		 d))
	     (list 3 4 5)))
      (list 6 13 21))

(test (let ((ctr 0))
	(let ((val (call/cc 
		    (lambda (exit) 
		      (map (lambda (a) 
			     (if (> a 3) (exit a)) 
			     (set! ctr (+ ctr 1))
			     ctr)
			   (list 0 1 2 3 4 5))))))
	  (list ctr val)))
      (list 4 4))

(test (call-with-current-continuation
       (lambda (exit)
	 (map 
	  (lambda (x) 
	    (if (negative? x) (exit x))
	    x)
	  '(54 0 37 -3 245 19))))
      -3)

(test (let ((ctr 0)
	    (cont #f)
	    (lst '()))
	(let ((val (call/cc 
		    (lambda (exit) 
		      (map (lambda (a) 
			     (if (and (not cont) (= a 2))
				 (exit a)) 
			     (if (and cont (= a 5)) 
				 (exit a))
			     (call/cc (lambda (c) (set! cont c)))
			     (set! lst (cons ctr lst))
			     (set! ctr (+ ctr 1))
			     ctr)
			   (list 0 1 2 3 4 5))))))
	  (if (< val 5)
	      (cont))
	  (list ctr val lst)))
      (list 5 5 (list 4 3 2 1 0)))

(let ()
  (define (tree-add x lst)
    (define (tree-add-1 lst-1)
      (map (lambda (a)
	     (if (pair? a) (tree-add-1 a) (+ a x)))
	   lst-1))
    (tree-add-1 lst))
  (test (tree-add 12 '((1 2) ((3)) 4 5)) '((13 14) ((15)) 16 17)))

(test (map (lambda (a) a) (map (lambda (b) b) (list 1 2 3))) (list 1 2 3))
(test (map cons '(a b c) '(() () ())) '((a) (b) (c)))
(test (map (lambda a (list a)) '(1 2 3)) '(((1)) ((2)) ((3))))
(test (map (lambda* a (list a)) '(1 2 3)) '(((1)) ((2)) ((3))))
(test (map (lambda* (a) (list a)) '(1 2 3)) '((1) (2) (3)))
(test (map (lambda* ((a 0)) (list a)) '(1 2 3)) '((1) (2) (3)))
(test (map (lambda* ((a 0) (b 1)) (list a)) '(1 2 3)) '((1) (2) (3)))
(test (map (lambda (a . b) (list a)) '(1 2 3)) '((1) (2) (3)))
(test (map list '(1 2 3)) '((1) (2) (3)))
(test (map (lambda a (apply list a)) '(1 2 3)) '((1) (2) (3)))
(test (map (lambda a (apply values a)) '(1 2 3)) '(1 2 3))
(test (map (lambda a (values a)) '(1 2 3)) '((1) (2) (3)))
(test (map (lambda a (append a)) '(1 2 3)) '((1) (2) (3)))
(test (map values '(1 2 3)) '(1 2 3))
;(test ((lambda* ('a) quote) 1) 1)
(test (procedure? (car (map lambda '(()) '((1))))) #t)
(test (procedure? (car (map lambda '((x)) '(((+ x 1)))))) #t)
(test (map #(0 1 2) #(2 1 0)) '(2 1 0))
(test (map quasiquote '((quasiquote 1) (quasiquote 2))) '(1 2))
(test (map (lambda (a b) (a b)) (map lambda '((x) (y) (z)) '((+ x x) (* y y) (expt z z))) (list 1 2 3)) '(2 4 27))
(test (map apply (map lambda '((x) (y) (z)) '((+ x x) (* y y) (expt z z))) '((1) (2) (3))) '(2 4 27))
(test (let () (define (add-some x) (define (add-some x) (+ x 2)) (+ x 1)) (map add-some '(1 2 3 4))) '(2 3 4 5)) ; from some CL website -- kinda ridiculous
(test (map gcd #(1 2)) '(1 2))
(test (let ((ht (hash-table '(a . 1) '(b . 2)) )) (for-each set-cdr! ht '(32 33)) (ht 'a)) 32)
(test (apply vector (map values #(1 2) #(3 4))) #(1 3 2 4))
(test (map values '(1 2 3) '(4 5 6) '(7 8 9)) '(1 4 7 2 5 8 3 6 9))
(test (map eval (list (+ 1 2) (+ 3 4))) '(3 7))
(test (map apply (list + - * /) (list 1 2 3 4) '((5) (6) (7) (8))) '(6 -4 21 1/2))

;;; (let ((val '())) (list (map (lambda a (set! val (cons a val)) a) '(1 2 3)) val)) -> ((#3=(1) #2=(2) #1=(3)) (#1# #2# #3#))
(test (map if '(#f #f #t) '(0 1 2) '(3 4 5)) '(3 4 2))
(test (map apply (map lambda '(() (a) (a b)) '(1 (+ a 1) (+ a b 1))) '(() (2) (3 4))) '(1 3 8))
(test (map values (list 1 2 3) (list 4 5 6)) '(1 4 2 5 3 6))
(test (map map (list values) '((1 2)) '((3 4))) '((1 3 2 4)))
(test (map values '((1 2)) '((3 4))) '((1 2) (3 4)))
(test (map map (list map) (list (list values)) '(((1 2))) '(((3 4)))) '(((1 3 2 4))))
(test (map apply (list values) '(((1 2))) '(((3 4)))) (apply map values '(((1 2))) '(((3 4))))) ; !
(test (let ((x '((1 2)))) (eval `(apply apply values x)) (object->string x)) "((1 2))") ; not "((values 1 2))" -- 24-Aug-12

(let ()
  (define (shuffle . args) 
    (apply map values args))
  (test (shuffle '(1 2 3) #(4 5 6) '(7 8 9)) '(1 4 7 2 5 8 3 6 9))
  (test (shuffle '(1 2 3)) '(1 2 3))
  (test (shuffle '(1 2 3) '(4)) '(1 4))
  (test (shuffle '(1 2 3) ()) ())
  )

(test (map list "hi") '((#\h) (#\i)))
(test (map string "hi") '("h" "i"))
(test (map vector "hi") '(#(#\h) #(#\i)))
(test (map char-upcase "hi") '(#\H #\I))
(test (map append #(#() #())) '(#() #()))

(test (map abs '() abs) 'error)
(test (map (lambda (x) (display "map should not have called this"))) 'error)
(test (map (lambda () 1) '()) '())
(test (let ((ctr 0)) (map (lambda (x y z) (set! ctr (+ ctr x y z)) ctr) '(1) '(3) '())) '())
(test (let ((ctr 0)) (map (lambda (x y z) (set! ctr (+ ctr x y z))) '(0 1) '(2 3) '(4 5 6))) '(6 15))

(test (map (lambda (a b) (+ a b)) (list 1)) 'error)
(test (map (lambda (a b) (+ a b)) (list 1) (list)) '())
(test (map (lambda (a b) (+ a b)) (list 1) (list 2)) (list 3))
(test (map (lambda (a b) (+ a b)) (list 1)) 'error)
(test (map (lambda (a b) (+ a b)) (list 1) (list 2) (list 3)) 'error)
(test (map (lambda (a b) (+ a b)) (list 1) (list 1 2)) '(2))
(test (map (lambda (a b) (+ a b)) (list 1 2) (list 1)) '(2))
(test (map (lambda (a b) (+ a b)) (list 1 2) (list 1 2 3)) '(2 4))
(test (map (lambda (a b) (+ a b)) (list 1 2) (list 1)) '(2))
(test (map (lambda (a b) (+ a b)) (list 1 2) (list 1 2) (list)) '())
(test (map (lambda (a b) (+ a b)) (list 1 2) (list 1 2) (list 1 2)) 'error)
(test (map (lambda (a b) (+ a b)) (list 1 2) (cons 1 2)) '(2))

(test (map (lambda* (x . args) args) '(1 2 3)) '(() () ()))
(test (map (lambda (x . args) args) '(1 2 3)) '(() () ()))
(test (map (lambda* (x . args) (list x args)) '(1 2 3)) '((1 ()) (2 ()) (3 ())))
(test (map (lambda (x . args) (list x args)) '(1 2 3)) '((1 ()) (2 ()) (3 ())))
(test (map (lambda args args) '(1 2 3)) '((1) (2) (3)))
(test (map (lambda* args args) '(1 2 3)) '((1) (2) (3)))
(test (map (lambda (x y . args) args) '(1 2 3)) 'error)
(test (map (lambda* (x y . args) args) '(1 2 3)) '(() () ())) ; all args are optional in lambda*
(test (map (lambda (x y . args) args) '(1 2 3) '(4 5 6)) '(() () ()))
(test (map (lambda* (x y . args) args) '(1 2 3) '(4 5 6)) '(() () ()))
(test (map (lambda (x y . args) (list x y args)) '(1 2 3) '(4 5 6)) '((1 4 ()) (2 5 ()) (3 6 ())))
(test (map (lambda* (x y . args) (list x y args)) '(1 2 3) '(4 5 6)) '((1 4 ()) (2 5 ()) (3 6 ())))
(test (map (lambda (x y . args) (list x y args)) '(1 2 3) '(4 5 6) '(7 8 9)) '((1 4 (7)) (2 5 (8)) (3 6 (9))))
(test (map (lambda* (x y . args) (list x y args)) '(1 2 3) '(4 5 6) '(7 8 9)) '((1 4 (7)) (2 5 (8)) (3 6 (9))))
(test (map (lambda* (x y :rest args) (list x y args)) '(1 2 3) '(4 5 6) '(7 8 9)) '((1 4 (7)) (2 5 (8)) (3 6 (9))))

(test (map (lambda . (x y z 8)) '(1 2 3))  'error) ; (y unbound) but other schemes ignore unused args
(test (map (lambda . (x 8)) '(1 2)) '(8 8)) 

(test (map (lambda (a) (+ a 1)) (list 1) (list 2)) 'error)
(test (map (lambda (a) (+ a 1)) #\a) 'error)
(test (map (lambda (a) (+ a 1)) (cons 1 2)) '(2))
(test (map (lambda (a b . args) (+ a b (apply + args))) '(0 1 2)) 'error)
(test (map (lambda (a) a) '(1 2 . 3)) '(1 2))
(test (map) 'error)
(test (map #t) 'error)
(test (map set-cdr! '(1 2 3)) 'error)
(test (map (lambda (a b) (set-cdr! a b) b) '((1) (2) (3)) '(4 5 6)) '(4 5 6))
(test (let ((str "0123")) (set! (str 2) #\null) (map append str)) '(#\0 #\1 #\null #\3))

(test (map ((lambda () abs)) '(-1 -2 -3)) '(1 2 3))
(test (apply map ((lambda () abs)) (list (list -1 -2 -3))) '(1 2 3))
(test (apply apply map ((lambda () abs)) (list (list (list -1 -2 -3)))) '(1 2 3))
(test (apply apply apply map ((lambda () abs)) '((((-1 -2 -3))))) '(1 2 3))
(test (apply apply apply (list (list map abs (list (list -1 -2 -3))))) '(1 2 3))
(test (apply apply list 1 '((1 2) (3 4))) '(1 (1 2) 3 4))
(test (apply + (apply apply apply (list (list map abs (list (list -1 -2 -3)))))) 6)
(test (apply (apply apply lambda '(a) '(((+ a 1)))) '(14)) 15)
(test (let ((a 14)) (apply apply quasiquote '(((+ ,a 1))))) '(+ 14 1))
(test (apply map vector (values (list (vector 1 2)))) '(#(1) #(2)))
(test (apply map string (list "123")) '("1" "2" "3"))
(test (map string "123") '("1" "2" "3"))
(test (map "hi" '(0 1)) '(#\h #\i))
(test (map (list 2 3) '(0 1)) '(2 3))
(test (map #(2 3) '(1 0)) '(3 2))
(for-each
 (lambda (arg)
   (test (map arg (list 1)) 'error))
 (list -1 #\a 1 'a-symbol 3.14 3/4 1.0+1.0i #f #t))
(for-each
 (lambda (arg)
   (test (map (lambda (n m) n) (list 1) arg) 'error))
 (list -1 #\a 1 'a-symbol 3.14 3/4 1.0+1.0i #f #t))
(for-each
 (lambda (arg)
   (test (map (lambda (a) a) arg) 'error))
 (list -1 #\a 1 'a-symbol 3.14 3/4 1.0+1.0i #f #t))

(test (map (lambda (a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
	     (max a1 a2 a3 a4 a5 a6 a7 a8 a9 a10))
	   (list 6 7 8 9 10)
	   (list 21 22 23 24 25)
	   (list 16 17 18 19 20)
	   (list 11 12 13 14 15)
	   (list 26 27 28 29 30)
	   (list 1 2 3 4 5)
	   (list 36 37 38 39 40)
	   (list 41 42 43 44 45)
	   (list 46 47 48 49 50)
	   (list 31 32 33 34 35))
      (list 46 47 48 49 50))
  
(test (map (lambda (a1 a2 a3 a4 a5 a6 a7 a8 a9 . a10)
	     (apply max a1 a2 a3 a4 a5 a6 a7 a8 a9 a10))
	   (list 6 7 8 9 10)
	   (list 21 22 23 24 25)
	   (list 16 17 18 19 20)
	   (list 11 12 13 14 15)
	   (list 26 27 28 29 30)
	   (list 1 2 3 4 5)
	   (list 36 37 38 39 40)
	   (list 41 42 43 44 45)
	   (list 46 47 48 49 50)
	   (list 31 32 33 34 35))
      (list 46 47 48 49 50))

(test (map (lambda* (a1 a2 a3 . a10)
	     (apply max a1 a2 a3 a10))
	   (list 6 7 8 9 10)
	   (list 21 22 23 24 25)
	   (list 16 17 18 19 20)
	   (list 11 12 13 14 15)
	   (list 26 27 28 29 30)
	   (list 1 2 3 4 5)
	   (list 36 37 38 39 40)
	   (list 41 42 43 44 45)
	   (list 46 47 48 49 50)
	   (list 31 32 33 34 35))
      (list 46 47 48 49 50))

(test (map (lambda args
	     (apply max args))
	   (list 6 7 8 9 10)
	   (list 21 22 23 24 25)
	   (list 16 17 18 19 20)
	   (list 11 12 13 14 15)
	   (list 26 27 28 29 30)
	   (list 1 2 3 4 5)
	   (list 36 37 38 39 40)
	   (list 41 42 43 44 45)
	   (list 46 47 48 49 50)
	   (list 31 32 33 34 35))
      (list 46 47 48 49 50))
  
(test (map map (list abs) (list (list -1))) '((1)))
(test (map map (list map) (list (list abs)) (list (list (list -1)))) '(((1))))
(test (map map (list map) (list (list map)) (list (list (list abs))) (list (list (list (list -1 -3))))) '((((1 3)))))
(test (map map (list lcm) (vector #(1 2))) '((1 2)))
(test (map map (list integer?) (list (vector "hi" 1 2/3))) '((#f #t #f)))
(test (map map (list char-lower-case?) (list "hAba")) '((#t #f #t #t)))
(test (map map (list char-lower-case? char-upper-case?) (list "hAba" "HacDf")) '((#t #f #t #t) (#t #f #f #t #f)))
(test (map map (list + -) (list (list 1 2) (list 3 4))) '((1 2) (-3 -4)))
(test (map map (list map map) (list (list + -) (list - +)) '(((1 2) (3 4)) ((4 5) (6 7)))) '(((1 2) (-3 -4)) ((-4 -5) (6 7))))

(test (map member (list 1 2 3) (list (list 1 2 3) (list 1 3 4) (list 3 4 5))) '((1 2 3) #f (3 4 5)))
(test (map - (list 1 2 3) (list 1 2 3) (list 1 3 4) (list 3 4 5)) '(-4 -7 -9))
(test (map - (list 1 2 3) (list 1 2 3 'hi) (list 1 3 4 #\a "hi") (list 3 4 5)) '(-4 -7 -9))
(test (let () (define (mrec a b) (if (<= b 0) (list a) (map mrec (list a) (list (- b 1))))) (mrec (list 1 2) 5)) '(((((((1 2))))))))
(test (map append '(3/4)) '(3/4))
(test (map list '(1.5)) '((1.5)))
(test (map vector '("hi")) '(#("hi")))
(test (map object->string '(:hi (1 2) (()))) '(":hi" "(1 2)" "(())"))
(test (map map (list for-each) (list (list abs)) (list (list (list 1 2 3)))) '((#<unspecified>)))
(test (map map (list vector) '((#(1 #\a (3))))) '((#(#(1 #\a (3))))))
(test (apply map map (list cdr) '((((1 2) (3 4 5))))) '(((2) (4 5))))
(test (apply map map (list char-upcase) '(("hi"))) '((#\H #\I)))
(test (apply map map (list *) '(((1 2)) ((3 4 5)))) '((3 8))) ; (* 1 3) (* 2 4)
(test (map apply (list map) (list map) (list (list *)) '((((1 2)) ((3 4 5))))) '(((3 8))))
(test (map map (list magnitude) '((1 . 2))) '((1))) ; magnitude is called once with arg 1
(test (map magnitude '(1 . 2)) '(1))
(test (map call/cc (list (lambda (r1) 1) (lambda (r2) (r2 2 3)) (lambda (r3) (values 4 5)))) '(1 2 3 4 5))
(test (map call/cc (list number? continuation?)) '(#f #t))

;; from scheme working group 
(test (let ((L (list 1 2 3 4 5))) (map (lambda (x) (set-cdr! (cddr L) 5) x) L)) '(1 2 3))
(test (let ((L (list 1 2))) (map (lambda (x) (set! (cdr (cdr L)) L) x) L)) '(1 2))
(test (let ((L (list 1 2))) (object->string (map (lambda (x) (set! (car (cdr L)) L) x) L))) "(1 #1=(1 #1#))")
;;;(test (let ((L (list 1 2))) (map (lambda (x) (set-cdr! L L) x) L)) '(1 2)) ;?? this depends on when we cdr? infinite loop in Guile
;;;(let ((L (list 1 2 3 4 5))) (map (lambda (x) (set-cdr! L '()) x) L)) ; another similar case -- s7 doesn't notice what happened
;;;  does that mean a GC during this map would leave us accessing freed memory? 
;;;  I think not because the original list is held by map (eval) locals that are protected
;;;  we simply stepped on something after looking at it, similar to:
(test (let ((L (list 1 2 3 4 5))) (map (lambda (x) (set-car! L 123) x) L)) '(1 2 3 4 5))
(test (let ((L (list 1 2 3 4 5))) (map (lambda (x) (set-cdr! (cddr L) (list 6 7 8)) x) L)) '(1 2 3 6 7))
;;; we could do something similar with strings:
(test (let ((S "12345")) (map (lambda (x) (set! (S 2) #\null) x) S)) '(#\1 #\2 #\null #\4 #\5))
;;; (length S) is still 5 even with the embedded null
(test (let ((L (list 1 2 3))) (map (lambda (x) (set! L (list 6 7 8)) x) L)) '(1 2 3))
(test (let ((L1 (list 1 2 3)) (L2 (list 4 5 6 7))) (map (lambda (x1 x2) (set-cdr! (cdr L1) '()) (cons x1 x2)) L1 L2)) '((1 . 4) (2 . 5)))
(test (let ((L (list 1 2 3))) (map (lambda (x) (set-car! (cddr L) 32) x) L)) '(1 2 32))
;;; should these notice the increased length?:
(test (let ((L1 (list 1 2)) (L2 (list 6 7 8 9))) (map (lambda (x y) (set-cdr! (cdr L1) (list 10 11 12 13 14)) (cons x y)) L1 L2)) '((1 . 6) (2 . 7)))
(test (let ((L1 (list 1)) (L2 (list 6 7 8))) (map (lambda (x y) (set-cdr! L1 (list 10 11 12)) (cons x y)) L1 L2)) '((1 . 6)))
(test (let ((L1 (list 1 2))) (map (lambda (x) (set-cdr! (cdr L1) (list 10 11 12)) x) L1)) '(1 2))
;;; a similar case could be made from hash-tables
(test (let ((H (hash-table '(a . 3) '(b . 4)))) (map (lambda (x) (set! (H 'c) 32) (cdr x)) H)) '(3 4))
(test (let ((H (hash-table '(a . 3) '(b . 4)))) (map (lambda (x) (set! (H 'b) 32) (cdr x)) H)) '(3 32))

;; in that 1st example, the set-cdr! is not the problem (map supposedly can treat its args in any order),
;;   any set! will do:
(test (let ((x 0)) (map (lambda (y) (set! x (+ x y)) x) '(1 2 3 4))) '(1 3 6 10))

(test (map begin '(1 2 3)) '(1 2 3))
(let ((funcs (map (lambda (lst) (eval `(lambda ,@lst))) '((() #f) ((arg) (+ arg 1))))))
  (test ((car funcs)) #f)
  (test ((cadr funcs) 2) 3))

(test (map = #() =) 'error)
(test (map ="") '())
(test (map abs ()) ())
(test (map abs "") ())
(test (map abs "123" "") ()) ; should this be an error -- arity is wrong?
(test (map abs "123" "" #f) 'error)
(test (map null? () #() "") ())
(test (map null? () #() 0 "") 'error)
(test (map '(()) #()) '())
(test (map '(1 2 . 3) '(1 . 2)) '(2))
(test (map '(()) '()) '())
(test (map #2D((1 2) (3 4)) '(1)) '(#(3 4)))
(test (map "a\x00b" #(1 2)) '(#\null #\b))
(test (map #(1 (3)) '(1)) '((3)))
(test (map '((1 (2)) (((3) 4))) '(1)) '((((3) 4))))
(test (map "hi" '(1)) '(#\i))
(test (map #() #()) '())
(test (map '(1 . 2) #()) '())
(test (map ''2 '(1)) '(2))
(test (((map lambda '((x)) '(1 2 . 3)) 0) 0) 1)
(test (((map lambda '(()) #(1 2)) 0)) 1)
(test (((map lambda '((x)) '((+ x 1))) 0) 32) 33)
(test (map #() '()) '()) ; hmmm -- (map '() '()) is an error
(test (map () ()) 'error)
(test (map "" "") '())
(test (map (let ((lst (list 1 2))) (set! (cdr (cdr lst)) lst) lst) '(0)) '(1))
(let ((lst (list 1 2))) (set! (cdr (cdr lst)) lst) (test (map lst lst) 'error))
(test (map 1 "hi" '()) 'error)
(test (map 0 #() '()) 'error)
(test (map #\a #(1 2) '(3 4) "") 'error)
(test (map or '(1 2 . 3)) '(1 2))
(test (map or "a\x00b") '(#\a #\null #\b))
(test (map cond '((1 2) (3 4))) '(2 4)) ; (cond (1 2)) -> 2
(test (map begin "hi") '(#\h #\i))
(test (map quote "hi") '(#\h #\i))
(test (map (begin #(1 (3))) '(1)) '((3)))
(test (map (''2 0) ''2) 'error)
(test (map (apply lambda 'a '(-1)) '((1 2))) '(-1))
(test (map do '(()) '((1 2))) '(2))
(test (map case '(1) '(((-1 1) 2) 3)) '(2))
(test (map let '(()) "a\x00b") '(#\a))
(test (map "hi" '(0 1) '(0 1)) 'error)
(test (map '((1 2) (3 4)) '(0 1) '(0 1)) '(1 4))
(test (map #2d((1 2) (3 4)) '(0 1) '(0 1)) '(1 4))
(test (map #2d((1 2) (3 4)) '(0 1)) '(#(1 2) #(3 4)))
(let ((lst (list 1 2))) (set! (cdr (cdr lst)) lst) (test (map (lambda (a) a) lst) 'error))
(let ((lst (list 1 2))) (set! (cdr (cdr lst)) lst) (test (map (lambda (a) a) lst lst) 'error))
(test (map "hi" ('((1)) 0)) '(#\i))
(test (map "hi" ('((1 0)) 0)) '(#\i #\h))
(test (let ((ht (hash-table '(a . 1) '(b . 2)))) (map ht ht)) '(#f #f))
(test (let ((ht (hash-table '(a . 1) '(b . 2)))) (let ((lst (map (lambda (c) (cdr c)) ht))) (or (equal? lst '(1 2)) (equal? lst '(2 1))))) #t)
(test (let ((ht (hash-table '(a . 1) '(b . 2)))) (map ht '(a b))) '(1 2))

(test (map '((1 2) (3 4)) #(1) #(1)) '(4))
(test (map (quasiquote ((1 2) (3 4))) #(1) #(1 2)) '(4))

(let ((pws (make-procedure-with-setter (lambda (a) a) (lambda (a b) b))))
  (test (map append pws) 'error)
  (test (map pws '(1 2 3)) '(1 2 3)))

(test (map abs '(1 2 . 3)) '(1 2)) ;; ?? Guile says wrong type arg here
(test (map + '(1) '(1 2 . 3)) '(2))
(test (map abs '(1 . 2)) '(1))
;; problematic because last thing is completely ignored:
(test (map abs '(1 . "hi")) '(1))
(test (map floor '(1 . "hi")) '(1))

(for-each
 (lambda (op)
   (test (map op '()) 'error)
   (test (map op "") 'error)
   (test (map op #() (list) (string)) 'error))
 (list 0 '() #f #t 'a-symbol :hi #\a #<eof> #<unspecified> #<undefined> 0.0 1+i 1/2 1/0 0/0 *stdout* (current-input-port)))

(test (map append (make-vector (list 2 0))) '())
(let ((p1 (make-procedure-with-setter (lambda (a) (+ a 1)) (lambda (a b) (+ a b)))))
  (test (map p1 '(1 2 3)) '(2 3 4)))
(test (map (lambda args (+ (car args) 1)) '(1 2 3)) '(2 3 4))
(test (map (lambda* (a (b 2)) (+ a 1)) '(1 2 3)) '(2 3 4))
(let ((p1 (make-procedure-with-setter (lambda (a b) (+ a b)) (lambda (a b c) (+ a b c)))))
  (test (map p1 '(1 2 3) '(3 2 1)) '(4 4 4)))
(test (map (lambda args (+ (car args) (cadr args))) '(1 2 3) '(3 2 1)) '(4 4 4))
(test (map (lambda* (a (b 2)) (+ a b)) '(1 2 3) '(3 2 1)) '(4 4 4))
(test (map (lambda* (a (b 2)) (+ a b)) '(1 2 3)) '(3 4 5))
(test (map (lambda* ((a 1) (b (map (lambda (c) (+ c 1)) (list 1 2)))) (+ a (apply + b))) (list 4 5 6)) '(9 10 11))
(test (let ((lst (list 0 1 2))) (map (lambda* ((a 1) (b (for-each (lambda (c) (set! (lst c) (+ (lst c) 1))) (list 0 1 2)))) a) lst)) '(0 2 4))

(test (let ((lst '(1 2 3))) (define-macro (hiho a) `(+ 1 ,a)) (map hiho lst)) '(2 3 4))
(test (let ((lst '(1 2 3))) (define-macro (hiho a b) `(+ 1 ,a (* 2 ,b))) (map hiho lst lst)) '(4 7 10))
(test (let ((lst '(1 2 3))) (define-macro (hi1 a) `(+ 1 ,a)) (define-macro (hiho a b) `(+ 1 ,a (* 2 ,b))) (map hiho lst (map hi1 lst))) '(6 9 12))
(test (let ((lst '(1 2 3))) (define-macro (hiho a b) `(+ 1 ,a (* 2 ,b))) (map hiho lst (map (symbol->value (define-macro (hi1 a) `(+ 1 ,a))) lst))) '(6 9 12))
(test (let ((lst '(1 2 3))) (define-macro (hi a) `(+ 1 ,a)) (define-macro (ho b) `(+ 1 (hi ,b))) (map ho lst)) '(3 4 5))
(test (let ((lst '(1 2 3))) (define-macro* (hi a (b 2)) `(+ 1 ,a (* 2 ,b))) (map hi lst)) '(6 7 8))
(test (let ((lst '(1 2 3))) (define-macro* (hi a (b 2)) `(+ 1 ,a (* 2 ,b))) (map hi lst (map hi lst))) '(14 17 20))

(let ()
  (define (hi)
    (map (lambda (a) (a 0))
	 (list (vector 1 2 3)
	       (string #\a #\b #\c)
	       (list 'e 'f 'g))))
  (test (hi) '(1 #\a e)))

(let ((ctr -1)) 
  (apply begin (map (lambda (symbol) 
		      (set! ctr (+ ctr 1))
		      (list 'define symbol ctr))
		    '(_zero_ _one_ _two_)))
  (+ _zero_ _one_ _two_))

(let ()
  (define (map-with-exit func . args)
  ;; func takes escape thunk, then args
  (let* ((result '())
	 (escape-tag (gensym))
	 (escape (lambda () (throw escape-tag))))
    (catch escape-tag
      (lambda ()
	(let ((len (apply max (map length args))))
	  (do ((ctr 0 (+ ctr 1)))
	      ((= ctr len) (reverse result))      ; return the full result if no throw
	    (let ((val (apply func escape (map (lambda (x) (x ctr)) args))))
	      (set! result (cons val result))))))
      (lambda args
	(reverse result))))) ; if we catch escape-tag, return the partial result

  (define (truncate-if func lst)
    (map-with-exit (lambda (escape x) (if (func x) (escape) x)) lst))

  (test (truncate-if even? #(1 3 5 -1 4 6 7 8)) '(1 3 5 -1))
  (test (truncate-if negative? (truncate-if even? #(1 3 5 -1 4 6 7 8))) '(1 3 5))
  )

;;; this is testing the one-liner unsafe closure optimizations
(test (let ()
	(define (fib n)
	  (if (< n 2)
	      n
	      (+ (fib (- n 1))
		 (fib (- n 2)))))
	(let ((x 0)
	      (ctr -1))
	  (map
	   (lambda (f)
	     (let ((z 1))
	       (set! ctr (+ ctr 1))
	       (case ctr
		 ((0 1 2 3) (f z))
		 ((4 5) (f z z))
		 ((6 7) (values (f (+ 1)) (f (+ 2)))))))
	   (list
	    (lambda (i)
	      (set! x (list i)))
	    (lambda (i)
	      (set! x (list i))
	      (set! x (list (+ i 1))))
	    (vector 1 2 3)
	    (list 3 2 1)
	    (lambda (a b)
	      (+ a b))
	    (lambda (a b)
	      (+ a b)
	      (+ a b a))
	    (lambda (a)
	      (if (< a 2) a (+ (fib (- a 1)) (fib (- a 2)))))
	    (lambda (a)
	      (if (zero? a) a (list a))
	      (list (+ a 10)))
	    ))))
      '((1) (2) 2 2 2 3 1 1 (11) (12)))
;;; more along the same lines
(test (let () (define (f2 a) (+ a 1)) (define (f1 a) (f2 a)) (define (f2 a) (- a)) (f1 12)) -12)
(test (let () (define (f2 a) (+ a 1)) (define (f1 a) (f2 a 1)) (define (f2 a b) (- a b)) (f1 12)) 11)
(test (let () (define (f2 a) (+ a 1)) (define (f1 a) (f2 a)) (define (f2 a) (- a 1)) (f1 12)) 11)

(test (let () (define* (f2 a) (+ a 1)) (define (f1 a) (f2 a)) (define* (f2 a) (- a)) (f1 12)) -12)
(test (let () (define* (f2 a) (+ a 1)) (define (f1 a) (f2 a 1)) (define* (f2 a b) (- a b)) (f1 12)) 11)
(test (let () (define* (f2 a) (+ a 1)) (define (f1 a) (f2 a)) (define* (f2 a) (- a 1)) (f1 12)) 11)



#|
;;; this is from the r6rs comment site
(let ((resume #f)
       (results '()))
   (set! results
         (cons (map (lambda (x)
                      (call/cc (lambda (k)
                                 (if (not resume) (set! resume k))
                                 0)))
                    '(#f #f))
               results ))
   (display results) (newline)
   (if resume
       (let ((resume* resume))
         (set! resume #f)
         (resume* 1))))

With a careful implementation of MAP, a new list is returned every
time, so that the displayed results are

   ((0 0))
   ((1 0) (0 0))
   ((1 1) (1 0) (0 0))

in s7:
((0 0))
((1 0) (0 0))
((0 . #1=(1 1)) #1# (0 0))

|#
