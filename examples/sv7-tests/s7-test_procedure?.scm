(test (procedure? car) #t)
(test (procedure? procedure?) #t)
(test (procedure? 'car) #f)
(test (procedure? (lambda (x) x)) #t)
(test (procedure? '(lambda (x) x)) #f)
(test (call/cc procedure?) #t) ; ??
(test (let ((a (lambda (x) x)))	(procedure? a)) #t)
(test (letrec ((a (lambda () (procedure? a)))) (a)) #t)
(test (let ((a 1)) (let ((a (lambda () (procedure? a)))) (a))) #f)
(test (let () (define (hi) 1) (procedure? hi)) #t)
(test (let () (define-macro (hi a) `(+ ,a 1)) (procedure? hi)) #f)
(test (procedure? begin) #f)
(test (procedure? lambda) #f)
(test (procedure? (lambda* ((a 1)) a)) #t)
(test (procedure? and) #f)
(test (procedure? 'let) #f)
(test (procedure? (make-procedure-with-setter (lambda () 1) (lambda (x) x))) #t)
(if with-bignums (test (procedure? (bignum "1e100")) #f))
(test (procedure? quasiquote) #f)
(let () (define-macro (hi a) `(+ ,a 1)) (test (procedure? hi) #f))
(test (procedure? (make-random-state 1234)) #f)
(test (procedure? pi) #f)
(test (procedure? cond) #f)
(test (procedure? do) #f)
(test (procedure? set!) #f)

(for-each
 (lambda (arg)
   (if (procedure? arg)
       (format #t ";(procedure? ~A) -> #t?~%" arg)))
 (list "hi" _ht_ :hi (integer->char 65) 1 (list 1 2) '#t '3 (make-vector 3) 3.14 3/4 1.0+1.0i #\f #() (if #f #f)))

(test (procedure?) 'error)
(test (procedure? abs car) 'error)
(test (procedure abs) 'error)

;; these are questionable -- an applicable object is a procedure
(test (procedure? "hi") #f)
(test (procedure? '(1 2)) #f)
(test (procedure? #(1 2)) #f)
