(test (procedure-arity car) '(1 0 #f))
(test (procedure-arity 'car) '(1 0 #f))
(test (procedure-arity +) '(0 0 #t))
(test (procedure-arity '+) '(0 0 #t))
(test (procedure-arity log) '(1 1 #f))
(test (procedure-arity '/) '(1 0 #t))
(test (procedure-arity catch) '(3 0 #f))
(test (procedure-arity) 'error)
(test (procedure-arity abs abs) 'error)
(test (procedure-arity "hi") 'error)

(test (procedure-arity vector-set!) '(3 0 #t))
(test (let ((hi (lambda () 1))) (procedure-arity hi)) '(0 0 #f))
(test (let ((hi (lambda (a) 1))) (procedure-arity hi)) '(1 0 #f))
(test (let ((hi (lambda (a b) 1))) (procedure-arity hi)) '(2 0 #f))
(test (let ((hi (lambda (a . b) 1))) (procedure-arity hi)) '(1 0 #t))
(test (let ((hi (lambda a 1))) (procedure-arity hi)) '(0 0 #t))

(test (let () (define (hi) 1) (procedure-arity hi)) '(0 0 #f))
(test (let () (define (hi a) a) (procedure-arity hi)) '(1 0 #f))
(test (let () (define* (hi a) a) (procedure-arity hi)) '(0 1 #f))
(test (let () (define* (hi a . b) a) (procedure-arity hi)) '(0 1 #t))
(test (let () (define* (hi (a 1) (b 2)) a) (procedure-arity hi)) '(0 2 #f))
(test (let ((hi (lambda* (a) 1))) (procedure-arity hi)) '(0 1 #f))
(test (call/cc (lambda (func) (procedure-arity func))) '(0 0 #t))

(test (procedure-arity (lambda* (a :rest b) a)) '(0 1 #t))
(test (procedure-arity (lambda* (:optional a :rest b) a)) '(0 1 #t))
(test (procedure-arity (lambda* (:optional a :key b :rest c) a)) '(0 2 #t))
(test (procedure-arity (lambda* (:optional a b) a)) '(0 2 #f))
(test (procedure-arity (lambda* (:rest args) args)) '(0 0 #t))
(test (procedure-arity (lambda* (a :optional b . c) a)) '(0 2 #t))
(test (procedure-arity (lambda* (:rest a . b) a)) '(0 0 #t))
(test (procedure-arity (lambda* a a)) '(0 0 #t))
(test (let () (define-macro (hi a) `(+ ,a 1)) (procedure-arity hi)) 'error)
(test (procedure-arity (make-procedure-with-setter (lambda (a) a) (lambda (a b) a))) '(1 0 #f))
(test (procedure-arity (make-procedure-with-setter (lambda (a . b) a) (lambda (a b) a))) '(1 0 #t))
(test (procedure-arity (make-procedure-with-setter (lambda* (a :optional b) a) (lambda (a b) a))) '(0 2 #f))

(test (procedure-arity (lambda (x . args) x)) '(1 0 #t))
(test (procedure-arity (lambda (x y . args) x)) '(2 0 #t))
(test (procedure-arity (lambda* (x . args) x)) '(0 1 #t))
(test (procedure-arity (lambda* (x y . args) x)) '(0 2 #t))

(test (procedure-arity (lambda* (a :allow-other-keys) 1)) '(0 1 #f)) ; which is actually right and wrong at the same time!


(for-each
 (lambda (arg)
   (test (procedure-arity arg) 'error))
 (list -1 #\a #f _ht_ 1 '#(1 2 3) 3.14 3/4 1.0+1.0i '() 'hi '#(()) (list 1 2 3) '(1 . 2) "hi"))

(define (for-each-subset func args)
  (let ((subsets '()))
    (define (subset source dest len)
      (if (null? source)
	  (begin
	    (if (member dest subsets)
		(format #t ";got ~S twice in for-each-subset: ~S~%" dest args))
	    (set! subsets (cons dest subsets))
	    (if (aritable? func len)
		(apply func dest)))
	  (begin
	    (subset (cdr source) (cons (car source) dest) (+ len 1))
	    (subset (cdr source) dest len))))
    (subset args '() 0)))

(test (let ((ctr 0))
	(for-each-subset (lambda args (set! ctr (+ ctr 1))) '(1 2 3 4))
	ctr)
      16)
(test (let ((ctr 0))
	(for-each-subset (lambda (arg) (set! ctr (+ ctr 1))) '(1 2 3 4))
	ctr)
      4)
(test (let ((ctr 0))
	(for-each-subset (lambda (arg1 arg2 arg3) (set! ctr (+ ctr 1))) '(1 2 3 4))
	ctr)
      4)
(test (let ((ctr 0))
	(for-each-subset (lambda* (arg1 arg2 arg3) (set! ctr (+ ctr 1))) '(1 2 3 4))
	ctr)
      15)
(test (let ((ctr 0))
	(for-each-subset (lambda () (set! ctr (+ ctr 1))) '(1 2 3 4))
	ctr)
      1)

(define (snarf func lst)
  "(snarf func lst) repeatedly applies func to as many elements of lst as func can take"
  (let ((arity (procedure-arity func)))
    (if (caddr arity)
	(apply func lst)
	(let ((n (+ (car arity) (cadr arity)))
	      (lst-len (length lst)))
	  (if (< lst-len (car arity))
	      (error 'wrong-number-of-args ";snarf func requires ~A args, but got ~A, ~A" (car arity) lst-len lst)
	      (if (<= lst-len n)
		  (apply func lst)
		  (if (not (zero? (modulo (length lst) n)))
		      (error 'wrong-number-of-args ";snarf will take ~A args at a time, but got ~A in ~A" n lst-len lst)
		      ;; ideally this would accept partial lists (i.e. left-over < req),
		      ;;   but then we also need to notice that case in the list-tail below
		      (let ()
			
			(define (snarf-1 len f args)
			  (if (not (null? args))
			      (let* ((last (list-tail args (- len 1)))
				     (rest (cdr last)))
				(dynamic-wind
				    (lambda ()
				      (set! (cdr last) '()))
				    (lambda ()
				      (apply func args))
				    (lambda ()
				      (set! (cdr last) rest)))
				(snarf-1 len f rest))))
			
			(snarf-1 n func lst)))))))))

(test (let ((lst '(1 2 3 4))) (catch #t (lambda () (snarf (lambda (a b) (format #t "~A ~A~%" a b c)) lst)) (lambda args 'error)) lst) '(1 2 3 4))
(test (snarf (lambda (a b) (format #t "~A ~A~%" a b)) '(1 2 3 4 5)) 'error)
(test (snarf (lambda (a b) (format #t "~A ~A~%" a b)) '(1)) 'error)
(test (let ((x 0)) (snarf (lambda (a) (set! x (+ x a))) '(1 2 3)) x) 6)
(test (let ((x 0)) (snarf (lambda (a b) (set! x (+ x a b))) '(1 2 3 4)) x) 10)
(test (let ((x 0)) (snarf (lambda* (a b) (set! x (+ x a b))) '(1 2 3 4)) x) 10)
(test (let ((x 0)) (snarf (lambda a (set! x (apply + a))) '(1 2 3 4)) x) 10)
(test (let ((x 0)) (snarf (lambda* (a b (c 0)) (set! x (+ x a b c))) '(1 2)) x) 3)
