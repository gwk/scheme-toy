(test (list-tail '(1 2 3) 0) '(1 2 3))
(test (list-tail '(1 2 3) 2) '(3))
(test (list-tail '(1 2 3) 3) '())
(test (list-tail '(1 2 3 . 4) 2) '(3 . 4))
(test (list-tail '(1 2 3 . 4) 3) 4)
(test (let ((x (list 1 2 3))) (eq? (list-tail x 2) (cddr x))) #t)
(test (list-tail '() 0) '())
(test (list-tail '() 1) 'error)
(test (list-tail '(1 2 3) 4) 'error)
(test (list-tail '() -1) 'error)
(test (list-tail (list 1 2) 2) '())
(test (list-tail (cons 1 2) 0) '(1 . 2))
(test (list-tail (cons 1 2) 1) 2)
(test (list-tail (cons 1 2) 2) 'error)
(test (list-tail (cons 1 2) -1) 'error)
(test (list-tail ''foo 1) '(foo))
(test (list-tail '((1 2) (3 4)) 1) '((3 4)))
(test (list-tail (list-tail '(1 2 3) 1) 1) '(3))
(test (list-tail (list-tail (list-tail '(1 2 3 4) 1) 1) 1) '(4))
(test (list-tail '(1 2) (list-tail '(0 . 1) 1)) '(2))

(let ((x '(1 . 2))) (set-cdr! x x) (test (list-tail x 0) x))
(let ((x '(1 . 2))) (set-cdr! x x) (test (list-tail x 1) (cdr x)))
(let ((x '(1 . 2))) (set-cdr! x x) (test (list-tail x 100) x))

(let ((x (list 1 2 3)))
  (let ((y (list-tail x 1)))
    (set! (y 1) 32)
    (test (equal? y '(2 32)) #t)
    (test (equal? x '(1 2 32)) #t))) ; list-tail is not like substring

(for-each
 (lambda (name op1 op2)
   (for-each
    (lambda (lst)
      (let ((val1 (catch #t (lambda () (op1 lst)) (lambda args 'error)))
	    (val2 (catch #t (lambda () (op2 lst)) (lambda args 'error))))
	(if (not (equal? val1 val2))
	    (format #t ";(~A ~A) -> ~A ~A?~%" name lst val1 val2))))
    lists))
 (list 'list-tail:0 'list-tail:1 'list-tail:2 'list-tail:3 'list-tail:4)
 (list (lambda (l) l) cdr cddr cdddr cddddr)
 (list (lambda (l) (list-tail l 0)) (lambda (l) (list-tail l 1)) (lambda (l) (list-tail l 2)) (lambda (l) (list-tail l 3)) (lambda (l) (list-tail l 4))))

(test (list-tail (list 1 2) 3) 'error)
(test (list-tail (list 1 2) -1) 'error)
(test (list-tail (list 1 2) 1.3) 'error)
(test (list-tail (list 1 2) 1/3) 'error)
(test (list-tail (list 1 2) 1+2.0i) 'error)
(test (list-tail '(1 2 . 3)) 'error)
(test (list-tail '(1 2 . 3) 1) '(2 . 3))
(test (list-tail '(1 2 . 3) 0) '(1 2 . 3))
(test (list-tail (list 1 2 3) (+ 1 (expt 2 32))) 'error)
(test (list-tail) 'error)
(test (list-tail '(1)) 'error)
(test (list-tail '(1) 1 2) 'error)
(test (set! (list-tail (list 1 2 3)) '(32)) 'error) ; should this work?

(for-each
 (lambda (arg)
   (test (list-tail (list 1 2) arg) 'error)
   (test (list-tail arg 0) 'error))
 (list "hi" -1 3 most-negative-fixnum most-positive-fixnum 
       (integer->char 65) #f 'a-symbol (make-vector 3) abs _ht_ quasiquote macroexpand 1/0 (log 0) 
       3.14 3/4 1.0+1.0i #\f #t (if #f #f) #<eof> #() #(1 2 3) (lambda (a) (+ a 1))))
