(test (copy 3) 3)
(test (copy 3/4) 3/4)
(test (copy "hi") "hi")
(test (copy 'hi) 'hi)
(test (copy (list 1 2 3)) (list 1 2 3))
(test (copy (vector 0.0)) (vector 0.0))
(test (copy #\f) #\f)
(test (copy (list 1 (list 2 3))) (list 1 (list 2 3)))
(test (copy (cons 1 2)) (cons 1 2))
(test (let ((x (list 1 2 3))) (eq? (copy x) x)) #f)
(test (let ((x (list 1 2 3))) (equal? (copy x) x)) #t)
(test (let ((x #(1 2 3))) (eq? (copy x) x)) #f)
(test (let ((x #(1 2 3))) (equal? (copy x) x)) #t)
(test (let ((x "hi")) (eq? (copy x) x)) #f)
(test (let ((x "hi")) (equal? (copy x) x)) #t)
(test (copy '(1 2 . 3)) '(1 2 . 3))
(test (copy (+)) 0)
(test (copy +) +)
(test (copy (#(#() #()) 1)) #())
(test (copy #f) #f)
(test (copy '()) '())
(test (copy #()) #())
(test (copy #2d((1 2) (3 4))) #2d((1 2) (3 4)))
(test (let ((f (lambda () 1))) ((copy f))) 1)
(test (let ((f (lambda () 1))) (eq? (copy f) f)) #t)
(test (let ((f (lambda* ((a 2)) (+ a 1)))) ((copy f))) 3)
(test (let ((f (lambda* ((a 2)) (+ a 1)))) (eq? (copy f) f)) #t)
(test (copy 1.0) 1.0)
(test (copy 1.0+i) 1.0+i)
(test (copy "") "")
(test (copy #t) #t)
(test (copy (string #\a #\null #\b)) "a\x00b")
(test (copy #<eof>) #<eof>)
(test ((copy abs) -123) 123)
(test (copy ''1) ''1)
(test (copy '''1) '''1)
(test (copy not) not)
(test (copy "a\x00b") "a\x00b")
(test (infinite? (copy (log 0.0))) #t)
(test (nan? (copy 1/0)) #t)
(test (copy if) if)
(test (copy quote) quote)
(test (let ((a 1) (b 2)) (equal? (copy (current-environment)) (current-environment))) #t)
(test (copy (global-environment)) (global-environment))
(test (copy (procedure-environment abs)) (global-environment))
(test (copy (procedure-environment macroexpand)) (global-environment))
(test (copy (procedure-environment quasiquote)) (global-environment))
(test (eval '(+ a 1) (copy (augment-environment (current-environment) '(a . 2)))) 3)

(test (copy (list 1 2 (list 3 4))) '(1 2 (3 4)))
(test (copy (cons 1 2)) '(1 . 2))
(test (copy '(1 2 (3 4) . 5)) '(1 2 (3 4) . 5))
(test (copy '()) '())

(test (copy) 'error)
(test (copy () () ()) 'error)

;;; 2 arg version of copy
(test (copy (list 1 2) (vector 0 0)) #(1 2))
(test (copy (list 1 2) (vector 0)) #(1))
(test (copy (list 1 2) (vector)) #())
(test (copy (list) (vector)) #())
(test (copy (list 1 2) (vector 0 0 3 4)) #(1 2 3 4))
; should (copy 1 2) be an error?
(test (copy #2d((1 2) (3 4)) (vector 0 0 0 0 0)) #(1 2 3 4 0))
(test (copy "12345" (make-list 5)) '(#\1 #\2 #\3 #\4 #\5))
(test (copy (list #\0 #\1 #\2) (make-string 3)) "012")
(test (copy '(0 1 2 3) (list 4 3 2 1)) '(0 1 2 3))
(test (copy #(0 1 2 3) (vector 4 3 2 1)) #(0 1 2 3))
(test (copy "12345" (make-string 5)) "12345")
(test (copy '(4 3 2 1) '(1 . 2)) '(4 . 2))
(test (copy (string (integer->char 255)) (vector 0)) #(#\xff))
(test (copy (vector (integer->char 255)) (string #\a)) (string (integer->char 255)))

(let ((lst (list 1 2 3)))
   (set! (cdr (cddr lst)) lst)
   (test (copy lst lst) lst)
   (test (copy lst (make-list 15 5)) '(1 2 3 1 2 3 5 5 5 5 5 5 5 5 5)))


(if with-bignums
    (begin
      (test (let ((x (bignum "1"))) (eq? x (copy x))) #f)
      (test (let ((x (bignum "1/2"))) (eq? x (copy x))) #f)
      (test (let ((x (bignum "1.0"))) (eq? x (copy x))) #f)
      (test (let ((x (bignum "1+i"))) (eq? x (copy x))) #f)))
(test (let ((x 1)) (eq? x (copy x))) #t) ; not sure this should be tested
(test (let ((x "str")) (eq? x (copy x))) #f)

(if (not (provided? 'gmp))
    (let ((r1 (make-random-state 1234)))
      (random 1.0 r1)
      (let ((r2 (copy r1)))
	(let ((v1 (random 1.0 r1))
	      (v2 (random 1.0 r2)))
	  (test (= v1 v2) #t)
	  (let ((v3 (random 1.0 r1)))
	    (random 1.0 r1)
	    (random 1.0 r1)
	    (let ((v4 (random 1.0 r2)))
	      (test (= v3 v4) #t)))))))

(if (provided? 'gmp)
    (let ((i (copy (bignum "1")))
	  (r (copy (bignum "3/4")))
	  (f (copy (bignum "1.5")))
	  (c (copy (bignum "1.0+1.0i"))))
      (test (= i (bignum "1")) #t)
      (test (= r (bignum "3/4")) #t)
      (test (= f (bignum "1.5")) #t)
      (test (= c (bignum "1.0+1.0i")) #t)))


;;; --------

(let ((c1 #f))
  (call/cc
   (lambda (c)
     (test (reverse c) 'error)
     (test (fill! c) 'error)
     (test (length c) 'error)
     (test (eq? c c) #t) ; is this the norm?
     (test (equal? c c) #t)
     (test (equal? c (copy c)) #t)
     (set! c1 c)))
  (test (continuation? c1) #t))

(let ((c1 #f))
  (call-with-exit
   (lambda (c)
     (test (reverse c) 'error)
     (test (fill! c) 'error)
     (test (length c) 'error)
     (test (eq? c c) #t) 
     (test (equal? c c) #t)
     (test (equal? c (copy c)) #t)
     (set! c1 c)))
  (test (procedure? c1) #t))


;;; length
(test (length (list 1 2)) 2)
(test (length "hiho") 4)
(test (length (vector 1 2)) 2)
(test (>= (length (make-hash-table 7)) 7) #t)
(test (length '()) 0)
(test (length (#(#() #()) 1)) 0)
(test (length abs) 'error)


;;; reverse
(test (reverse "hi") "ih")
(test (reverse "") "")
(test (reverse "123") "321")
(test (reverse "1234") "4321")
(test (reverse "a\x00b") "b\x00a")
(test (reverse #()) #())
(test (reverse #(1 2 3)) #(3 2 1))
(test (reverse #(1 2 3 4)) #(4 3 2 1))
(test (reverse #2D((1 2) (3 4))) #2D((4 3) (2 1)))
(test (reverse (string #\a #\null #\b)) "b\x00a")
(test (reverse abs) 'error)
