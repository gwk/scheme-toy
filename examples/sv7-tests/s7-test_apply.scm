(test (apply (lambda (a b) (+ a b)) (list 3 4)) 7)
(test (apply + 10 (list 3 4)) 17)
(test (apply list '()) '())
(test (apply + '(1 2)) 3)
(test (apply - '(1 2)) -1)
(test (apply max 3 5 '(2 7 3)) 7)
(test (apply cons '((+ 2 3) 4)) '((+ 2 3) . 4))
(test (apply + '()) 0)
(test (apply + (list 3 4)) 7)
(test (apply + '()) 0)
(test (apply + 2 '(3)) 5)
(test (apply + 2 3 '()) 5)
(test (apply + '(2 3)) 5)
(test (apply list 1 '(2 3)) (list 1 2 3))
(test (apply apply (list list 1 2 '(3))) (list 1 2 3))
(test (vector? (apply make-vector '(1))) #t)
(test (apply make-vector '(1 1)) '#(1))
(test (apply make-vector '((1) 1)) '#(1))
(test (let ((f +)) (apply f '(1 2))) 3)
(test (apply min '(1 2 3 5 4 0 9)) 0)
(test (apply min 1 2 4 3 '(4 0 9)) 0)
(test (apply vector 1 2 '(3)) '#(1 2 3))
(test (apply vector '()) #())
(test (apply (lambda (x . y) x) (list 1 2 3)) 1)
(test (apply * (list 2 (apply + 1 2 '(3)))) 12)
(test (apply (if (> 3 2) + -) '(3 2)) 5)
(test (let ((x (list 1 2))) (eq? x (append '() x))) #t) ;; ?? guile says #t also
(test (apply (lambda* args args) 1 2 3 '(4 5 6 (7))) '(1 2 3 4 5 6 (7))) ; from lisp bboard
(test (apply (list 1 2) '(0)) 1)

(test (apply (cons 1 2) '(0)) 1) ; ! (apply (cons 1 2) '(1)) is an error

(for-each
 (lambda (arg)
   (test (apply (lambda (x) x) (list arg)) arg))
 (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))

(test (apply cadadr (list '''4)) 4)
(test (apply string-ref "hi" '(0)) #\h)
(test (let ((x (string-copy "hi"))) (apply string-set! x 0 '(#\c)) x) "ci")
(test (apply apply (list + '(3  2))) 5)
(test (apply apply apply apply (list (list (list + '(3  2))))) 5)
(test (apply + 1 2 (list 3 4)) 10)
(test ((apply cdr '((1 2) (3 4)) ()) 0) '(3 4))
(test ((apply car '((1 2) (3 4)) ()) 1) 2)
(test ((apply cadr '((1 2) (3 4)) ()) 1) 4)
(test (apply append '()) '())
(test (apply apply append '()) '())
(test (apply apply apply append '(())) '())
(test (apply apply + ()) 0)
(test (apply apply * ()) 1)
(test (apply apply not not () ()) #f)
(test (apply apply apply eq? eq? eq? () () ()) #t)
(test (apply apply apply list list list () () ()) (list list list))
(test (apply apply vector cons (list '1 '2) ()) (vector cons 1 2))
(test (apply apply procedure-arity equal? () ()) '(2 0 #f))

(test (let ((x '(((1 2)) ((3 4))))) (catch #t (lambda () (apply apply apply apply x)) (lambda args 'error)) x) '(((1 2)) ((3 4))))
(test (let ((x '((1 2) (3 4)))) (catch #t (lambda () (apply apply apply apply x)) (lambda args 'error)) x) '((1 2) (3 4)))
(test (let ((x '((1 2) 3 4))) (catch #t (lambda () (apply apply apply x)) (lambda args 'error)) x) '((1 2) 3 4))
(test (let ((x '((1 2) (3 4)))) (catch #t (lambda () (apply apply apply not x)) (lambda args 'error)) x) '((1 2) (3 4)))

(test (eq? (apply apply apply values '(())) #<unspecified>) #t)
(test (eqv? (apply apply apply values '(())) #<unspecified>) #t)
(test (equal? (apply apply apply values '(())) #<unspecified>) #t)

(test (apply apply apply + '(((1)))) 1)
(test (apply apply map + '(((1)))) '(1))
(test (apply apply map quote '(((1)))) '(1))
(test (apply apply map values '(((1)) ((2)))) '((1) 2))
(test (apply apply map append '(((1)) ((2)))) '((1 . 2)))
(test (apply apply apply quote '(((1)))) 1)
(test (apply map cdr '(((1 2) (3 4)))) '((2) (4)))
(test (apply apply + '((1 2))) 3)
(test (apply apply cons '(((1 2) (3 4)))) '((1 2) 3 4))
(test (apply apply append '(((1 2) (3 4)))) '(1 2 3 4))
(test (apply map + '((1 2) (3 4))) '(4 6))
(test (apply map reverse '(((1 2) (3 4)))) '((2 1) (4 3)))
(test (apply apply map cons '(((1 2) (3 4)))) '((1 . 3) (2 . 4)))
(test (apply apply map list-tail '(((1 2) (3 4))) '(((1)))) '(((3 4))))
(test (apply apply map reverse '((1 2) (3 4)) '(())) '((2 1) (4 3)))
(test (apply apply map values '(((1)) ((2))) '(((1 2) (3 4)))) '(((1)) 1 3 ((2)) 2 4))
(test (apply apply map append '(((1 2) (3 4))) '(((1)) ((2)))) '(((1 2) (3 4) 1 . 2)))
(test (apply apply map append '(()) '(((1)) ((2)))) '((1 . 2)))
(test (apply apply map cdr '(((1 2) (3 4))) '()) '((2) (4)))
(test (apply apply apply list-tail '((1 2) (3 4)) '(((1)))) '((3 4)))
(test (apply apply apply reverse '(((1 2) (3 4))) '(())) '((3 4) (1 2)))
(test (apply apply apply values '(1) '(())) 1)
(test (apply apply apply values '(1) '((()))) '(1))
(test (apply apply apply values '((1)) '()) 1)
(test (apply apply apply values '((1)) '(())) '(1))
(test (apply apply reverse '(((1 2) (3 4))) '()) '((3 4) (1 2)))
(test (apply apply append '() '(((1 2) (3 4)))) '(1 2 3 4))
(test (apply apply length '(()) '()) 0)
(test (apply apply let '() '((1))) 1)
(test (apply apply apply apply + '((()))) 0)
(test (apply apply apply map reverse '((1 2) (3 4)) '((()))) '((2 1) (4 3)))
(test (apply apply apply map values '(((1 2) (3 4))) '()) '(1 3 2 4))
(test (apply apply apply apply + '(1) '((()))) 1)

(test (apply apply apply append (reverse '(((1)) ((2))))) '((2) . 1))
(test (apply apply map append (reverse '(((1)) ((2))))) '((2 . 1)))
(test (apply (apply apply lambda (quote '(1)))) 1)
(test (apply quote (map reverse (reverse '((1 2))))) '(2 1))
(test (map quote (apply map + '((1 2) (3 4)))) '(4 6))
(test (map car (apply map quote '(((1 2) (3 4))))) '(1 3))
(test (apply length (apply map append '(((1)) ((2))) '((1)))) -1)
(test (apply append (apply map list-tail '(((1 2) (3 4))) '((1)))) '((3 4)))
(test (apply append (apply map values '(((1)) ((2))) '(((1 2) (3 4))))) '((1) 1 2 (2) 3 4))
(test (apply append (apply map values '((1 2) (3 4)) '(((1 2) (3 4))))) '(1 2 1 2 3 4 3 4))
(test (apply append '((1) () (2 3 4) (5 6) ())) '(1 2 3 4 5 6))
(test (apply append '((1) () (2 3 4) (5 6) 7)) '(1 2 3 4 5 6 . 7))

(test (apply +) 0)
(test (apply + #f) 'error)
(test (apply #f '(2 3)) 'error)
(test (apply make-vector '(1 2 3)) 'error)
(test (apply + 1) 'error)
(test (apply) 'error)
(test (apply 1) 'error)
(test (apply . 1) 'error)
(test (apply car ''foo) 'error)
(test (apply + '(1 . 2)) 'error)
(test (apply + '(1 2 . 3)) 'error)
(test (apply '() '()) 'error)
(test (apply list '(1 . 2) '()) '((1 . 2)))
(test (apply (lambda (x) x) _ht_) 'error)
(test (apply + '#(1 2 3)) 'error)
(test (apply (lambda (a b) (+ a b)) '(1 . 2)) 'error)
(test (apply (lambda args (apply + args)) 1 2 3) 'error)
(test (apply (lambda args (apply + args)) 1 2 #f) 'error)
(test (apply (lambda args (apply list args)) 1 2 #f) 'error)
(test (apply (lambda args (apply + args)) 1 2 ()) 3)
(test (apply (lambda args (apply list args)) 1 2 ()) '(1 2))
(test (apply (lambda args (apply list args)) 1 '(2)) '(1 2))
(test (apply (lambda args (apply list args)) 1 '2) 'error)
(test (apply (lambda args (apply list args)) 1 'abs) 'error)
(test (apply (lambda args (apply list args)) 1 ''2) '(1 quote 2))
(test (apply (lambda args (apply list args)) () ()) '(()))
(test (apply (lambda args (apply list args)) () (cons 1 2)) 'error)
(test (apply (lambda args (apply list args)) (cons 1 2)) 'error)

(test (apply "hi" '(1 2)) 'error)
(test ("hi" 1 2) 'error)
(test (apply '(1 2) '(1 2)) 'error)
(test ((list 1 2 3) 1 2) 'error)

(test (apply "hi" '(1)) #\i)
(test ("hi" 1) #\i)
(test (apply '(1 2) '(1)) 2)
(test ((list 1 2 3) 1) 2)

(for-each
 (lambda (arg)
   (test (apply arg '(1)) 'error)
   (test (apply abs arg) 'error))
 (list -1 #\a 1 'a-symbol 3.14 3/4 1.0+1.0i #t)) 

(test (apply "hi" '(1)) #\i)
(test (apply '(1 2 3) '(1)) 2)
(test (apply #(1 2 3) '(2)) 3)
(test (apply #2D((1 2) (3 4)) 0 0 ()) 1)
(test (apply '((1 2) (3 4)) 1 0 ()) 3)
(test (let ((ht (make-hash-table))) (set! (ht "hi") 32) (apply ht '("hi"))) 32)

(test (let ((x (list 1 2))) (set-cdr! x x) (apply + x)) 'error)
(test (apply + '(1 2 . 3)) 'error)
(test (apply + '(1 2) (list 3 4)) 'error)
(test (let () (define (mrec a b) (if (<= b 0) (list a) (apply mrec (list a) (list (- b 1))))) (mrec (list 1 2) 5)) '(((((((1 2))))))))

(let ((lst (list 1 2 3)))
   (set! (cdr (cddr lst)) lst)
   (test (apply + lst) 'error))

(test (let ((lst '(1 2 3))) (let ((lst1 (apply list lst))) (set! (car lst1) 21) lst)) '(1 2 3))
(test (let ((lst '(1 2))) (let ((lst1 (apply cons lst))) (set! (car lst1) 21) lst)) '(1 2))
(test (let* ((x '(1 2 3)) (y (apply list x))) (eq? x y)) #f) ; this was #t until 26-Sep-11

(test (apply values (values (cons 1 ()))) 1)
(test (+ (apply values (values (list 1 2)))) 3)
(test (port-filename) (apply port-filename (list)))
(num-test (apply atan (#(1 #\a (3)) (max (values 1 2)))) 1.2490457723983)
(test (apply #2D((1 2) (3 4)) (list (floor (acosh 1)))) #(1 2)) 
(test ((apply values (list + 1 2)) 3) 6)
(num-test (* 0-2i (acosh (asin 0.0))) pi)
(test (apply truncate (lognot (min 1)) (list)) -2)
(num-test (apply /(list 11 11)) 1)

(test (apply dynamic-wind (list (lambda () #f) (lambda () 1) (lambda () #f))) 1)
(test (apply call-with-exit (list (lambda (exit) 1))) 1)
(test (apply call-with-exit (list (lambda (exit) (exit 1) 32))) 1)
(test (apply catch (list #t (lambda () 1) (lambda args 'error))) 1)
(test (apply eval '((+ 1 2))) 3)
(test (apply eval '()) 'error) ; (eval) is an error -- should it be? (eval ()) is () so perhaps (following values), (eval) -> #<unspecified>?
(test (apply eval '(())) '())
(test (apply eval-string '("(+ 1 2)")) 3) 
(test (let () (apply begin '((define x 1) (define y x) (+ x y)))) 2)
(test (apply begin '()) (begin))
(test (apply if '(#f 1 2)) 2)
(test (let ((x 1)) (apply set! '(x 3)) x) 3)
(test (let ((x 3)) (apply set! (list (values 'x 32))) x) 32)
(test (let ((x 1)) (apply cond '(((= x 2) 3) ((= x 1) 32)))) 32)
(test (apply and '((= 1 1) (> 2 3))) #f)
(test (apply and '()) (and))
(test (apply or '((= 1 1) (> 2 3))) #t)
(test (apply or '()) (or))
(test (let () (apply define '(x 32)) x) 32)
(test (let () (apply define* '((hi (a 1) (b 2)) (+ a b))) (hi 32)) 34)
(test ((apply lambda '((n) (+ n 1))) 2) 3)
(test ((apply lambda* '(((n 1)) (+ n 1)))) 2)
(test (apply let '(((x 1)) (+ x 2))) 3)
(test (apply let* '(((x 1) (y (* 2 x))) (+ x y))) 3)
(test (equal? (apply let* '((a 2) (b (+ a 3))) '(list + a b) ()) (list + 2 5)) #t)
(test (apply let 'func '((i 1) (j 2)) '((+ i j (if (> i 0) (func (- i 1) j) 0)))) 5)
(test (let () (apply define-macro `((hiho a) `(+ ,a 1))) (hiho 2)) 3)
(test (let () (apply defmacro `(hiho (a) `(+ ,a 1))) (hiho 2)) 3)
(test (let () (apply defmacro* `(hiho ((a 2)) `(+ ,a 1))) (hiho)) 3)
(test (let () (apply define-macro* `((hiho (a 2)) `(+ ,a 1))) (hiho)) 3)
(test (apply do '(((i 0 (+ i 1))) ((= i 3) i))) 3)
(test (apply case '(1 ((2 3) 4) ((1 5) 32))) 32)
(test (+ (apply values '(1 2 3))) 6)
(test (apply quote '(1)) 1)
(test (apply quote '()) 'error) ; (quote) is an error
(test (let () (apply letrec '(() (define x 9) x))) 9)
(test ((lambda (n) (apply n '(((x 1)) (+ x 2)))) let) 3)
(test ((apply lambda (list (apply let (list (list) (quote (list (apply case '(0 ((0 1) 'n))))))) (quasiquote (+ n 1)))) 2) 3)
(test (apply let '((x 1)) '((+ x 1))) 2)
(test ((apply make-procedure-with-setter (list (lambda (x) (+ x 1)) (lambda (x y) (+ x y)))) 23) 24)
(test (apply (apply make-procedure-with-setter (list (lambda (x) (+ x 1)) (lambda (x y) (+ x y)))) '(23)) 24)

(test (apply 'begin) 'error)
(test (apply and) #t)
(test (apply begin) '())
(test (apply if '((> 1 2) 3 4)) 4)
(test (apply or) #f)
(test (apply quote '(1)) 1)

(let ()
  (define (min-max arg . args)
    (if (null? args)
	(apply max arg)
	(min (apply max arg) 
	     (apply min-max args))))

  (test (min-max '(1 2 3) '(0 -1 4)) 3)
  (test (min-max '(1 2 3) '(0 -1 4) '(1 2)) 2))
