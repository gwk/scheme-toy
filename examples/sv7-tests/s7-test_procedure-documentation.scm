(test (string=? (let () (define (hi) "this is a string" 1) (procedure-documentation hi)) "this is a string") #t)
(test (string=? (let () (define (hi) "this is a string" 1) (help hi)) "this is a string") #t)
(test (string=? (let () (define (hi) "this is a string" 1) (#_help hi)) "this is a string") #t)
(test (string=? (let () (define (hi) "this is a string") (procedure-documentation hi)) "this is a string") #t)
(test (string=? (let () (define (hi) "this is a string") (hi)) "this is a string") #t)
(test (string=? (let () (define* (hi (a "a string")) a) (procedure-documentation hi)) "") #t)
(test (string=? (let () (define* (hi (a "a string")) "another string" a) (procedure-documentation hi)) "another string") #t)
(test (string=? (let () (define (hi a) "hi doc" (define (ho b) "ho doc" b) (ho a)) (procedure-documentation hi)) "hi doc") #t)
(test (set! (procedure-documentation abs) "X the unknown") 'error)
(test (let ((str (procedure-documentation abs))) (set! ((procedure-documentation abs) 1) #\x) (equal? str (procedure-documentation abs))) #t)
(test (let ((str (procedure-documentation abs))) (fill! (procedure-documentation abs) #\x) (equal? str (procedure-documentation abs))) #t)
(let ()
  (define-macro (amac a) "this is a string" `(+ ,a 1))
  (test (procedure-documentation amac) "this is a string"))
(let ()
  (define-macro* (amac (a 1)) "this is a string" `(+ ,a 1))
  (test (procedure-documentation amac) "this is a string"))
(let ()
  (define-bacro (amac a) "this is a string" `(+ ,a 1))
  (test (procedure-documentation amac) "this is a string"))
(let ()
  (define-bacro* (amac (a 1)) "this is a string" `(+ ,a 1))
  (test (procedure-documentation amac) "this is a string"))
(let ()
  (define-macro (amac a) `(+ ,a 1))
  (test (procedure-documentation amac) ""))
(let ()
  (define-bacro (amac a) ,a)
  (test (procedure-documentation amac) ""))

(test (string=? (procedure-documentation abs) "(abs x) returns the absolute value of the real number x") #t)
(test (string=? (help abs) "(abs x) returns the absolute value of the real number x") #t)
(test (string=? (#_help abs) "(abs x) returns the absolute value of the real number x") #t)
(test (string=? (procedure-documentation 'abs) "(abs x) returns the absolute value of the real number x") #t)
(test (let ((hi (lambda (x) "this is a test" (+ x 1)))) 
	(list (hi 1) (procedure-documentation hi)))
      (list 2 "this is a test"))
(test (procedure-documentation (lambda* (a b) "docs" a)) "docs")
(test (procedure-documentation (lambda* (a b) "" a)) "")
(test (procedure-documentation (lambda* (a b) a)) "")
(test (procedure-documentation (lambda* (a b) "" a)) "")
(test (procedure-documentation (call-with-exit (lambda (c) c))) "")
(test (procedure-documentation (call/cc (lambda (c) c))) "")
(test (procedure-documentation) 'error)
(test (procedure-documentation abs abs) 'error)

(if (not (provided? 'snd))
    (for-each
     (lambda (arg)
       (test (procedure-documentation arg) 'error)
       (test (help arg) #f))
     (list -1 #\a #f _ht_ 1 '#(1 2 3) 3.14 3/4 1.0+1.0i '() 'hi '#(()) (list 1 2 3) '(1 . 2) "hi" :hi)))

;; (test (procedure-with-setter? symbol-access) #t)
(test (procedure-documentation symbol-access) "(symbol-access sym) is a procedure that adds or removes controls on how a symbol accesses its current binding.")

(test (procedure-arity) 'error)
(test (procedure-arity abs abs) 'error)
(test (procedure-arity (call-with-exit (lambda (c) c))) '(0 0 #t))
(test (procedure-arity (call/cc (lambda (c) c))) '(0 0 #t))

(let ((p (make-procedure-with-setter (lambda (a) (+ a 1)) (lambda (a b) (+ a b)))))
  (test (object->string (procedure-source p)) "(lambda (a) (+ a 1))")
  (let ((p1 p)
	(p2 (make-procedure-with-setter (lambda (a) "pws doc" (+ a 1)) (lambda (a b) (+ a b)))))
    (test (equal? p p1) #t)
    (test (equal? p1 p2) #f)
    (test (procedure-documentation p2) "pws doc")
    (test (apply p2 '(2)) 3)))

(let ((func (eval '(lambda (a) "this is from eval" (+ a 1)))))
  (test (func 3) 4)
  (test (procedure-documentation func) "this is from eval"))
(test (let ((e (environment '(x . 3)))) 
	(let ((func (eval '(lambda (a) (+ a x)) e)))
	  (func 2))) 
      5)
