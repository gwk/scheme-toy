(let ((max-stack 0))
  (define (tc-1 a c) 
    (let ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (if (< b c) 
	  (tc-1 b c))))
  (tc-1 0 32)
  (if (> max-stack 10) (format #t "tc-1 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-1 a c) 
    (if (> (-s7-stack-size) max-stack)
	(set! max-stack (-s7-stack-size)))
    (if (< a c) 
	(tc-2 (+ a 1) c)))
  (define (tc-2 a c) 
    (if (> (-s7-stack-size) max-stack)
	(set! max-stack (-s7-stack-size)))
    (if (< a c) 
	(tc-1 (+ a 1) c)))
  (tc-1 0 32)
  (if (> max-stack 10) (format #t "tc-1-1 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-2 a c) 
    (let ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (if (= b c)
	  #f
	  (tc-2 b c))))
  (tc-2 0 32)
  (if (> max-stack 10) (format #t "tc-2 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-2 a c) 
    (let ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (if (< b c)
	  (tc-2 b c)
	  #f)))
  (tc-2 0 32)
  (if (> max-stack 10) (format #t "tc-2-1 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-3 a c) 
    (let ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (cond ((= b c) #f)
	    ((< b c)
	     (tc-3 b c)))))
  (tc-3 0 32)
  (if (> max-stack 10) (format #t "tc-3 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-4 a c) 
    (let ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (cond ((= b c) #f)
	    (else (tc-4 b c)))))
  (tc-4 0 32)
  (if (> max-stack 10) (format #t "tc-4 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-5 a c) 
    (let ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (case b
	((32) #f)
	(else (tc-5 b c)))))
  (tc-5 0 32)
  (if (> max-stack 10) (format #t "tc-5 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-6 a c) 
    (let ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (case b
	((17) #f)
	((0 1 2 3 4 5 6 7 8) (tc-6 b c))
	((9 10 11 12 13 14 15 16) (tc-6 b c)))))
  (tc-6 0 32)
  (if (> max-stack 10) (format #t "tc-6 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-7 a c) 
    (let ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (or (>= b c)
	  (tc-7 b c))))
  (tc-7 0 32)
  (if (> max-stack 10) (format #t "tc-7 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-8 a c) 
    (let ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (and (< b c)
	   (tc-8 b c))))
  (tc-8 0 32)
  (if (> max-stack 10) (format #t "tc-8 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-9 a c) 
    (let tc-9a ((b a))
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (if (< b c)
	  (tc-9a (+ b 1)))))
  (tc-9 0 32)
  (if (> max-stack 10) (format #t "tc-9 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-10 a c) 
    (let* ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (and (< b c)
	   (tc-10 b c))))
  (tc-10 0 32)
  (if (> max-stack 10) (format #t "tc-10 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-11 a c) 
    (letrec ((b (+ a 1))) 
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (and (< b c)
	   (tc-11 b c))))
  (tc-11 0 32)
  (if (> max-stack 10) (format #t "tc-11 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-12 a c) 
    (if (< a c)
	(begin
	  (if (> (-s7-stack-size) max-stack)
	      (set! max-stack (-s7-stack-size)))
	  (tc-12 (+ a 1) c))))
  (tc-12 0 32)
  (if (> max-stack 10) (format #t "tc-12 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-13 a c) 
    (if (> (-s7-stack-size) max-stack)
	(set! max-stack (-s7-stack-size)))
    (cond ((= a c) #f)
	  ((< a c)
	   (if (> a c) (display "oops"))
	   (tc-13 (+ a 1) c))))
  (tc-13 0 32)
  (if (> max-stack 10) (format #t "tc-13 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-14 a c) 
    (if (> (-s7-stack-size) max-stack)
	(set! max-stack (-s7-stack-size)))
    (cond ((>= a c) #f)
	  ((values (+ a 1) c) => tc-14)))
  (tc-14 0 32)
  (if (> max-stack 10) (format #t "tc-14 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-15 a c) 
    (if (> (-s7-stack-size) max-stack)
	(set! max-stack (-s7-stack-size)))
    (or (>= a c)
	(apply tc-15 (list (+ a 1) c))))
  (tc-15 0 32)
  (if (> max-stack 10) (format #t "tc-15 max: ~D~%" max-stack)))

(let ((max-stack 0))
  (define (tc-17 a c) 
    (if (> (-s7-stack-size) max-stack)
	(set! max-stack (-s7-stack-size)))
    (or (and (>= a c) a)
	(eval `(tc-17 (+ ,a 1) ,c))))
  (let ((val (tc-17 0 32)))
    (test (and (= val 32) (< max-stack 28)) #t)))

#|
(let ((max-stack 0))
  (define (tc-19 a c) 
    (if (> (-s7-stack-size) max-stack)
	(set! max-stack (-s7-stack-size)))
    (call/cc
     (lambda (r)
       (if (>= a c) (r a))
       (tc-19 (+ a 1) c))))
  (let ((val (tc-19 0 16)))
    (test (and (= val 16) (< max-stack 8)) #t)))
|#

(let ((max-stack 0))
  (define (tc-21 a) 
    (if (< a 32)
	(do ((i (- a 1) (+ i 1)))
	    ((= i a) 
	     (tc-21 (+ a 1)))
	  (if (> (-s7-stack-size) max-stack)
	      (set! max-stack (-s7-stack-size))))
	a))
  (let ((val (tc-21 0)))
    (if (> max-stack 10) (format #t "tc-21 max: ~D~%" max-stack))
    (if (not (= val 32)) (format #t "tc-21 returned: ~A~%" val))))

(let ((max-stack 0))
  (define (tc-env a c) 
    (with-environment (augment-environment (current-environment) (cons 'b (+ a 1)))
      (if (> (-s7-stack-size) max-stack)
	  (set! max-stack (-s7-stack-size)))
      (if (< b c) 
	  (tc-env b c))))
  (tc-env 0 32)
  (if (> max-stack 10) (format #t "tc-env max: ~D~%" max-stack)))


;;; make sure for-each and map aren't messed up

(let ((max-stack 0))
  (for-each
   (lambda (a)
     (if (> (-s7-stack-size) max-stack)
	 (set! max-stack (-s7-stack-size)))
     (if (not (= a 1))
	 (error 'wrong-type-arg ";for-each arg is ~A" a)))
   (make-list 100 1))
  (test (< max-stack 20) #t)) ; 10 is not snd-test (and below)

(let ((max-stack 0))
  (map
   (lambda (a)
     (if (> (-s7-stack-size) max-stack)
	 (set! max-stack (-s7-stack-size)))
     (if (not (= a 1))
	 (error 'wrong-type-arg ";map arg is ~A" a)))
   (make-list 100 1))
  (test (< max-stack 20) #t))


;;; the next 3 are not tail-recursive
;;;
;;;   eval-string pushes stack markers to catch multiple statements
;;;   OP_DEACTIVATE_GOTO in call-with-exit
;;;   OP_DYNAMIC_WIND in the dynamic-wind case

(let ((max-stack 0))
  (define (tc-17 a c) 
    (if (> (-s7-stack-size) max-stack)
	(set! max-stack (-s7-stack-size)))
    (or (and (>= a c) a)
	(eval-string (format #f "(tc-17 (+ ~A 1) ~A)" a c))))
  (let ((val (tc-17 0 32)))
    (test (and (= val 32) (< max-stack 28)) #f)))

(let ((max-stack 0))
  (define (tc-16 a c) 
    (if (> (-s7-stack-size) max-stack)
	(set! max-stack (-s7-stack-size)))
    (call-with-exit
     (lambda (r)
       (if (>= a c) (r a))
       (tc-16 (+ a 1) c))))
  (let ((val (tc-16 0 32)))
    (test (and (= val 32) (> max-stack 28)) #t)))

(let ((max-stack 0))
  (define (tc-18 a c) 
    (dynamic-wind
	(lambda ()
	  (if (> (-s7-stack-size) max-stack)
	      (set! max-stack (-s7-stack-size))))
	(lambda ()
	  (or (and (>= a c) a)
	      (tc-18 (+ a 1) c)))
	(lambda ()
	  #f)))
  (let ((val (tc-18 0 32)))
    (test (and (= val 32) (> max-stack 28)) #t)))

(test (let ((f #f)) (let tr ((i 10)) (if (= i 3) (set! f (lambda () i))) (if (> i 0) (tr (- i 1)))) (f)) 3)
(test (let ((f '())) (let tr ((i 4)) (set! f (cons i f)) (if (> i 0) (tr (- i 1)))) f) '(0 1 2 3 4))




;;; -------- miscellaneous amusements

(test ((number->string -1) 0) #\-)
(test ((reverse '(1 2)) 0) 2)
(test ((append begin) list) list)
(test ((begin object->string) car) "car")
(test ((and abs) -1) 1)
(test (((values begin) object->string) car) "car")
(test (((values (begin begin)) object->string) car) "car")
(test ((((values append) begin) object->string) car) "car")
(test ((((((values and) or) append) begin) object->string) car) "car")
(test (((((((values values) and) or) append) begin) object->string) car) "car")
(test (((append s7-version)) 0) #\s)
(test ((values (lambda hi #()))) #())
(test (((((lambda () (lambda () (lambda () (lambda () 1)))))))) 1)
(test (((cond (cond => cond)) (cond)) ((cond (#t #t)))) #t)
(test ((object->string #f) (ceiling 3/4)) #\f)
;now an error (test (((lambda* ((a :optional) (b :key)) (apply lambda* (list (list a b 'c) 'c)))) 1) 1) ; (lambda* (:optional :key c) c)
(test (procedure? ((((((lambda* ((x (lambda () x))) x))))))) #t)
(test (procedure? ((((((letrec ((x (lambda () x))) x))))))) #t)
(test (procedure? ((((((letrec ((x (lambda () y)) (y (lambda () x))) x))))))) #t)
(test (procedure? ((((((let x () x))))))) #t)
(test (procedure? ((((((lambda (x) (set! x (lambda () x))) (lambda () x))))))) #t)
(test (procedure? ````,,,,((((let x () x))))) #t)
(test ((do ((i 0 (+ i 1))) ((= i 1) (lambda () 3)))) 3)
(test (dynamic-wind s7-version s7-version s7-version) (s7-version))
(num-test ((list .(log 0)) 1) 0)
(num-test (((cons .(log 0)) 0) 1) 0.0)

(test (+ (+) (*)) 1)
(test (modulo (lcm) (gcd)) 1)
(test (max (+) (*)) 1)
(test (min (gcd) (lcm)) 0)
(test (symbol->value (gensym) (global-environment)) #<undefined>)
(test (string-ref (s7-version) (*)) #\7)
(test (string>=? (string-append) (string)) #t)
(test (substring (string-append) (+)) "")
(test (ash (*) (+)) 1)
(test (> (*) (+)) #t)
(test ((or #f list)) ())
(test ((or #f lcm)) 1)
(test ((or begin symbol?)) ())
(test ((or begin make-polar)) ())
(test ((and #t begin)) ())
(test (begin) ())
(test ((or #f lcm) 2 3) 6)
(test ((or and) #f #t) #f)
(test ((and or) #f #t) #t)
(test (or (or) (and)) #t)
(test ((car '((1 2) (3 4))) 0) 1)
(test ((or apply) lcm) 1)
(test (- ((or *))) -1)
(test ((car (list lcm))) 1)
(test ((or (cond (lcm)))) 1)
(test ((cond (asin floor *))) 1)
(test (logior (#(1 #\a (3)) 0) (truncate 1.5)) 1)
(test (real? (*)) #t)
(test (- (lcm)) -1)
(test (* (*)) 1)
(test (+ (+) (+ (+)) (+ (+ (+)))) 0)
(test (+(*(+))(*)(+(+)(+)(*))) 2)
(num-test (+(-(*).(+1))(*(+).(-1))(*(+).(-10))(*(-(+)0)1.)(-(+)(*).01)(*(-(+)).01)(-(+)(*)1.0)(-(*(+))1.0)(*(-(+))1.0)(-(+(*)1).0))-2.01)
(num-test (+(-(*).(+1.0))(*(+).(-1.0))(-(+)1.(*)0.)(-(*(+)0.)1.)(-(+(*)1.)0.)(+(-(*)0.)1.))1.0)
;; float comparison so can't use direct '=' here

(test (nan? (asinh (cos (real-part (log 0.0))))) #t)
(num-test(cos(sin(log(tan(*))))) 0.90951841537482)
(num-test (asinh (- 9223372036854775807)) -44.361419555836)
(num-test (imag-part (asin -9223372036854775808)) 44.361419555836)
(if (provided? 'dfls-exponents)
    (begin
      ;; proof that these exponents should be disallowed
      (num-test (string->number "1l1") 10.0)
      (num-test (string->number "1l1+1l1i") 10+10i)
      (num-test (string->number "1l11+11l1i") 100000000000+110i)
      (num-test (string->number "#d1d1") 10.0)
      (num-test (string->number "#d0001d0001") 10.0)))
(test (#|#<|# = #|#f#|# #o#e0 #|#>|# #e#o0 #|#t#|#) #t)
(num-test (apply * (map (lambda (r) (sin (* pi (/ r 130)))) (list 1 67 69 73 81 97))) (/ 1.0 64))
(num-test (max 0(+)(-(*))1) 1)

(test ((call-with-exit object->string) 0) #\#) ; #<goto>
(test ((begin begin) 1) 1)
(test ((values begin) 1) 1)
(test ((provide or) 3/4) 'error)
(test (string? cond) #f)
(test (list? or) #f)
(test (pair? define) #f)
(test (number? lambda*) #f)
(test ((s7-version) (rationalize 0)) #\s)
(test (cond (((values '(1 2) '(3 4)) 0 0))) 'error)
(test (cond (((#2d((1 2) (3 4)) 0) 0) 32)) 32)
(test (cond ((apply < '(1 2)))) #t)
(test (dynamic-wind lcm gcd *) 0) ; was 'error but Peter Bex tells me this is normal
(test (case 0 ((> 0 1) 32)) 32)
(test (char-downcase (char-downcase #\newline)) #\newline)
(test (and (and) (and (and)) (and (and (and (or))))) #f)
(test ((values begin #\a 1)) 1)
(test ((values and 1 3)) 3)
(test ((((lambda () begin)) (values begin 1))) 1)
(test (+ (((lambda* () values)) 1 2 3)) 6)
(test ((values ('((1 2) (3 4)) 1) (abs -1))) 4)
(test ((apply lambda '() '(() ()))) '())
(test ((lambda* ((symbol "#(1 #\\a (3))")) #t)) #t)
(test (apply if ('((1 2) (3 4)) 1)) 4)

(test (((lambda #\newline gcd))) 'error)
(test (symbol? (let () (define (hi) (+ 1 2)))) #t)
(test (symbol? (begin (define (x y) y) (x (define (x y) y)))) #t)
(test (symbol? (do () ((define (x) 1) (define (y) 2)))) #t)
(test (cond (0 (define (x) 3) (x))) 3)
(test (let ((x (lambda () 3))) (if (define (x) 4) (x) 0)) 4)
(test (and (define (x) 4) (+ (x) 1)) 5)
(test (do ((x (lambda () 3) (lambda () 4))) ((= (x) 4) (define (x) 5) (x))) 5)
(test (begin (if (define (x) 3) (define (x) 4) (define (x) 5)) (x)) 4)

(test (let ((1,1 3) (1'1 4) (1|1 5) (1#1 6) (1\1 7) (1?1 8)) (+ 1,1 1'1 1|1 1#1 1\1 1?1)) 33)
(test (let ((,a 3)) ,a) 'error)
(test (let ((@a 3)) @a) 3)
(test (let (("a" 3)) "a") 'error)
(test (let ((`a 3)) `a) 'error)
(test (let (('a 3)) 'a) 'error)
(test (let ((a`!@#$%^&*~.,<>?/'{}[]\|+=_-a 3)) a`!@#$%^&*~.,<>?/'{}[]\|+=_-a) 3)

(test (set! ((quote (1 2)) 0) #t) #t)
(test (set! (((lambda () (list 1 2))) 0) 2) 2)
(test (let ((x (list 1 2))) (set! (((lambda () x)) 0) 3) x) '(3 2))
(test (let ((x (list 1 2))) (set! (((vector x) 0) 1) 32) x) '(1 32))
(test (let ((x (list 1 2))) (set! ((((lambda () (vector x))) 0) 0) 3) x) '(3 2))
(test (let ((x (list 1 2))) (set! ((((lambda () (list x))) 0) 0) 3) x) '(3 2))
(test (let ((x (list 1 2))) (set! ((set! x (list 4 3)) 0) 32) x) '(32 3))
(test (let ((x (list 1 2))) (list-set! (set! x (list 4 3)) 0 32) x) '(32 3))
(test (let ((x (list 1 2))) (set! ((list-set! x 0 (list 4 3)) 0) 32) x) '((32 3) 2))
(test (let ((x (list 1 2))) (list-set! (list-set! x 0 (list 4 3)) 0 32) x) '((32 3) 2))
(test (set! (('((0 2) (3 4)) 0) 0) 0) 0)
(test (set! ((map abs '(1 2)) 1) 0) 0)
(test (let () (set! ((define x #(1 2)) 0) 12) x) #(12 2))
(test (let ((x (list 1 2))) (set! ((call-with-exit (lambda (k) (k x))) 0) 12) x) '(12 2))
(test (let ((x #2d((1 2) (3 4)))) (set! (((values x) 0) 1) 12) x) #2D((1 12) (3 4)))
(test (let ((x 0)) (set! ((make-procedure-with-setter (lambda () x) (lambda (y) (set! x y)))) 12) x) 12)
(test (let ((x 0) (str "hiho")) (string-set! (let () (set! x 32) str) 0 #\x) (list x str)) '(32 "xiho"))
(test (let ((x "hi") (y "ho")) (set! ((set! x y) 0) #\x) (list x y)) '("xo" "xo"))
(test (let ((x "hi") (y "ho")) (set! x y) (set! (y 0) #\x) (list x y)) '("xo" "xo")) ; Guile gets the same result
(test (let ((x (lambda (a) (a z 1) z))) (x define)) 1) ; !
(test (let ((x (lambda (a) (a z (lambda (b) (+ b 1))) (z 2)))) (x define)) 3)
(test (let ((x (lambda (a b c) (apply a (list b c))))) (x let '() 3)) 3)
(test (let ((x (lambda (a b c) (apply a (list b c))))) (x let '((y 2)) '(+ y 1))) 3)

(let () (test ((values let '((x 1))) '(+ x 1)) 2)) ; !
(let () (test ((values begin '(define x 32)) '(+ x 1)) 33))
(let () (test (((values lambda '(x) '(+ x 1))) 32) 33))
(let () (test (let ((arg '(x)) (body '(+ x 1))) (((values lambda arg body)) 32)) 33))
(let () (test (let ((arg '(x)) (body '(+ x 1))) ((apply lambda arg (list body)) 32)) 33))
(let () (test (let ((x 12)) ((apply lambda '(x) (list (list '+ 1 x 'x))) 3)) 16))
(let () (test (let* ((x 3) (arg '(x)) (body `((+ ,x x 1)))) ((apply lambda arg body) 12)) 16))

(let ()
  (define (bcase start end func)
    (let ((body '()))
      (do ((i start (+ i 1)))
	  ((= i end))
	  (set! body (cons `((,i) ,(func i)) body)))
      (lambda (i) (apply case i body))))
  (test ((bcase 0 3 abs) 1) 1))






;;; ------ CLisms ------------------------------------------------------------------------


(let ()

      ;; **********************************************************************
      ;; 
      ;; Copyright (C) 2002 Heinrich Taube (taube@uiuc.edu) 
      ;; 
      ;; This program is free software; you can redistribute it and/or
      ;; modify it under the terms of the GNU General Public License
      ;; as published by the Free Software Foundation; either version 2
      ;; of the License, or (at your option) any later version.
      ;; 
      ;; This program is distributed in the hope that it will be useful,
      ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
      ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      ;; GNU General Public License for more details.
      ;; 
      ;; **********************************************************************
      
      ;; $Name:  $
      ;; $Revision: 1.6 $
      ;; $Date: 2005/11/17 13:29:37 $
      
      ;;
      ;; Implementation of the CLTL2 loop macro. The following 
      ;; non Rev 5 definitions need to be in effect before the file
      ;; is loaded:
      ;;
      ;; (define-macro (name . args) ...)
      ;; (error string)
      ;; (gensym string)
      ;;
      
      (defmacro when (test . forms)
	`(if ,test (begin ,@forms)))
	  
      (define-macro (loop . args)
	(let ()
	  
	  (define-macro (push val sym)
	    `(begin (set! ,sym (cons ,val ,sym)) ,sym))
	  
	  (define-macro (pop sym)
	    (let ((v (gensym "v")))
	      `(let ((,v (car ,sym)))
		 (set! ,sym (cdr ,sym))
		 ,v)))
	  
	  ;; this next one is a no-op but i need it as a marker for my cltl2
	  ;; translator.
	  
	  (define-macro (function sym) sym)     
	  
	  ;; getters and setters for the loop-clause "struct"
	  
	  (define (loop-operator c)          (vector-ref  c 0))
	  (define (loop-operator-set! c x)   (vector-set! c 0 x))
	  (define (loop-bindings c)          (vector-ref  c 1))
	  (define (loop-bindings-set! c x)   (vector-set! c 1 x))
	  (define (loop-collectors c)        (vector-ref  c 2))
	  (define (loop-collectors-set! c x) (vector-set! c 2 x))
	  (define (loop-initially c)         (vector-ref  c 3))
	  (define (loop-initially-set! c x)  (vector-set! c 3 x))
	  (define (loop-end-tests c)         (vector-ref  c 4))
	  (define (loop-end-tests-set! c x)  (vector-set! c 4 x))
	  (define (loop-looping c)           (vector-ref  c 5))
	  (define (loop-looping-set! c x)    (vector-set! c 5 x))
	  (define (loop-stepping c)          (vector-ref  c 6))
	  (define (loop-stepping-set! c x)   (vector-set! c 6 x))
	  (define (loop-finally c)           (vector-ref  c 7))
	  (define (loop-finally-set! c x)    (vector-set! c 7 x))
	  (define (loop-returning c)         (vector-ref  c 8))
	  (define (loop-returning-set! c x)  (vector-set! c 8 x))
	  
	  (define (make-loop-clause . args)
	    (let ((v (vector #f '() '() '() '() '() '() '() '())))
	      (if (null? args) v
		  (do ((a args (cddr a)))
		      ((null? a) v)
		    (case (car a)
		      ((operator) (loop-operator-set! v (cadr a)))
		      ((bindings) (loop-bindings-set! v (cadr a)))
		      ((collectors) (loop-collectors-set! v (cadr a)))
		      ((initially) (loop-initially-set! v (cadr a)))
		      ((end-tests) (loop-end-tests-set! v (cadr a)))
		      ((looping) (loop-looping-set! v (cadr a)))
		      ((stepping) (loop-stepping-set! v (cadr a)))
		      ((finally) (loop-finally-set! v (cadr a)))
		      ((returning) (loop-returning-set! v (cadr a))))))))
	  
	  (define (gather-clauses caller clauses)
	    ;; nconc all clausal expressions into one structure
	    (let ((gather-clause 
		   (lambda (clauses accessor)
		     ;; append data from clauses
		     (do ((l '()))
			 ((null? clauses) l)
		       (set! l (append l (accessor (car clauses))))
		       (set! clauses (cdr clauses))))))
	      (make-loop-clause 'operator caller
				'bindings
				(gather-clause clauses 
					       (function loop-bindings))
				'collectors
				(gather-clause clauses 
					       (function loop-collectors))
				'initially 
				(gather-clause clauses 
					       (function loop-initially))
				'end-tests 
				(gather-clause clauses 
					       (function loop-end-tests))
				'looping 
				(gather-clause clauses 
					       (function loop-looping))
				'stepping 
				(gather-clause clauses 
					       (function loop-stepping))
				'finally 
				(gather-clause clauses
					       (function loop-finally))
				'returning 
				(gather-clause clauses
					       (function loop-returning)))))
	  
	  (define (loop-op? x ops)
	    (assoc x ops))
	  
	  (define (loop-variable? x)
	    (symbol? x))
	  
	  (define (make-binding var val)
	    (list var val))
	  
	  (define (loop-error ops forms . args)
	    ;; all error messages include error context.
	    (let ((loop-context
		   (lambda (lst ops)
		     ;; return tail of expr up to next op in cdr of tail
		     (do ((h lst)
			  (l '()))
			 ((or (null? lst)
			      ;; ignore op if in front.
			      (and (not (eq? h lst))
				   (loop-op? (car lst) ops)))
			  (reverse l))
		       (set! l (cons (car lst) l))
		       (set! lst (cdr lst))))))
	      (let ((forms (loop-context forms ops)))
		(newline)
		(display "LOOP ERROR: ")
		(do ((tail args (cdr tail)))
		    ((null? tail) #f)
		  (display (car tail)))
		(newline)
		(display "clause context: ")
		(if (null? forms) 
		    (display "()")
		    (do ((tail forms (cdr tail)))
			((null? tail) #f)
		      (if (eq? tail forms) (display "'"))
		      (display (car tail))
		      (display (if (null? (cdr tail)) "'" " "))))
		(newline)
		(error "illegal loop syntax"))))
	  
	  (define (parse-for forms clauses ops)
	    ;; forms is (FOR ...)
	    (let ((op (loop-op? (car forms) ops)))
	      (if (null? (cdr forms))
		  (loop-error ops forms "Variable expected but source code ran out." )
		  (let ((var (cadr forms)))
		    (if (loop-variable? var)
			(if (null? (cddr forms))
			    (loop-error ops forms
					"'for' clause expected but source code ran out.")
			    ;; find the iteration path in the op
			    (let ((path (assoc (caddr forms) (cdddr op))))
			      ;; path is (<pathop> <parser>)
			      (if (not path)
				  (loop-error ops forms "'" (caddr forms) "'"
					      " is not valid with 'for'.")
				  ( (cadr path) forms clauses ops))))
			(loop-error ops forms "Found '" (cadr forms)
				    "' where a variable expected."))))))
	  
	  (define (parse-numerical-for forms clauses ops)
	    ;; forms is (FOR <var> <OP> ...)
	    ;; where <OP> is guaranteed to be one of: FROM TO BELOW ABOVE DOWNTO
	    clauses
	    (let ((var (cadr forms))
		  (tail (cddr forms))
		  (bind '())
		  (from #f)
		  (head #f)
		  (last #f)
		  (stop #f)
		  (step #f)
		  (test #f)
		  (incr #f))
	      
	      (do ((next #f))
		  ((or (null? tail) (loop-op? (car tail) ops)))
		(set! next (pop tail))
		(if (null? tail)
		    (loop-error ops forms
				"Expected expression but source code ran out."))
		(case next
		  ((from downfrom)
		   (if head (loop-error ops forms "Found '" next "' when '"
					head "' in effect."))
		   (set! head next)
		   (set! from (pop tail)))
		  ((below)
		   (if last (loop-error ops forms "Found '" next "' when '"
					last "' in effect."))
		   (set! stop (pop tail))
		   (set! last next))
		  ((to)
		   (if last (loop-error ops forms "Found '" next "' when '"
					last "' in effect."))
		   (set! stop (pop tail) )
		   (set! last next))
		  ((above )
		   (if last (loop-error ops forms "Found '" next "' when '"
					last "' in effect."))
		   (set! stop (pop tail))
		   (set! last next))
		  ((downto )
		   (if last (loop-error ops forms "Found '" next "' when '"
					last "' in effect."))
		   (set! stop (pop tail))
		   (set! last next))
		  ((by)
		   (if step (loop-error ops forms "Found duplicate 'by'."))
		   (set! step (pop tail)))
		  (else
		   (loop-error ops forms 
			       "'" next "' is not valid with 'for'."))))
	      (if (not head)
		  (set! head 'from))
	      (if (or (eq? head 'downfrom)
		      (eq? last 'downto)
		      (eq? last 'above))
		  (begin
		    (set! incr '-)
		    (if (eq? last 'above)
			(set! test '<=)
			(set! test '<)))   ; allow to for downto
		  (begin
		    (set! incr '+)
		    (if (eq? last 'below)
			(set! test '>=)
			(set! test '>))))
	      
	      ;; add binding for initial value
	      (push (make-binding var (or from 0)) bind)
	      ;; add binding for non-constant stepping values.
	      (if (not step)
		  (set! step 1)
		  (if (not (number? step))
		      (let ((var (gensym "v")))
			(push (make-binding var step) bind)
			(set! step var))))
	      (set! step `(set! ,var (,incr ,var ,step)))
	      (if stop
		  (let ((end (gensym "v")))
		    (push (make-binding end stop) bind)
		    (set! stop (list test var end))))
	      (values (make-loop-clause 'operator 'for
					'bindings (reverse bind)
					'stepping (list step)
					'end-tests (if (not stop)
						       '() (list stop)))
		      tail)))
	  
	  (define (parse-repeat forms clauses ops)
	    ;; forms is (REPEAT <FORM> ...)
	    (if (null? (cdr forms))
		(loop-error ops forms 
			    "'repeat' clause expected but source code ran out." )
		(call-with-values (lambda ()
				    (parse-numerical-for 
				     (list 'for (gensym "v") 'below (cadr forms))
				     clauses ops))
		  (lambda (clause ignore)
		    ignore
		    (values clause (cddr forms))))))
	  
	  (define (parse-sequence-iteration forms clauses ops)
	    ;; tail is (FOR <var> <OP> ...)
	    ;; <OP> is guaranteed to be one of: IN ON ACROSS
	    clauses
	    (let ((head forms)
		  (var (cadr forms))
		  (seq (gensym "v"))
		  (tail (cddr forms))
		  (bind '())
		  (data #f) 
		  (init '()) 
		  (loop '()) 
		  (incr #f)
		  (stop '()) 
		  (step '()) 
		  (type #f))
	      
	      (do ((next #f))
		  ((or (null? tail) (loop-op? (car tail) ops)))
		(set! next (pop tail))
		(when (null? tail)
		      (loop-error ops head
				  "Expression expected but source code ran out." ))
		(case next
		  ((in on across)
		   (if type (loop-error ops head 
					"Extraneous '" next "' when '"
					type "' in effect."))
		   (set! type next)
		   (set! data (pop tail)))
		  ((by )
		   (if incr 
		       (loop-error ops head "Duplicate 'by'." )
		       (if (eq? type 'across)
			   (loop-error ops head "'by' is invalid with 'across'." )
			   (set! incr (pop tail)))))
		  (else
		   (loop-error ops head "'" next "' is not valid with 'for'."))))
					; add bindings for stepping var and source
	      (push (make-binding var #f) bind)
	      (push (make-binding seq data) bind)
	      (if (eq? type 'across)
		  (let ((pos (gensym "v"))
			(mx (gensym "v")))
		    (push (make-binding pos 0) bind)
		    (push (make-binding mx #f) bind)
		    (push `(set! ,mx (vector-length ,seq)) init)
		    (push `(set! ,pos (+ 1 ,pos)) step)
		    (push `(set! ,var (vector-ref ,seq ,pos)) loop)
		    (push `(>= ,pos ,mx) stop))
		  (begin
		    (if incr
			(if (and (list? incr) (eq? (car incr) 'quote))
			    (push `(set! ,seq (,(cadr incr) ,seq)) step)
			    (push `(set! ,seq (,incr ,seq)) step))
			(push `(set! ,seq (cdr ,seq)) step))
		    (push (if (eq? type 'in)
			      `(set! ,var (car ,seq))
			      `(set! ,var ,seq))
			  loop)
		    (push `(null? ,seq) stop)))
	      
	      (values (make-loop-clause 'operator 'for
					'bindings (reverse bind)
					'end-tests stop
					'initially init
					'looping loop
					'stepping step)
		      tail)))
	  
	  (define (parse-general-iteration forms clauses ops)
	    ;; forms is (FOR <var> = ...)
	    clauses
	    (let ((head forms)
		  (var (cadr forms))
		  (tail (cddr forms))
		  (init #f)
		  (type #f)
		  (loop #f)
		  (step #f))
	      (do ((next #f))
		  ((or (null? tail) (loop-op? (car tail) ops)))
		(set! next (pop tail))
		(if (null? tail)
		    (loop-error ops head 
				"Expression expected but source code ran out."))
		(case next
		  ((= )
		   (if type (loop-error ops head "Duplicate '='."))
		   (set! loop `(set! ,var ,(pop tail)))
		   (set! type next))
		  ((then )
		   (if init (loop-error ops head "Duplicate 'then'."))
		   (set! init loop)
		   (set! loop #f)
		   (set! step `(set! ,var ,(pop tail)))
		   (set! type next))
		  (else
		   (loop-error ops head "'" next "' is not valid with 'for'."))))
	      
	      (values (make-loop-clause 'operator 'for
					'bindings (list (make-binding var #f))
					'initially (if init (list init) '())
					'looping (if loop (list loop) '())
					'stepping (if step (list step) '()))
		      tail)))
	  
	  (define (parse-with forms clauses ops)
	    ;; forms is (WITH <var> = ...)
	    clauses
	    (let ((head forms)
		  (tail (cdr forms))
		  (var #f)
		  (expr #f)
		  (and? #f)
		  (bind '())
		  (init '()))
	      (do ((need #t) 
		   (next #f))
		  ((or (null? tail) (loop-op? (car tail) ops)))
		(set! next (pop tail))
		(cond ((and (loop-variable? next) need)
		       (if var
			   (loop-error ops head
				       "Found '" next "' where 'and' expected."))
		       (if expr
			   (loop-error ops head
				       "Found '" next "' where 'and' expected."))
		       (set! var next)
		       (set! expr #f)
		       (set! and? #f)
		       (set! need #f))
		      ((eq? next 'and)
		       (if and?
			   (loop-error ops head "Duplicate 'and'.")
			   (if var 
			       (if expr
				   (begin
				     (push (make-binding var #f) bind)
				     (push `(set! ,var ,expr) init))
				   (push (make-binding var #f) bind))
			       (loop-error ops head "Extraneous 'and'.")))
		       (set! var #f)
		       (set! expr #f)
		       (set! and? #t)
		       (set! need #t))
		      ((eq? next '=)
		       (if expr
			   (loop-error ops head 
				       "Found '=' where 'and' expected.")
			   (set! expr (pop tail))))
		      (else
		       (if need
			   (loop-error ops head
				       "Found '" next "' where variable expected.")
			   (loop-error ops head "Found '" next
				       "' where '=' or 'and' expected.")))))
	      (if and? 
		  (loop-error ops head "Extraneous 'and'.")
		  (if var 
		      (if expr
			  (begin (push (make-binding var #f) bind)
				 (push `(set! ,var ,expr) init))
			  (push (make-binding var #f) bind))))
	      
	      (values (make-loop-clause 'operator 'with
					'bindings (reverse bind)
					'initially (reverse init))
		      tail)))
	  
	  (define (parse-do forms clauses ops)
	    clauses
	    (let ((head forms)
		  (oper (pop forms))
		  (body '()))
	      (do ()
		  ((or (null? forms)
		       (loop-op? (car forms) ops))
		   (if (null? body)
		       (loop-error ops head "Missing '" oper "' expression.")
		       (set! body (reverse body))))
		(push (car forms) body)
		(set! forms (cdr forms)))
	      (values
	       (make-loop-clause 'operator oper 'looping body)
	       forms)))
	  
	  (define (parse-finally forms clauses ops)
	    clauses
	    (let ((oper (pop forms))
		  (expr #f))
	      (if (null? forms)
		  (loop-error ops forms "Missing '" oper "' expression."))
	      (set! expr (pop forms))
	      (values (make-loop-clause 'operator oper 'finally (list expr))
		      forms)))
	  
	  (define (parse-initially forms clauses ops)
	    clauses
	    (let ((oper (pop forms))
		  (expr #f))
	      (if (null? forms)
		  (loop-error ops forms "Missing '" oper "' expression."))
	      (set! expr (pop forms))
	      (values (make-loop-clause 'operator oper 'initially (list expr))
		      forms)))
	  
	  (define (lookup-collector var clauses)
	    ;; collector is list: (<var> <type> <acc> <head>)
	    ;; returns the clause where the collect variable VAR is
	    ;; actually bound or nil if var hasn't already been bound
	    ;; if var is nil only the single system allocated collecter
	    ;; is possibly returned.
	    (let ((checkthem (lambda (var lis)
			       (do ((a #f)) 
				   ((or (null? lis) a) a)
				 (if (eq? var (car (car lis))) ;collector-var
				     (set! a (car lis)))
				 (set! lis (cdr lis))))))
	      (do ((c #f))
		  ((or (null? clauses) c) c)
		(set! c (checkthem var (loop-collectors (car clauses))))
		(set! clauses (cdr clauses)))))
	  
	  (define (compatible-accumulation? typ1 typ2)
	    (let ((l1 '(collect append nconc))
		  (l2 '(never always))
		  (l3 '(minimize maximize)))
	      (or (eq? typ1 typ2)
		  (and (member typ1 l1) (member typ2 l1))
		  (and (member typ1 l2) (member typ2 l2))
		  (and (member typ1 l3) (member typ2 l3)))))
	  
	  (define (parse-accumulation forms clauses ops)
	    ;; forms is (<op> form ...)
	    ;; where <op> is collect append nconc
	    (let ((save forms)
		  (oper (pop forms))
		  (make-collector (lambda (var type acc head)
				    (list var type acc head)))
		  ;; removed because noop
		  ;;(collector-var (lambda (col) (car col)))
		  (collector-type (lambda (col) (cadr col)))
		  (collector-acc (lambda (col) (caddr col)))
		  (collector-head (lambda (col) (cadddr col)))
		  (expr #f)
		  (coll #f)
		  (new? #f)
		  (into #f)
		  (loop '())
		  (bind '())
		  (init '())
		  (tests '())
		  (return '()))
	      
	      (if (null? forms)
		  (loop-error ops forms "Missing '" oper "' expression."))
	      (set! expr (pop forms))
	      (if (not (null? forms))
		  (if (eq? (car forms) 'into)
		      (begin
			(if (null? (cdr forms))
			    (loop-error ops save "Missing 'into' variable."))
			(if (loop-variable? (cadr forms))
			    (begin (set! into (cadr forms))
				   (set! forms (cddr forms)))
			    (loop-error ops save "Found '" (car forms)
					"' where 'into' variable expected.")))))
	      
	      ;; search for a clause that already binds either the user specified
	      ;; accumulator (into) or a system allocated one if no into.
	      ;; system collectors
	      ;;   o only one  allowed, all accumuations must be compatible
	      ;;   o returns value
	      ;;   value collector: (nil <op> <#:acc>)
	      ;;   list collector:  (nil <op> <#:tail> <#:head>)
	      ;; into collectors
	      ;;   o any number allowed
	      ;;   o returns nothing.
	      ;;   value collector: (<into> <op> <into> )
	      ;;   list collector:  (<into> <op> <#:tail> <#:head>)
	      (set! coll (lookup-collector into clauses))
	      (if (not coll)
		  (set! new? #t)
		  ;; accumulator already established by earlier clause
		  ;; check to make sure clauses are compatible.
		  (if (not (compatible-accumulation? oper (collector-type coll)))
		      (loop-error ops save "'" (collector-type coll)
				  "' and '" oper "' are incompatible accumulators.")))
	      (case oper 
		((sum count)
		 (let ((acc #f))
		   (if new?
		       (begin 
			 (set! acc (or into (gensym "v")))
			 (push (make-binding acc 0) bind)
			 ;; coll= (nil <op> <#:acc>) or (<into> <op> <into>)
			 (set! coll (make-collector into oper acc #f))
			 ;; only add a return value if new collector isnt into
			 (if (not into) (push acc return)))
		       (set! acc (collector-acc coll)))
		   (if (eq? oper 'sum)
		       (push `(set! ,acc (+ ,acc ,expr)) loop)
		       (push `(if ,expr (set! ,acc (+ ,acc 1))) loop))))
		((minimize maximize)
		 (let ((var (gensym "v"))
		       (opr (if (eq? oper 'minimize) '< '>))
		       (acc #f))
		   (if new?
		       (begin
			 (set! acc (or into (gensym "v")))
			 (push (make-binding acc #f) bind)
			 ;; coll= (nil <op> <#:acc>) or (<into> <op> <into>)
			 (set! coll (make-collector into oper acc #f))
			 ;; only add a return value if new collector isnt into
			 (if (not into) (push `(or ,acc 0) return)))
		       (set! acc (collector-acc coll)))
		   (push (make-binding var #f) bind)
		   (push `(begin (set! ,var ,expr)
				 (if (or (not ,acc) 
					 (,opr ,var ,acc))
				     (set! ,acc ,var)))
			 loop)))
		((append collect nconc)
		 ;; for list accumulation a pointer to the tail of the list
		 ;; is updated and the head of the list is returned. any
		 ;; into variable is set to the head inside the loop.
		 (let ((head #f)
		       (tail #f))
		   (if (not new?)
		       (begin (set! tail (collector-acc coll))
			      (set! head (collector-head coll)))
		       (begin
			 (if into (push (make-binding into '(list)) bind))
			 (set! tail (gensym "v"))
			 ;; allocate a pointer to the head of list
			 (set! head (gensym "v"))
			 (push (make-binding head '(list #f)) bind)
			 (push (make-binding tail #f) bind)
			 ;; initialize tail to head
			 (push `(set! ,tail ,head) init)
			 (set! coll (make-collector into oper tail head))
			 ;; only add a return value if new collector isnt into
			 (if (not into)
			     (push `(cdr ,head) return))))
		   ;; add loop accumulation forms
		   (if (eq? oper 'append)
		       (begin
			 (push `(set-cdr! ,tail (append ,expr (list))) loop)
			 (push `(set! ,tail (last-pair ,tail)) loop))
		       (if (eq? oper 'collect)
			   (begin
			     (push `(set-cdr! ,tail (list ,expr)) loop)
			     (push `(set! ,tail (cdr ,tail)) loop))
			   (begin 
			     (push `(set-cdr! ,tail ,expr) loop)
			     (push `(set! ,tail (last-pair ,tail)) loop))))
		   ;; update user into variable inside the main loop
		   ;; regardless of whether its a new collector or not
		   (if into
		       (push `(set! ,into (cdr ,head)) loop)))))
	      
	      (values (make-loop-clause 'operator oper
					'bindings (reverse bind)
					'initially (reverse init)
					'looping (reverse loop)
					'returning (reverse return)
					'collectors (if new? (list coll) '())
					'end-tests (reverse tests))
		      forms)))
	  
					;(define (loop-stop expr)
					;  `(%done% ,expr))
	  
	  (define (loop-return expr)
	    `(return ,expr))
	  
	  (define (parse-while-until forms clauses ops)
	    clauses
	    (let ((head forms)
		  (oper (pop forms))
		  (test #f)
		  (stop '(go #t))) ; :done
	      (if (null? forms)
		  (loop-error ops head "Missing '" oper "' expression."))
	      
	      (case oper
		((until ) (set! test (pop forms)))
		((while ) (set! test `(not ,(pop forms)))))
	      ;; calls the DONE continuation.
	      (values (make-loop-clause 'operator oper
					'looping (list `(if ,test ,stop)))
		      forms)))
	  
	  (define (parse-thereis forms clauses ops)
	    clauses
	    (let ((oper (car forms))
		  (expr #f)
		  (bool #f)
		  (func #f))
	      (if (null? (cdr forms))
		  (loop-error ops forms "Missing '" (car forms) "' expression." ))
	      (set! expr (cadr forms))
	      ;; fourth element of operator definition must be
	      ;; a function that returns the stop expression.
	      (set! func (cadddr (loop-op? oper ops) ))
	      
	      (case oper
		((thereis ) 
		 ;; return true as soon as expr is true or false at end
		 (set! bool #f))
		((always )
		 ;; return false as soon as expr is false, or true at end
		 (set! expr `(not ,expr))
		 (set! bool #t))
		((never )
		 ;; return false as soon as expr is true, or true at end
		 (set! bool #t)))
	      (set! forms (cddr forms))
	      ;; this calls the RETURN continuation
	      (values (make-loop-clause 'operator 'thereis
					'looping 
					(list `(if ,expr ,(func (not bool))))
					'returning 
					(list bool))
		      forms)))
	  
	  (define (parse-return forms clauses ops)
	    clauses
	    (let ((oper (car forms))
		  (expr #f)
		  (func #f))
	      (if (null? (cdr forms))
		  (loop-error ops forms "Missing '" (car forms) "' expression."))
	      (set! expr (cadr forms))
	      (set! forms (cddr forms))
	      ;; fourth element of operator definition must be
	      ;; a function that returns the stop expression.
	      (set! func (cadddr (loop-op? oper ops) ))
	      ;; this calls the RETURN continuation
	      (values (make-loop-clause 'operator 'return
					'looping `(,(func expr)))
		      forms)))
	  
	  (define (legal-in-conditional? x ops)
	    ;; FIXED (member (loop-operator...))
	    (let ((op (loop-op? x ops)))
	      (if (and op 
		       (not (null? (cddr op)))
		       (eq? (caddr op) 'task)
		       (not (member (car op) '(thereis never always))))
		  op #f)))
	  
	  (define (parse-then-else-dependents forms clauses ops)
	    (let ((previous forms)
		  (stop? #f)
		  (parsed '()))
	      
	      (do ((op #f)
		   (clause #f)
		   (remains #f))
		  ((or (null? forms) stop?))
		(set! op (legal-in-conditional? (car forms) ops))
		(if (not op)
		    (loop-error ops previous "'" (car forms)
				"' is not conditional operator."))
					;(multiple-value-setq 
					; (clause remains)
					; ( (cadr op) forms (append clauses parsed) ops))
		(call-with-values
		    (lambda () ( (cadr op) forms (append clauses parsed) ops))
		  (lambda (a b) (set! clause a) (set! remains b)))
		
					;(format #t "~%after call clause=~s forms=~S" clause forms)      
		
		(set! parsed (append parsed (list clause)))
		(set! previous forms)
		(set! forms remains)
		
		(if (not (null? forms))
		    (if (eq? (car forms) 'and)
			(begin
			  (set! forms (cdr forms))
			  (if (null? forms)
			      (loop-error ops previous "Missing 'and' clause.")))
			(if (eq? (car forms) 'else)
			    (set! stop? #t)
			    (if (loop-op? (car forms) ops)
				(set! stop? #t))))))
	      (values parsed forms)))
	  
	  (define (parse-conditional forms clauses ops)
	    (let ((ops (cons '(else ) ops))
		  (save forms)
		  (oper (car forms))
		  (loop (list))  ; avoid '() because of acl bug
		  (expr (list))
		  (then (list))
		  (else (list)))
	      (if (null? (cdr forms))
		  (loop-error ops save "Missing '" oper "' expression."))
	      (set! forms (cdr forms))
	      (set! expr (pop forms))
	      (if (null? forms)
		  (loop-error ops forms "Missing conditional clause."))
	      (if (eq? oper 'unless)
		  (set! expr (list 'not expr)))
	      (call-with-values
		  (lambda () (parse-then-else-dependents forms clauses ops))
		(lambda (a b)
		  (set! then a)
		  (set! forms b)))
	      
	      ;; combine dependant clauses if more than one
	      (if (not (null? (cdr then)))
		  (set! then (gather-clauses (list) then))
		  (set! then (car then)))
	      (loop-operator-set! then 'if)
	      
	      ;; this (if ...) is hacked so that it is a newly
	      ;; allocated list. otherwise acl and clisp have a
	      ;; nasty structure sharing problem.
	      (set! loop (list 'if expr 
			       (append `(begin ,@(loop-looping then)) (list))
			       #f))
	      (if (and (not (null? forms))
		       (eq? (car forms) 'else))
		  (begin
		    (set! forms (cdr forms))
		    (when (null? forms)
			  (loop-error ops save "Missing 'else' clause."))
		    (call-with-values 
			(lambda ()
			  (parse-then-else-dependents 
			   forms (append clauses (list then))
			   ops))
		      (lambda (a b) (set! else a) (set! forms b)))
		    (if (not (null? (cdr else)))
			(set! else (gather-clauses '() else))
			(set! else (car else)))
		    (set-car! (cdddr loop) `(begin ,@(loop-looping else)))
		    ;; flush loop forms so we dont gather actions.
		    (loop-looping-set! then '())
		    (loop-looping-set! else '())
		    (set! then (gather-clauses 'if (list then else)))))
	      (loop-looping-set! then (list loop))
	      (values then forms)))
	  
	  (define (parse-clauses forms cond? ops)
	    (if (or (null? forms)
		    (not (symbol? (car forms))))
		(list (make-loop-clause 'operator 'do 'looping forms))
		(let ((op-type? (lambda (op type)
				  (and (not (null? (cddr op)))
				       (eq? (caddr op) type)))))
		  (let ((previous forms)
			(clauses '()))
		    (do ((op #f)
			 (clause #f)
			 (remains '())
			 (body '()) )
			((null? forms))
		      (if (and cond? (eq? (car forms) 'and))
			  (pop forms))
		      (set! op (loop-op? (car forms) ops))
		      (if (not op)
			  (loop-error ops previous "Found '" (car forms)
				      "' where operator expected."))
					;(multiple-value-setq (clause remains)
					;                     ((cadr op) forms clauses ops))
		      (call-with-values
			  (lambda () ( (cadr op) forms clauses ops))
			(lambda (a b)
			  (set! clause a)
			  (set! remains b)))
		      (if (op-type? op 'task)
			  (set! body op)
			  (if (op-type? op 'iter)
			      (if (not (null? body))
				  (loop-error ops previous "'" (car op)
					      "' clause cannot follow '"
					      (car body) "'."))))
		      (set! previous forms)
		      (set! forms remains)
		      (set! clauses (append clauses (list clause))))
		    clauses))))
	  
	  (define (parse-iteration caller forms ops)
	    (gather-clauses caller (parse-clauses forms '() ops)))
	  
	  ;;
	  ;; loop implementation
	  ;;
	  
	  (define *loop-operators*
	    ;; each clause is (<op> <parser> <tag> . <whatever>)
	    (list (list 'with (function parse-with) #f)
		  (list 'initially (function parse-initially) #f)
		  (list 'repeat (function parse-repeat) 'iter)
		  (list 'for (function parse-for) 'iter
			(list 'from (function parse-numerical-for))
			(list 'downfrom (function parse-numerical-for))
			(list 'below (function parse-numerical-for))
			(list 'to (function parse-numerical-for))
			(list 'above (function parse-numerical-for))
			(list 'downto (function parse-numerical-for))
			(list 'in (function parse-sequence-iteration))
			(list 'on (function parse-sequence-iteration))
			(list 'across (function parse-sequence-iteration))
			(list '= (function parse-general-iteration)))
		  (list 'as (function parse-for) 'iter)
		  (list 'do (function parse-do) 'task)
		  (list 'collect (function parse-accumulation) 'task)
		  (list 'append (function parse-accumulation) 'task)
		  (list 'nconc (function parse-accumulation) 'task)
		  (list 'sum (function parse-accumulation) 'task)
		  (list 'count (function parse-accumulation) 'task)
		  (list 'minimize (function parse-accumulation) 'task)
		  (list 'maximize (function parse-accumulation) 'task)
		  (list 'thereis (function parse-thereis) 'task
			(function loop-return))
		  (list 'always (function parse-thereis) 'task
			(function loop-return))
		  (list 'never (function parse-thereis) 'task 
			(function loop-return))
		  (list 'return (function parse-return) 'task 
			(function loop-return))
		  (list 'while (function parse-while-until) #f )
		  (list 'until (function parse-while-until) #f )
		  (list 'when (function parse-conditional) 'task)
		  (list 'unless (function parse-conditional) 'task)
		  (list 'if (function parse-conditional) 'task)
		  (list 'finally (function parse-finally) #f)))
	  
	  ;;
	  ;; loop expansions for scheme and cltl2
	  ;;
	  
	  (define (scheme-loop forms)
	    (let ((name (gensym "v"))
		  (parsed (parse-iteration 'loop forms *loop-operators*))
		  (end-test '())
		  (done '(go #t))  ; :done
		  (return #f))
					;(write (list :parsed-> parsed))
	      ;; cltl2's loop needs a way to stop iteration from with the run
	      ;; block (the done form) and/or immediately return a value
	      ;; (the return form).  scheme doesnt have a block return or a
	      ;; go/tagbody mechanism these conditions are implemented using
	      ;; continuations.  The forms that done and return expand to are
	      ;; not hardwired into the code because this utility is also used
	      ;; by CM's 'process' macro. Instead, the done and return forms
	      ;; are returned by functions assocated with the relevant operator
	      ;; data. For example, the function that returns the return form
	      ;; is stored as the fourth element in the return operator data.
	      ;; and the done function is stored in the while and until op data.
	      
	      ;; the cadddr of the RETURN operator is a function that
	      ;; provides the form for immediately returning a value
	      ;; from the iteration.
	      
	      (let ((returnfn (cadddr (assoc 'return *loop-operators*))))
		(set! return (returnfn
			      (if (null? (loop-returning parsed))
				  #f
				  (car (loop-returning parsed))))))
	      
	      ;; combine any end-tests into a single IF expression
	      ;; that calls the (done) continuation if true. multiple
	      ;; tests are OR'ed togther
	      
	      (set! end-test
		    (let ((ends (loop-end-tests parsed)))
		      (if (null? ends)
			  '()
			  (list
			   `(if ,(if (null? (cdr ends))
				     (car ends)
				     (cons 'or ends))
				;;  calls the done continuation
				,done 
				#f)))))
	      `(let (,@ (loop-bindings parsed))
		 ,@(loop-initially parsed)
		 (call-with-exit
		  (lambda (return)     ; <- (return) returns from this lambda
		    (call-with-exit
		     (lambda (go)  ; <- (go #t) returns from this lambda
		       ;; a named let provides the actual looping mechanism.
		       ;; the various tests and actions may exit via the
		       ;; (done) or (return) continuations.
		       (let ,name () 
			    ,@end-test
			    ,@(loop-looping parsed)
			    ,@(loop-stepping parsed)
			    (,name))))
		    ;; this is the lexical point for (go #t) continuation.
		    ,@(loop-finally parsed)
		    ;; invoke the RETURN continuation with loop value or #f
		    ,return)))))
	  
	  
	  (scheme-loop args)))
      
      ;;
      ;; loop tests.
      ;;
      
      (test (loop for i below 10 collect i) '(0 1 2 3 4 5 6 7 8 9))
      (test (loop for i to 10 sum i) 55)
      (test (loop for i downto -10 count (even? i)) 6)
      (test (loop for x in '(0 1 2 3 4 5 6 7 8 9) thereis (= x 4)) #t)
      (test (loop for x in '(0 1 2 3 4 5 6 7 8 9) by 'cddr collect x) '(0 2 4 6 8))
      (test (loop for x on '(0 1 2 3) by 'cddr collect x) '((0 1 2 3) (2 3)))
      (test (loop for x in '(0 1 2 3 4 5 6 7 8 9) thereis (= x 4)) #t)
      (test (loop for x in '(0 1 2 3 4 5 6 7 8 9) never (= x 4)) #f)
      (test (loop for x in '(0 1 2 3 4 5 6 7 8 9) never (= x 40)) #t)
      (test (loop for x in '(0 2 3 4 5 6 7 8 9) always (< x 40)) #t)
      (test (loop repeat 10 with x = 0 collect x do (set! x (+ x 1))) '(0 1 2 3 4 5 6 7 8 9))
      (test (loop repeat 10 for x = #t then (not x) collect x) '(#t #f #t #f #t #f #t #f #t #f))
      (test (loop repeat 10 count #t) 10)
      (test (loop repeat 10 count #f) 0)
      (test (loop for i to 10 collect i collect (* 2 i)) '(0 0 1 2 2 4 3 6 4 8 5 10 6 12 7 14 8 16 9 18 10 20))
      (test (loop for i from -10 to 10 by 2 nconc (list i (- i))) '(-10 10 -8 8 -6 6 -4 4 -2 2 0 0 2 -2 4 -4 6 -6 8 -8 10 -10))
      (test (loop for i from -10 downto 10 by -1 collect i) '())
      (test (loop for i downfrom 10 downto -10 by 2 collect i) '(10 8 6 4 2 0 -2 -4 -6 -8 -10))
      (test (loop for i from 10 to -10 by 1 collect i) '())
      (test (loop for i to 10 for j downfrom 10 collect i collect j) '(0 10 1 9 2 8 3 7 4 6 5 5 6 4 7 3 8 2 9 1 10 0))
      (test (loop for i below 0 collect i into foo finally (return foo)) '())
      (test (loop for i below 0 sum i into foo finally (return foo)) 0)
      (test (loop for i below 0 maximize i into foo finally (return foo)) #f)
      (test (loop with a and b = 'x and c = 2 repeat 10 for x = 1 then 'fred collect (list x a b c))
	    '((1 #f x 2) (fred #f x 2) (fred #f x 2) (fred #f x 2) (fred #f x 2) (fred #f x 2) (fred #f x 2) (fred #f x 2) (fred #f x 2) (fred #f x 2)))
      (test (loop for i across #(0 1 2 3) append (list i (expt 2 i))) '(0 1 1 2 2 4 3 8))
      (test (loop with a = 0 and b = -1 while (< a 10) sum a into foo do (set! a (+ a 1)) finally (return (list foo b))) '(45 -1))
      (test (loop for i from 0 until (> i 9) collect i) '(0 1 2 3 4 5 6 7 8 9))
      (test (loop for i from 0 while (< i 9) when (even? i) collect i) '(0 2 4 6 8))
      (test (loop with l = (list 0) for s in spec for k = s then (+ k s) do (push k l) finally (return l)) 'error)
      (test (loop with l = (list (encode-interval 'p 1)) for s in spec for k = (interval s) then (transpose k (interval s)) do (push k l) finally (return l)) 'error)
      ;; end loop

      ;; more macros from Rick's stuff

      (defmacro dolist (spec . body)
	;; spec = (var list . return)
	(let ((v (gensym)))
	  `(do ((,v ,(cadr spec) (cdr ,v))
		(,(car spec) #f))
	       ((null? ,v) ,@(cddr spec))
	     (set! ,(car spec) (car ,v))
	     ,@body)))

      (test (let ((sum 0)) (dolist (v (list 1 2 3) sum) (set! sum (+ sum v)))) 6)
      
      (defmacro dotimes (spec . body)
	;; spec = (var end . return)
	(let ((e (gensym))
	      (n (car spec)))
	  `(do ((,e ,(cadr spec))
		(,n 0))
	       ((>= ,n ,e) ,@(cddr spec))
	     ,@body
	     (set! ,n (+ ,n 1)))))

      (test (let ((sum 0)) (dotimes (i 3 sum) (set! sum (+ sum i)))) 3)
      
      (defmacro do* (spec end . body)
	`(let* (,@(map (lambda (var) (list (car var) (cadr var))) spec))
	   (do () ,end
	     ,@body
	     ,@(map (lambda (var) (list 'set! (car var) (caddr var))) spec))))

      (test (let ((sum 0)) (do* ((i 0 (+ i 1)) (j i (+ i 1))) ((= i 3) sum) (set! sum (+ sum j)))) 5)

      (define-macro (fluid-let xexe . body)
	;; taken with changes from Teach Yourself Scheme
	(let ((xx (map car xexe))
	      (ee (map cadr xexe))
	      (old-xx (map (lambda (ig) (gensym)) xexe)))
	  `(let ,(map (lambda (old-x x) `(,old-x ,x)) 
		      old-xx xx)
	     (dynamic-wind
		 (lambda () #f)
		 (lambda ()
		   ,@(map (lambda (x e)
			    `(set! ,x ,e)) 
			  xx ee)
		   (let ()
		     ,@body))
		 (lambda ()
		   ,@(map (lambda (x old-x)
			    `(set! ,x ,old-x)) 
			  xx old-xx))))))
      
      (test (let ((x 32)
		  (y 0))
	      (define (gx) x)
	      (fluid-let ((x 12))
		(set! y (gx)))
	      (list x y))
	    '(32 12))
      
      (test (let ((x "hi")
		  (y 0)
		  (z '(1 2 3)))
	      (define (gx) (+ x z))
	      (fluid-let 
		  ((x 32) (z (+ 123 (car z))))
		(set! y (gx)))
	      (list x y z))
            '("hi" 156 (1 2 3)))
      
      (test (let ((x 32)
		  (y 0))
	      (define (gx) x)
	      (call-with-exit
	       (lambda (return)
		 (fluid-let ((x 12))
		   (set! y (gx))
		   (return))))
	      (list x y))
	    '(32 12))

      (test (let ((x 32)
		  (y 0))
	      (define (gx) x)
	      (let ((x 100))
		(fluid-let ((x 12))
		  (set! y (gx))))
	      (list x y))
	    '(32 32))
      ;; oops! fluid-let doesn't actually work!

      ;; in CL: (defvar x 32) (let ((y 0)) (defun gx () x) (let ((x 12)) (setf y (gx))) (list x y)) -> '(32 12)
      ;;                      (let ((y 0)) (defun gx () x) (let ((x 100)) (let ((x 12)) (setf y (gx)))) (list x y)) -> '(32 12)
      ;;                      (let ((y 0)) (defun gx () x) (let ((x 100)) (let ((x 12)) (setf y (gx)) (setf x 123)) (list x y))) -> '(100 12) !
      ;; (the defvar makes x dynamic)

      
      ;; define** treats args before :optional as required args
      (define-macro (define** declarations . forms)
	(let ((name (car declarations))
	      (args (cdr declarations)))
	  (define (position thing lst count)
	    (if (or (null? lst)
		    (not (pair? (cdr lst))))
		#f
		(if (eq? thing (car lst))
		    count
		    (position thing (cdr lst) (+ count 1)))))
	  (let ((required-args (position :optional args 0)))
	    (if required-args
		`(define* (,name . func-args)
		   (if (< (length func-args) ,required-args)
		       (error "~A requires ~D argument~A: ~A" 
			      ',name ,required-args (if (> ,required-args 1) "s" "") func-args)
		       (apply (lambda* ,args ,@forms) func-args)))
		`(define* ,declarations ,@forms)))))

      ;; Rick's with-optkeys

      (define-macro (with-optkeys spec . body)
	(
	 (lambda (user rawspec body)
	   
	   (define (string->keyword str) (symbol->keyword (string->symbol str)))
	   
	   (define (key-parse-clause info mode args argn user)
	     ;; return a cond clause that parses one keyword. info for each
	     ;; var is: (<got> <var> <val>)
	     (let* ((got (car info))
		    (var (cadr info))
		    (key (string->keyword (symbol->string var))))
	       `((eq? (car ,args) ,key )
		 (if ,got (error "duplicate keyword: ~S" , key))
		 (set! ,var (if (null? (cdr ,args))
				(error "missing value for keyword: ~S" 
				       , user)
				(cadr ,args)))
		 (set! ,got #t) ; mark that we have a value for this param
		 (set! ,mode #t) ; mark that we are now parsing keywords
		 (set! ,argn (+ ,argn 1))
		 (set! ,args (cddr ,args)))))
	   
	   (define (pos-parse-clause info mode args argn I)
	     ;; return a cond clause that parses one positional. info for
	     ;; each var is: (<got> <var> <val>)
	     (let ((got (car info))
		   (var (cadr info)))
	       `((= ,argn ,I)
		 (set! ,var (car ,args))
		 (set! ,got #t) ; mark that we have a value for this param
		 (set! ,argn (+ ,argn 1))
		 (set! ,args (cdr ,args)))))
	   
	   (let* ((otherkeys? (member '&allow-other-keys rawspec))
		  ;; remove &allow-other-keys from spec
		  (spec (if otherkeys? (reverse (cdr (reverse rawspec))) rawspec))
		  (data (map (lambda (v)
			       ;; for each optkey variable v return a list
			       ;; (<got> <var> <val>) where the <got>
			       ;; variable indicates that <var> has been
			       ;; set, <var> is the optkey variable itself
			       ;; and <val> is its default value
			       (if (pair? v)
				   (cons (gensym (symbol->string (car v))) v)
				   (list (gensym (symbol->string v)) v #f)))
			     spec))
		  (args (gensym "args")) ; holds arg data as its parsed
		  (argn (gensym "argn"))
		  (SIZE (length data))
		  (mode (gensym "keyp")) ; true if parsing keywords
		  ;; keyc are cond clauses that parse valid keyword
		  (keyc (map (lambda (d) (key-parse-clause d mode args argn user))
			     data))
		  (posc (let lup ((tail data) (I 0))
			  (if (null? tail) (list)
			      (cons (pos-parse-clause (car tail) mode args argn I)
				    (lup (cdr tail) (+ I 1))))))
		  (bindings (map cdr data)) ; optkey variable bindings
		  )
	     
	     (if otherkeys?
		 (set! bindings (cons '(&allow-other-keys (list)) bindings)))
	     
	     `(let* ,bindings ; bind all the optkey variables with default values
		;; bind status and parsing vars
		(let ,(append (map (lambda (i) (list (car i) #f)) data)
			      `((,args ,user)
				(,argn 0)
				(,mode #f)))
		  ;; iterate arglist and set opt/key values
		  (do ()
		      ((null? ,args) #f)
		    (cond 
		     ;; add valid keyword clauses first
		     ,@ keyc
			;; a keyword in (car args) is now either added to
			;; &allow-other-keys or an error
			, (if otherkeys?
			      `((keyword? (car ,args))
				(if (not (pair? (cdr ,args)))
				    (error "missing value for keyword ~S" (car ,args)))
				(set! &allow-other-keys (append &allow-other-keys
								(list (car ,args)
								      (cadr ,args))))
				(set! ,mode #t) ; parsing keys now...
				(set! ,args (cddr ,args)) )
			      `((keyword? (car ,args)) ;(and ,mode (keyword? (car ,args)))
				(error "invalid keyword: ~S" (car ,args)) )
			      )
			  ;; positional clauses illegal if keywords have happened
			  (,mode (error "positional after keywords: ~S" (car ,args)))
			  ;; too many value specified
			  ((not (< ,argn ,SIZE)) (error "too many args: ~S" , args))
			  ;; add the valid positional clauses
			  ,@ posc
			     ))
		  ,@ body))
	     ))
	 (car spec)
	 (cdr spec)
	 body
	 ))
      
      (test (let ((args '(1 2 3)))  (with-optkeys (args a b c) (list a b c))) '(1 2 3))
      (test (let ((args '(1 2 3 4)))  (with-optkeys (args a b c) (list a b c))) 'error)
      (test (let ((args '(1 2))) (with-optkeys (args a b (c 33)) (list a b c))) '(1 2 33))
      (test (let ((args '())) (with-optkeys (args a b (c 33)) (list a b c))) '(#f #f 33))
      (test (let ((args '(:b 22))) (with-optkeys (args a b (c 33)) (list a b c))) '(#f 22 33))
      (test (let ((args '(-1 :z 22))) (with-optkeys (args a b (c 33)) (list a b c))) 'error)
      (test (let ((args '(:b 99 :z 22))) (with-optkeys (args a b (c 33)) (list a b c))) 'error)
      (test (let ((args '(:z 22))) (with-optkeys (args a b (c 33) &allow-other-keys) (list a b c &allow-other-keys))) '(#f #f 33 (:z 22)))
      (test (let ((args '(:id "0" :inst "flute" :name "Flute"))) (with-optkeys (args id inst &allow-other-keys) (list id inst &allow-other-keys))) '("0" "flute" (:name "Flute")))
      (test (let ((args '(:inst "flute" :id "0" :name "Flute"))) (with-optkeys (args id inst &allow-other-keys) (list id inst &allow-other-keys))) '("0" "flute" (:name "Flute")))
      (test (let ((args '(:id "0" :name "Flute" :inst "flute"))) (with-optkeys (args id inst &allow-other-keys) (list id inst &allow-other-keys))) '("0" "flute" (:name "Flute")))
      (test (let ((args '(:name "Flute" :inst "flute" :id "0"))) (with-optkeys (args id inst &allow-other-keys) (list id inst &allow-other-keys))) '("0" "flute" (:name "Flute")))
      
      
      (let ()
	
	;; some common lispisms
	;;   where names are the same, but functions are different (abs for example), 
	;;   I'll prepend "cl-" to the CL version; otherwise we end up redefining
	;;   map and member, for example, which can only cause confusion.
	;;
	;; also I'm omitting the test-if-not and test-not args which strike me as ridiculous.
	;; If CLtL2 says something is deprecated, it's not included.
	;; Series and generators are ignored.
	;;
	;;  ... later ... I've run out of gas.
	
					;(define-macro (progn . body) `(let () ,@body))
	(define progn begin)
	(define-macro (prog1 first . body) (let ((result (gensym))) `(let ((,result ,first)) ,@body ,result)))
	(define-macro (prog2 first second . body) `(prog1 (progn ,first ,second) ,@body))

	(defmacro the (type form) form)
	(define-macro (defvar var . args) `(define ,var (or ,(and (not (null? args)) (car args)) #f)))

	(defmacro incf (sym . val) `(let () (set! ,sym (+ ,sym ,(if (null? val) 1 (car val)))) ,sym))
	(defmacro decf (sym . val) `(let () (set! ,sym (- ,sym ,(if (null? val) 1 (car val)))) ,sym))

	(defmacro push (val sym) 
	  `(let () 
	     (setf ,sym (cons ,val ,sym)) 
	     ,sym))

	(defmacro pop (sym) 
	  (let ((v (gensym))) 
	    `(let ((,v (car ,sym))) 
	       (setf ,sym (cdr ,sym)) 
	       ,v)))

	(defmacro* pushnew (val sym (test equal?) (key identity))
	  (let ((g (gensym))
		(k (if (procedure? key) key identity))) ; can be explicit nil!
	    `(let ((,g ,val))
	       (if (null? (cl-member (,k ,g) ,sym ,test ,k))
		   (push ,g ,sym))
	       ,sym)))

	(defmacro unless (test . forms) `(if (not ,test) (begin ,@forms)))
	(define-macro (declare . args) #f)
	(defmacro set (a b) `(set! ,(symbol->value a) ,b))

	(define-macro (setf . pairs)
	  (if (not (even? (length pairs)))
	      (error "setf has odd number of args"))
	  `(let () ,@(let ((var #f)) 
		       (map (lambda (p) 
			      (if var
				  (let ((val (if (pair? var)
						 (if (member (car var) '(aref svref elt char schar))
						     (list 'set! (cdr var) p)
						     (if (eq? (car var) 'car)
							 (list 'set-car! (cadr var) p)
							 (if (eq? (car var) 'cdr)
							     (list 'set-cdr! (cadr var) p)
							     (if (eq? (car var) 'nth)
								 (list 'set! (list (caddr var) (cadr var)) p)
								 (list 'set! var p)
								 ))))
						 (list 'set! var p))))
				    (set! var #f)
				    val)
				  (begin
				    (set! var p)
				    '())))
			    pairs))))

	(define-macro (setq . pairs)
	  (if (not (even? (length pairs)))
	      (error "setq has odd number of args"))
	  `(let () ,@(let ((var #f)) 
		       (map (lambda (p) 
			      (if var
				  (let ((val (list 'set! var p)))
				    (set! var #f)
				    val)
				  (begin
				    (set! var p)
				    '())))
			    pairs))))

	(define-macro (psetq . pairs)
	  (let ((vals '())
		(vars '()))
	    (do ((var-val pairs (cddr var-val)))
		((null? var-val))
	      (let ((interval (gensym)))
		(set! vals (cons (list interval (cadr var-val)) vals))
		(set! vars (cons (list 'set! (car var-val) interval) vars))))
	    `(let ,(reverse vals)
	       ,@vars)))

	(define (mapcar func . lists)
	  ;; not scheme's map because lists can be different lengths
	  ;; and args can be any sequence type (all mixed together)
	  (define (mapcar-seqs func seqs)
	    (if (null? seqs)
		'()
		(cons (func (car seqs))
		      (mapcar-seqs func (cdr seqs)))))

	  (define (mapcar-1 index lens func seqs)
	    (if (member index lens)
		'()
		(cons (apply func (mapcar-seqs (lambda (obj) (obj index)) seqs))
		      (mapcar-1 (+ index 1) lens func seqs))))

	  (let ((lens (map length lists)))
	    (mapcar-1 0 lens func lists)))
#|
(define (mapcar func . lists)
  ;; not scheme's map because lists can be different lengths
  (if (member '() lists)
      '()
      (cons (apply func (map car lists))
	    (apply mapcar func (map cdr lists)))))
|#

	(define (maplist function . lists)
	  (if (member '() lists)
	      '()
	      (cons (apply function lists)
		    (apply maplist function (map cdr lists)))))

	(define (mapc function . lists)
	  (define (mapc-1 function . lists)
	    (if (not (member '() lists))
		(begin
		  (apply function (map car lists))
		  (apply mapc-1 function (map cdr lists)))))
	  (apply mapc-1 function lists)
	  (car lists))

	(define (mapl function . lists)
	  (define (mapl-1 function . lists)
	    (if (not (member '() lists))
		(begin
		  (apply function lists)
		  (apply mapl-1 function (map cdr lists)))))
	  (apply mapl-1 function lists)
	  (car lists))

	(define (mapcon function . lists)
	  (apply nconc (apply maplist function lists)))

	(define (mapcan function . lists)
	  (apply nconc (apply mapcar function lists)))
	  
	(define* (map-into result-sequence function . sequences)
	  (if (or (null? result-sequence)
		  (null? sequences))
	      result-sequence
	      (let* ((vals (apply mapcar function sequences))
		     (len (min (length vals) (length result-sequence))))
		(do ((i 0 (+ i 1)))
		    ((= i len))
		  (set! (result-sequence i) (vals i)))
		result-sequence)))


	(define input-stream-p input-port?)
	(define output-stream-p output-port?)


	;; -------- lists

	;; in CL (cdr '()) is nil

	(define (first l) (if (not (null? l)) (list-ref l 0) '()))
	(define (second l) (if (> (length l) 1) (list-ref l 1) '()))
	(define (third l) (if (> (length l) 2) (list-ref l 2) '()))
	(define (fourth l) (if (> (length l) 3) (list-ref l 3) '()))
	(define (fifth l) (if (> (length l) 4) (list-ref l 4) '()))
	(define (sixth l) (if (> (length l) 5) (list-ref l 5) '()))
	(define (seventh l) (if (> (length l) 6) (list-ref l 6) '()))
	(define (eighth l) (if (> (length l) 7) (list-ref l 7) '()))
	(define (ninth l) (if (> (length l) 8) (list-ref l 8) '()))
	(define (tenth l) (if (> (length l) 9) (list-ref l 9) '()))
	(define (nth n l) (if (< n (length l)) (list-ref l n) '()))
	(define (endp val) (if (null? val) #t (if (pair? val) #f (error "bad arg to endp"))))
	(define rest cdr)
	(define list-length length)
	(define* (cl-make-list size (initial-element '())) (make-list size initial-element))

	(define (copy-list lis) 
	  (if (not (pair? lis))
	      lis
	      (cons (car lis) (copy-list (cdr lis)))))

	(define (rplaca x y) (set-car! x y) x)
	(define (rplacd x y) (set-cdr! x y) x)

	(define (copy-tree lis)
	  (if (pair? lis)
	      (cons (copy-tree (car lis))
		    (copy-tree (cdr lis)))
	      lis))

	(define* (butlast lis (n 1))
	  (let ((len (length lis)))
	    (if (<= len n)
		'()
		(let ((result '()))
		  (do ((i 0 (+ i 1))
		       (lst lis (cdr lst)))
		      ((= i (- len n)) (reverse result))
		    (set! result (cons (car lst) result)))))))

	(define* (last lst (n 1))
	  (let ((len (length lst)))
	    (do ((i 0 (+ i 1))
		 (l lst (cdr l)))
		((or (null? l)
		     (>= i (- len n)))
		 l))))

	(define (nthcdr n lst) 
	  (do ((i n (- i 1)) 
	       (result lst (cdr result))) 
	      ((or (null? result) (zero? i)) result)))

	(define* (tree-equal a b (test eql)) 
	  (define (teq a b)
	    (if (not (pair? a))
		(and (not (pair? b))
		     (test a b))
		(and (pair? b)
		     (teq (car a) (car b))
		     (teq (cdr a) (cdr b)))))
	  (teq a b))

	(define (acons key datum alist) (cons (cons key datum) alist))

	(define* (subst-if new test tree (key identity))
	  (if (test (key tree))
	      new
	      (if (not (pair? tree))
		  tree
		  (cons (subst-if new test (car tree) key)
			(subst-if new test (cdr tree) key)))))

	(define* (subst-if-not new test tree (key identity))
	  (subst-if new (lambda (obj) (not (test obj))) tree key))

	(define* (subst new old tree (test eql) (key identity))
	  (subst-if new (lambda (obj) (test old obj)) tree key))

	(define (list* obj1 . objs)
	  (define (list-1 obj)
	    (if (null? (cdr obj))
		(car obj)
		(cons (car obj) (list-1 (cdr obj)))))
	  (if (null? objs)
	      obj1
	      (cons obj1 (list-1 objs))))

	(define* (assoc-if predicate alist (key car))
	  (if (null? alist)
	      '()
	      (if (and (not (null? (car alist)))
		       (predicate (key (car alist))))
		  (car alist)
		  (assoc-if predicate (cdr alist) key))))
	
	(define* (assoc-if-not predicate alist (key car))
	  (assoc-if (lambda (obj) (not (predicate obj))) alist key))

	(define* (cl-assoc item alist (test eql) (key car))
	  (assoc-if (lambda (obj) (test item obj)) alist key))
	
	(define* (rassoc-if predicate alist (key cdr))
	  (if (null? alist)
	      '()
	      (if (and (not (null? (car alist)))
		       (predicate (key (car alist))))
		  (car alist)
		  (rassoc-if predicate (cdr alist) key))))
	
	(define* (rassoc-if-not predicate alist (key cdr))
	  (rassoc-if (lambda (obj) (not (predicate obj))) alist key))

	(define* (rassoc item alist (test eql) (key cdr))
	  (rassoc-if (lambda (obj) (test item obj)) alist key))

	(define (copy-alist alist)
	  (if (null? alist)
	      '()
	      (cons (if (pair? (car alist))
			(cons (caar alist) (cdar alist))
			(car alist))
		    (copy-alist (cdr alist)))))

	(define (revappend x y) (append (reverse x) y))

	
	(define* (pairlis keys data alist)
	  (if (not (= (length keys) (length data)))
	      (error "pairlis keys and data lists should have the same length"))
	  (let ((lst (or alist '())))
	    (if (null? keys)
		lst
		(do ((key keys (cdr key))
		     (datum data (cdr datum)))
		    ((null? key) lst)
		  (set! lst (cons (cons (car key) (car datum)) lst))))))

	(define* (sublis alist tree (test eql) (key car))
	  (let ((val (cl-assoc tree alist test key)))
	    (if (not (null? val))
		(cdr val)
		(if (not (pair? tree))
		    tree
		    (cons (sublis alist (car tree) test key)
			  (sublis alist (cdr tree) test key))))))

	(define* (nsublis alist tree (test eql) (key car)) ; sacla
	  (define (sub subtree)
	    (let ((ac (cl-assoc subtree alist test key)))
	      (if (not (null? ac))
		  (cdr ac)
		  (if (not (pair? subtree))
		      subtree
		      (let ()
			(set-car! subtree (sub (car subtree)))
			(set-cdr! subtree (sub (cdr subtree)))
			subtree)))))
	  (sub tree))

	(define* (nsubst-if new predicate tree (key identity)) ; sacla
	  (define (sub subtree)
	    (if (predicate (key subtree))
		new
		(if (not (pair? subtree))
		    subtree
		    (let ()
		      (set-car! subtree (sub (car subtree)))
		      (set-cdr! subtree (sub (cdr subtree)))
		      subtree))))
	  (sub tree))

	(define* (nsubst-if-not new predicate tree (key identity))
	  (nsubst-if new (lambda (obj) (not (predicate obj))) tree key))
    
	(define* (nsubst new old tree (test eql) (key identity))
	  (nsubst-if new (lambda (obj) (test old obj)) tree key))

	(define (ldiff lst object) ; sacla
	  (if (not (eqv? lst object))
	      (let* ((result (list (car lst)))
		     (splice result))
		(call-with-exit
		 (lambda (return)
		   (do ((l (cdr lst) (cdr l)))
		       ((not (pair? l))
			(if (eql l object) 
			    (set-cdr! splice '()))
			result)
		     (if (eqv? l object)
			 (return result)
			 (set! splice (cdr (rplacd splice (list (car l))))))))))
	      '()))

	(define* (member-if predicate list (key identity))
	  (if (null? list)
	      '()
	      (if (predicate (key (car list)))
		  list
		  (member-if predicate (cdr list) key))))

	(define* (member-if-not predicate list (key identity))
	  (member-if (lambda (obj) (not (predicate obj))) list key))

	(define* (cl-member item list (test eql) (key identity))
	  (if (null? list)
	      '()
	      (if (test item (key (car list)))
		  list
		  (cl-member item (cdr list) test key))))

	(define* (adjoin item list (test eql) (key identity))
	  (if (not (null? (cl-member (key item) list test key)))
	      list
	      (cons item list)))

	(define (tailp sublist list)
	  (or (eq? sublist list)
	      (and (not (null? list))
		   (tailp sublist (cdr list)))))

	(define* (union list1 list2 (test eql) (key identity))
	  (let ((new-list (copy list1)))
	    (do ((obj list2 (cdr obj)))
		((null? obj) new-list)
	      (set! new-list (adjoin (car obj) new-list test key)))))

	(define nunion union) ; this is not required to be destructive

	(define* (intersection list1 list2 (test eql) (key identity))
	  (let ((new-list '()))
	    (do ((obj list1 (cdr obj)))
		((null? obj) new-list)
	      (if (not (null? (cl-member (key (car obj)) list2 test key)))
		  (set! new-list (adjoin (car obj) new-list test key))))))

	(define nintersection intersection)
	    
	(define* (set-difference list1 list2 (test eql) (key identity))
	  (let ((new-list '()))
	    (do ((obj list1 (cdr obj)))
		((null? obj) new-list)
	      (if (null? (cl-member (key (car obj)) list2 test key))
		  (set! new-list (adjoin (car obj) new-list test key))))))

	(define nset-difference set-difference)

	(define* (set-exclusive-or list1 list2 (test eql) (key identity))
	  (let ((new-list '()))
	    (do ((obj list1 (cdr obj)))
		((null? obj))
	      (if (null? (cl-member (key (car obj)) list2 test key))
		  (set! new-list (adjoin (car obj) new-list test key))))
	    (do ((obj list2 (cdr obj)))
		((null? obj) new-list)
	      (if (null? (cl-member (key (car obj)) list1 test key))
		  (set! new-list (adjoin (car obj) new-list test key))))))

	(define nset-exclusive-or set-exclusive-or)

	(define* (subsetp list1 list2 (test eql) (key identity))
	  (call-with-exit
	   (lambda (return)
	     (do ((obj list1 (cdr obj)))
		 ((null? obj) #t)
	      (if (null? (cl-member (key (car obj)) list2 test key))
		  (return nil))))))

	(define* (nbutlast list (n 1)) ; sacla
	  (if (null? list)
	      '()
	      (let ((length (do ((p (cdr list) (cdr p))
				 (i 1 (+ i 1)))
				((not (pair? p)) i))))
		(if (> length n)
		    (do ((1st (cdr list) (cdr 1st))
			 (2nd list 1st)
			 (count (- length n 1) (- count 1)))
			((zero? count) 
			 (set-cdr! 2nd '())
			 list))
		    '()))))

	(define (nconc . lists) ; sacla sort of
	  (let ((ls (let ()
		      (define (strip-nulls lst)
			(if (null? lst)
			    '()
			    (if (null? (car lst))
				(strip-nulls (cdr lst))
				lst)))
		      (strip-nulls lists))))
	    (if (null? ls)
		'()
	      (let* ((top (car ls))
		     (splice top))
		(do ((here (cdr ls) (cdr here)))
		    ((null? here) top)
		  (set-cdr! (last splice) (car here))
		  (if (not (null? (car here)))
		      (set! splice (car here))))))))

	(define (nreconc x y) (nconc (nreverse x) y))



	;; -------- numbers

	(define (conjugate z) (make-rectangular (real-part z) (- (imag-part z))))
	(define zerop zero?)
	(define oddp odd?)
	(define evenp even?)
	(define plusp positive?)
	(define minusp negative?)
	(define realpart real-part)
	(define imagpart imag-part)
	(define* (float x ignore) (* 1.0 x))
	(define rational rationalize)
	(define mod modulo)
	(define rem remainder)

	(define (logtest i1 i2) (not (zero? (logand i1 i2))))
	(define (logbitp index integer) (logbit? integer index)) ;(logtest (expt 2 index) integer))
	(define (lognand n1 n2) (lognot (logand n1 n2)))
	(define (lognor n1 n2) (lognot (logior n1 n2)))
	(define (logandc1 n1 n2) (logand (lognot n1) n2))
	(define (logandc2 n1 n2) (logand n1 (lognot n2)))
	(define (logorc1 n1 n2) (logior (lognot n1) n2))
	(define (logorc2 n1 n2) (logior n1 (logior n2)))
	(define (logeqv . ints) (lognot (apply logxor ints)))

	;; from slib
	(define (logcount n)
	  (define bitwise-bit-count
	    (letrec ((logcnt (lambda (n tot)
			       (if (zero? n)
				   tot
				   (logcnt (quotient n 16)
					   (+ (vector-ref
					       '#(0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4)
					       (modulo n 16))
					      tot))))))
	      (lambda (n)
		(cond ((negative? n) (lognot (logcnt (lognot n) 0)))
		      ((positive? n) (logcnt n 0))
		      (else 0)))))
	  (cond ((negative? n) (bitwise-bit-count (lognot n)))
		(else (bitwise-bit-count n))))

	(define-constant boole-clr 0)
	(define-constant boole-set 1)
	(define-constant boole-1 2)
	(define-constant boole-2 3)
	(define-constant boole-c1 4)
	(define-constant boole-c2 5)
	(define-constant boole-and 6)
	(define-constant boole-ior 7)
	(define-constant boole-xor 8)
	(define-constant boole-eqv 9)
	(define-constant boole-nand 10)
	(define-constant boole-nor 11)
	(define-constant boole-andc1 12)
	(define-constant boole-andc2 13)
	(define-constant boole-orc1 14)
	(define-constant boole-orc2 15)

	(define (boole op int1 int2)
	  (cond
	    ((= op boole-clr)   0)
	    ((= op boole-set)   -1) ;; all ones -- "always 1" is misleading
	    ((= op boole-1)     int1)
	    ((= op boole-2)     int2)
	    ((= op boole-c1)    (lognot int1))
	    ((= op boole-c2)    (lognot int2))
	    ((= op boole-and)   (logand int1 int2))
	    ((= op boole-ior)   (logior int1 int2))
	    ((= op boole-xor)   (logxor int1 int2))
	    ((= op boole-eqv)   (logeqv int1 int2))
	    ((= op boole-nand)  (lognot (logand int1 int2)))
	    ((= op boole-nor)   (lognot (logior int1 int2)))
	    ((= op boole-andc1) (logand (lognot int1) int2))
	    ((= op boole-andc2) (logand int1 (lognot int2)))
	    ((= op boole-orc1)  (logior (lognot int1) int2))
	    ((= op boole-orc2)  (logior int1 (lognot int2)))))

	;; from Rick
	(define (byte siz pos)
	  ;; cache size, position and mask.
	  (list siz pos (ash (- (ash 1 siz) 1) pos)))

	(define byte-size car)
	(define byte-position cadr)
	(define byte-mask caddr)

	(define (ldb bytespec integer)
	  (ash (logand integer (byte-mask bytespec))
	       (- (byte-position bytespec))))

	(define (dpb integer bytespec into)
	  (logior (ash (logand integer (- (ash 1 (byte-size bytespec)) 1)) (byte-position bytespec))
		  (logand into (lognot (byte-mask bytespec)))))

	(define (ldb-test byte int) (not (zero? (ldb byte int))))
	(define (mask-field byte int) (logand int (dpb -1 byte 0)))
	(define (deposit-field byte spec int) (logior (logand byte (byte-mask spec)) (logand int (lognot (byte-mask spec)))))
	(define (scale-float x k) (* x (expt 2.0 k)))
	
	;; from clisp -- can't see any point to most of these
	(define-constant double-float-epsilon 1.1102230246251568e-16)
	(define-constant double-float-negative-epsilon 5.551115123125784e-17)
	(define-constant least-negative-double-float -2.2250738585072014e-308)
	(define-constant least-negative-long-float -5.676615526003731344e-646456994)
	(define-constant least-negative-normalized-double-float -2.2250738585072014e-308)
	(define-constant least-negative-normalized-long-float -5.676615526003731344e-646456994)
	(define-constant least-negative-normalized-short-float -1.1755e-38)
	(define-constant least-negative-normalized-single-float -1.1754944e-38)
	(define-constant least-negative-short-float -1.1755e-38)
	(define-constant least-negative-single-float -1.1754944e-38)
	(define-constant least-positive-double-float 2.2250738585072014e-308)
	(define-constant least-positive-long-float 5.676615526003731344e-646456994)
	(define-constant least-positive-normalized-double-float 2.2250738585072014e-308)
	(define-constant least-positive-normalized-long-float 5.676615526003731344e-646456994)
	(define-constant least-positive-normalized-short-float 1.1755e-38)
	(define-constant least-positive-normalized-single-float 1.1754944e-38)
	(define-constant least-positive-short-float 1.1755e-38)
	(define-constant least-positive-single-float 1.1754944e-38)
	(define-constant long-float-epsilon 5.4210108624275221706e-20)
	(define-constant long-float-negative-epsilon 2.7105054312137610853e-20)
	(define-constant most-negative-double-float -1.7976931348623157e308)
	;; most-negative-fixnum 
	(define-constant most-negative-long-float -8.8080652584198167656e646456992) 
	(define-constant most-negative-short-float -3.4028e38)
	(define-constant most-negative-single-float -3.4028235e38)
	(define-constant most-positive-double-float 1.7976931348623157e308)
	;; most-positive-fixnum 
	(define-constant most-positive-long-float 8.8080652584198167656e646456992)
	(define-constant most-positive-short-float 3.4028e38)
	(define-constant most-positive-single-float 3.4028235e38)
	(define-constant short-float-epsilon 7.6295e-6)
	(define-constant short-float-negative-epsilon 3.81476e-6)
	(define-constant single-float-epsilon 5.960465e-8)
	(define-constant single-float-negative-epsilon 2.9802326e-8)

	(define (lisp-implementation-type) "s7")
	(define lisp-implementation-version s7-version)
	(define (software-type) "s7")
	(define software-version s7-version)

	(define (machine-version)
	  (if (and (defined? 'file-exists?)
                   (file-exists? "/proc/cpuinfo"))
	      (call-with-input-file "/proc/cpuinfo"
		(lambda (cpufile)
		  (do ((line (read-line cpufile) (read-line cpufile)))
		      ((or (eof-object? line)
			   (string=? (substring line 0 10) "model name"))
		       (if (string? line)
			   (string-trim " " (substring line (+ 1 (position #\: line))))
			   "unknown")))))
	      "unknown"))
	
	;; = < <= > >= are the same, also min max + - * / lcm gcd exp expt log sqrt
	;; sin cos tan acos asin atan pi sinh cosh tanh asinh acosh atanh
	;; numerator denominator logior logxor logand ash integer-length random

	;; slightly different: floor ceiling truncate round and the ff cases thereof
	;; abs of complex -> magnitude
	(define (cl-abs x) (if (not (zero? (imag-part x))) (magnitude x) (abs x)))

	;; these actually return multiple values
	(define* (cl-floor x (divisor 1)) (floor (/ x divisor)))
	(define* (cl-ceiling x (divisor 1)) (ceiling (/ x divisor)))
	(define* (cl-truncate x (divisor 1)) (truncate (/ x divisor)))
	(define* (cl-round x (divisor 1)) (round (/ x divisor)))
	(define* (ffloor x divisor) (* 1.0 (cl-floor x divisor)))
	(define* (fceling x divisor) (* 1.0 (cl-ceiling x divisor)))
	(define* (ftruncate x divisor) (* 1.0 (cl-truncate x divisor)))
	(define* (fround x divisor) (* 1.0 (cl-round x divisor)))
       
	(define (/= . args) 
	  (if (null? (cdr args))
	      #t 
	      (if (member (car args) (cdr args))
		  #f
		  (apply /= (cdr args)))))

	(define (1+ x) (+ x 1))
	(define (1- x) (- x 1))
	(define (isqrt x) (floor (sqrt x)))
	(define phase angle)
	(define* (complex rl (im 0.0)) (make-rectangular rl im))
	(define (signum x) (if (zerop x) x (/ x (abs x))))
	(define (cis x) (exp (make-rectangular 0.0 x)))


	;; -------- characters

	(define char-code-limit 256)
	(define alpha-char-p char-alphabetic?)
	(define upper-case-p char-upper-case?)
	(define lower-case-p char-lower-case?)
	(define* (digit-char-p c (radix 10)) (string->number (string c) radix))
	(define (alphanumericp c) (or (char-alphabetic? c) (char-numeric? c)))

	(define* (char= . args) (or (< (length args) 2) (apply char=? args)))
	(define* (char< . args) (or (< (length args) 2) (apply char<? args)))
	(define* (char<= . args) (or (< (length args) 2) (apply char<=? args)))
	(define* (char> . args) (or (< (length args) 2) (apply char>? args)))
	(define* (char>= . args) (or (< (length args) 2) (apply char>=? args)))
	(define* (char-equal . args) (or (< (length args) 2) (apply char-ci=? args)))
	(define* (char-lessp . args) (or (< (length args) 2) (apply char-ci<? args)))
	(define* (char-greaterp . args) (or (< (length args) 2) (apply char-ci>? args)))
	(define* (char-not-lessp . args) (or (< (length args) 2) (apply char-ci>=? args)))
	(define* (char-not-greaterp . args) (or (< (length args) 2) (apply char-ci<=? args)))

	(define (char/= . args) 
	  (if (null? (cdr args))
	      #t 
	      (if (member (car args) (cdr args))
		  #f
		  (apply char/= (cdr args)))))

	(define (char-not-equal . args) 
	  (if (null? (cdr args))
	      #t 
	      (if (or (member (char-upcase (car args)) (cdr args))
		      (member (char-downcase (car args)) (cdr args)))
		  #f
		  (apply char-not-equal (cdr args)))))

	(define char-code char->integer)
	(define code-char integer->char)

	(define (character c) 
	  (if (char? c) 
	      c 
	      (if (integer? c)
		  (integer->char c)
		  (if (string? c)
		      (c 0)
		      (if (symbol? c)
			  ((symbol->string c) 0))))))

	;; char-upcase and char-downcase are ok
	(define char-int char->integer)
	(define int-char integer->char)

	(define* (digit-char w (radix 10))
	  (let ((str (number->string w radix)))
	    (and str (= (length str) 1) (str 0))))

	(define (both-case-p c) "unimplemented")
	(define (standard-char-p c) "unimplemented")
	(define (char-name c) "unimplemented")
	(define (name-char s) "unimplemented")

	;; --------

	(define terpri newline)


	;; -------- types

	(define vectorp vector?)
	(define simple-vector-p vector?)
	(define symbolp symbol?)
	(define (atom obj) (not (pair? obj)))
	(define consp pair?)
	(define (null obj) (or (not obj) (null? obj)))
	(define (listp obj) (or (null? obj) (pair? obj)))
	(define numberp number?)
	(define integerp integer?)
	(define rationalp rational?)
	(define (floatp l) (and (number? l) (not (rational? l)) (zero? (imag-part l)))) ; clisp
	(define (complexp l) (and (complex? l) (not (real? l))))
	(define realp real?)
	(define characterp char?)
	(define stringp string?)
	(define simple-string-p string?)
	(define arrayp vector?)
	(define simple-bit-vector-p vector?)
	(define keywordp keyword?)
	(define functionp procedure?)

	(define-constant t #t)
	(define-constant nil '())

	(define eq eq?)
	(define eql eqv?)
	(define equal equal?)

	(define (equalp x y)
	  (or (equal x y)
	      (and (char? x) (char? y) (char-ci=? x y))
	      (and (number? x) (number? y) (= x y))
	      (and (string? x) (string? y) (string-ci=? x y))))

	(define symbol-value symbol->value)
	(define symbol-function symbol->value)
	(define fdefinition symbol->value)
	(define boundp defined?)
	(define fboundp defined?)
	(define (funcall fn . arguments) (apply fn arguments))
	(define-constant call-arguments-limit 65536)

	(define (identity x) x)


	;; -------- sequences

	(define* (count-if predicate sequence from-end (start 0) end (key identity))
	  (let* ((counts 0)
		 (len (length sequence))
		 (nd (or (and (number? end) end) len))) ; up to but not including end
	    (if (< nd start)
		(error "count-if :start ~A is greater than ~A ~A" start (if end ":end" "length") nd))
	    (if (not from-end)
		(do ((i start (+ i 1)))
		    ((= i nd))
		  (if (predicate (key (sequence i)))
		      (set! counts (+ counts 1))))
		(do ((i (- nd 1) (- i 1)))
		    ((< i start))
		  (if (predicate (key (sequence i)))
		      (set! counts (+ counts 1)))))
		counts))

	(define* (count-if-not predicate sequence from-end (start 0) end (key identity))
	  (count-if (lambda (obj) (not (predicate obj))) sequence from-end start end key))

	(define* (count item sequence from-end (test eql) (start 0) end (key identity))
	  (count-if (lambda (arg) (test item arg)) sequence from-end start end key))

	(define* (find-if predicate sequence from-end (start 0) end (key identity))
	  (let* ((len (length sequence))
		 (nd (or (and (number? end) end) len))) ; up to but not including end
	    (if (< nd start)
		(error "~A :start ~A is greater than ~A ~A" __func__ start (if end ":end" "length") nd))
	    (call-with-exit
	     (lambda (return)
	       (if (not from-end)
		   (do ((i start (+ i 1)))
		       ((= i nd) #f)
		     (if (predicate (key (sequence i)))
			 (return (sequence i))))
		   (do ((i (- nd 1) (- i 1)))
		       ((< i start) #f)
		     (if (predicate (key (sequence i)))
			 (return (sequence i)))))))))

	(define* (find-if-not predicate sequence from-end (start 0) end (key identity))
	  (find-if (lambda (obj) (not (predicate obj))) sequence from-end start end key))

	(define* (find item sequence from-end (test eql) (start 0) end (key identity))
	  (find-if (lambda (arg) (test item arg)) sequence from-end start end key))
	     
	(define* (position-if predicate sequence from-end (start 0) end (key identity))
	  (let* ((len (length sequence))
		 (nd (or (and (number? end) end) len))) ; up to but not including end
	    (if (< nd start)
		(error "~A :start ~A is greater than ~A ~A" __func__ start (if end ":end" "length") nd))
	    (call-with-exit
	     (lambda (return)
	       (if (not from-end)
		   (do ((i start (+ i 1)))
		       ((= i nd) #f)
		     (if (predicate (key (sequence i)))
			 (return i)))
		   (do ((i (- nd 1) (- i 1)))
		       ((< i start) #f)
		     (if (predicate (key (sequence i)))
			 (return i))))))))

	(define* (position-if-not predicate sequence from-end (start 0) end (key identity))
	  (position-if (lambda (obj) (not (predicate obj))) sequence from-end start end key))

	(define* (position item sequence from-end (test eql) (start 0) end (key identity))
	  (position-if (lambda (arg) (test item arg)) sequence from-end start end key))


	(define* (nsubstitute-if new-item test sequence from-end (start 0) end count (key identity))
	  (if (and (number? count)
		   (not (positive? count)))
	      sequence
	      (let* ((len (length sequence))
		     (nd (or (and (number? end) end) len))) ; up to but not including end
		(if (< nd start)
		    (error "~A :start ~A is greater than ~A ~A" __func__ start (if end ":end" "length") nd))
		(let ((cur-count 0))
		  (if (not (number? count))
		      (set! count len))
		  (if (not from-end)
		      (do ((i start (+ i 1)))
			  ((or (= cur-count count)
			       (= i nd))
			   sequence)
			(if (test (key (sequence i)))
			    (begin
			      (set! cur-count (+ cur-count 1))
			      (set! (sequence i) new-item))))
		      (do ((i (- nd 1) (- i 1)))
			  ((or (= cur-count count)
			       (< i start))
			   sequence)
			(if (test (key (sequence i)))
			    (begin
			      (set! cur-count (+ cur-count 1))
			      (set! (sequence i) new-item)))))))))

	(define* (nsubstitute-if-not new-item test sequence from-end (start 0) end count (key identity))
	  (nsubstitute-if new-item (lambda (obj) (not (test obj))) sequence from-end start end count key))

	(define* (nsubstitute new-item old-item sequence from-end (test eql) (start 0) end count (key identity))
	  (nsubstitute-if new-item (lambda (arg) (test old-item arg)) sequence from-end start end count key))

	(define* (substitute-if new-item test sequence from-end (start 0) end count (key identity))
	  (nsubstitute-if new-item test (copy sequence) from-end start end count key))

	(define* (substitute-if-not new-item test sequence from-end (start 0) end count (key identity))
	  (substitute-if new-item (lambda (obj) (not (test obj))) (copy sequence) from-end start end count key))

	(define* (substitute new-item old-item sequence from-end (test eql) (start 0) end count (key identity))
	  (nsubstitute new-item old-item (copy sequence) from-end test start end count key))

	(define* (reduce function sequence from-end (start 0) end initial-value (key identity))
	  (let* ((slen (length sequence))
		 (nd (or (and (number? end) end) slen))
		 (len (min slen (- nd start))))
	    (if (< nd start)
		(error "~A :start ~A is greater than ~A ~A" __func__ start (if end ":end" "length") nd))
	    (if (not (positive? len))
		(or initial-value
		    (function))
		(if (and (= len 1)
			 (not initial-value))
		    (sequence start)
		    (if (and (not from-end) (not (null? from-end)))
			(let* ((first-arg (or initial-value (key (sequence start))))
			       (second-arg (if initial-value (key (sequence start)) (key (sequence (+ start 1)))))
			       (val (function first-arg second-arg)))
			  (do ((i (if initial-value (+ start 1) (+ start 2)) (+ i 1)))
			      ((= i nd) val)
			    (set! val (function val (key (sequence i))))))
			(let* ((second-arg (or initial-value (key (sequence (- nd 1)))))
			       (first-arg (if initial-value (key (sequence (- nd 1))) (key (sequence (- nd 2)))))
			       (val (function first-arg second-arg)))
			  (do ((i (if initial-value (- nd 2) (- nd 3)) (- i 1)))
			      ((< i start) val)
			    (set! val (function (key (sequence i)) val)))))))))

	(define (nreverse sequence)
	  (let ((len (length sequence)))
	    (do ((i 0 (+ i 1))
		 (j (- len 1) (- j 1)))
		((>= i j) sequence)
	      (let ((tmp (sequence i)))
		(set! (sequence i) (sequence j))
		(set! (sequence j) tmp)))))

	(define (cl-reverse sequence)
	  (nreverse (copy sequence)))
	
	(define copy-seq copy)
	(define (complement fn) (lambda args (not (apply fn args))))
	(define (elt sequence index) (sequence index))
	;; length is ok

	(define* (some predicate . sequences)
	  (call-with-exit
	   (lambda (return)
		     (apply for-each 
		      (lambda args
			(let ((val (apply predicate args)))
			  (if val (return val))))
		      sequences)
		     #f)))

	(define* (notany predicate . sequences)
	  (not (apply some predicate sequences)))

	(define* (every predicate . sequences)
	  (call-with-exit
	   (lambda (return)
		     (apply for-each 
		      (lambda args
			(if (not (apply predicate args))
			    (return #f)))
		      sequences)
		     #t)))

	(define* (notevery predicate . sequences)
	  (not (apply every predicate sequences)))

	(define* (cl-fill sequence item (start 0) end) ; actuall "fill" doesn't collide, but it's confusing
	  (let ((nd (or (and (not (null? end)) end)
			(length sequence))))
	    (if (and (= start 0)
		     (= nd (length sequence)))
		(fill! sequence item)
		(do ((i start (+ i 1)))
		    ((= i nd))
		  (set! (sequence i) item)))
	    sequence))

	;; many of the sequence functions return a different length sequence, but
	;;   for user-defined sequence types, we can't use the 'type kludge (or
	;;   at least it's ugly), so we need either (make obj size initial-value)
	;;   where obj is a representative of the desired type, or another
	;;   arg to copy giving the new object's size.  For now, I'll cobble up
	;;   something explicit.
	;;
	;; perhaps the extended type could give its type symbol as well as the make function?
	;; 'vct and make-vct etc

	(define (make obj size)
	  (cond ((vector? obj)     (make-vector size))
		((list? obj)       (make-list size))
		((string? obj)     (make-string size))
		((hash-table? obj) (make-hash-table size)))) ; does this make any sense?

	(define* (make-sequence type size initial-element)
	  (case type 
	    ((vector bit-vector simple-vector) (make-vector size initial-element))
	    ((hash-table) (make-hash-table size))
	    ((string) (cl-make-string size (or initial-element #\null))) ; not #f!
	    ((list) (cl-make-list size initial-element))
            (else '())))

	(define (cl-map type func . lists)
	  (let* ((vals (apply mapcar func lists))
		 (len (length vals)))
	    (let ((obj (make-sequence (or type 'list) len)))
	      (if (> (length obj) 0)
		  (do ((i 0 (+ i 1)))
		      ((= i len))
		    (set! (obj i) (vals i))))
	      obj)))

	(define* (subseq sequence start end)
	  (let* ((len (length sequence))
		 (nd (or (and (number? end) end) len))
		 (size (- nd start))
		 (obj (make sequence size)))
	    (do ((i start (+ i 1))
		 (j 0 (+ j 1)))
		((= i nd) obj)
	      (set! (obj j) (sequence i)))))
	
	(define (concatenate type . sequences)
	  (let* ((len (apply + (map length sequences)))
		 (new-obj (make-sequence type len))
		 (ctr 0))
	    (for-each
	     (lambda (sequence)
	       (for-each
		(lambda (obj)
		  (set! (new-obj ctr) obj)
		  (set! ctr (+ ctr 1)))
		sequence))
	     sequences)
	    new-obj))

	;; :(concatenate 'list "hiho" '#(1 2)) -> (#\h #\i #\h #\o 1 2)

	(define* (replace seq1 seq2 (start1 0) end1 (start2 0) end2)
	  (let* ((len1 (length seq1))
		 (len2 (length seq2))
		 (nd1 (or (and (number? end1) end1) len1))
		 (nd2 (or (and (number? end2) end2) len2)))
	    (if (and (eq? seq1 seq2)
		     (> start1 start2))
		(let ((offset (- start1 start2)))
		  (do ((i (- nd1 1) (- i 1)))
		      ((< i start1) seq1)
		    (set! (seq1 i) (seq1 (- i offset)))))
		(do ((i start1 (+ i 1))
		     (j start2 (+ j 1)))
		    ((or (= i nd1)
			 (= j nd2))
		     seq1)
		  (set! (seq1 i) (seq2 j))))))
	
	(define* (remove-if predicate sequence from-end (start 0) end count (key identity))
	  (let* ((len (length sequence))
		 (nd (or (and (number? end) end) len))
		 (num (if (number? count) count len))
		 (changed 0))
	    (if (not (positive? num))
		sequence
		(let ((result '()))
		  (if (null from-end)
		      (do ((i 0 (+ i 1)))
			  ((= i len))
			(if (or (< i start)
				(>= i nd)
				(>= changed num)
				(not (predicate (key (sequence i)))))
			    (set! result (cons (sequence i) result))
			    (set! changed (+ changed 1))))
		      (do ((i (- len 1) (- i 1)))
			  ((< i 0))
			(if (or (< i start)
				(>= i nd)
				(>= changed num)
				(not (predicate (key (sequence i)))))
			    (set! result (cons (sequence i) result))
			    (set! changed (+ changed 1)))))		    
		  (let* ((len (length result))
			 (obj (make sequence len))
			 (vals (if (null from-end) (reverse result) result)))
		    (do ((i 0 (+ i 1)))
			((= i len))
		      (set! (obj i) (vals i)))
		    obj)))))
	
	(define* (remove-if-not predicate sequence from-end (start 0) end count (key identity))
	  (remove-if (lambda (obj) (not (predicate obj))) sequence from-end start end count key))
	
	(define* (remove item sequence from-end (test eql) (start 0) end count (key identity))
	  (remove-if (lambda (arg) (test item arg)) sequence from-end start end count key))

	(define-macro* (delete-if predicate sequence from-end (start 0) end count (key identity))
	  `(let ((obj (remove-if ,predicate ,sequence ,from-end ,start ,end ,count ,key)))
	     (if (symbol? ',sequence)
		 (set! ,sequence obj))
	     obj))
	
	(define-macro* (delete-if-not predicate sequence from-end (start 0) end count (key identity))
	  `(let ((obj (remove-if-not ,predicate ,sequence ,from-end ,start ,end ,count ,key)))
	     (if (symbol? ',sequence)
		 (set! ,sequence obj))
	     obj))
	
	(define-macro* (delete item sequence from-end (test eql) (start 0) end count (key identity))
	  `(let ((obj (remove ,item ,sequence ,from-end ,test ,start ,end ,count ,key)))
	     (if (symbol? ',sequence)
		 (set! ,sequence obj))
	     obj))
	
	(define* (remove-duplicates sequence from-end (test eql) (start 0) end (key identity))
	  (let* ((result '())
		 (start-seq (+ start 1))
		 (len (length sequence))
		 (nd (if (number? end) end len)))
	    (do ((i start (+ i 1)))
		((= i nd))
	      (let* ((orig-obj (sequence i))
		     (obj (key orig-obj)))
		(if (null from-end)
		    (begin
		      (if (not (find obj sequence :start start-seq :end nd :test test :key key))
			  (set! result (cons orig-obj result)))
		      (set! start-seq (+ start-seq 1)))
		    (if (not (find obj result :test test :key key))
			(set! result (cons orig-obj result))))))
	    (let* ((res (reverse result))
		   (new-len (+ (length result) start (- len nd)))
		   (new-seq (make sequence new-len)))
	      (let ((n 0))
		(do ((i 0 (+ i 1)))
		    ((= i len) new-seq)
		  (if (or (< i start)
			  (>= i nd))
		      (begin
			(set! (new-seq n) (sequence i))
			(set! n (+ n 1)))
		      (if (not (null? res))
			  (begin
			    (set! (new-seq n) (car res))
			    (set! res (cdr res))
			    (set! n (+ n 1))))))))))
	
	(define-macro* (delete-duplicates sequence from-end (test eql) (start 0) end (key identity))
	  `(let ((obj (remove-duplicates ,sequence ,from-end ,test ,start ,end ,key)))
	     (if (symbol? ,sequence)
		 (set! ,sequence obj))
	     obj))
	
	(define* (merge result-type seq1 seq2 predicate (key identity))
	  (let* ((len1 (length seq1))
		 (len2 (length seq2))
		 (size (+ len1 len2))
		 (obj (make-sequence result-type size))
		 (i 0)
		 (j 0))
	    (do ((n 0 (+ n 1)))
		((or (= i len1)
		     (= j len2))
		 (if (< i len1)
		     (do ((k i (+ k 1)))
			 ((= k len1) obj)
		       (set! (obj n) (seq1 k))
		       (set! n (+ n 1)))
		     (if (< j len2)
			 (do ((k j (+ k 1)))
			     ((= k len2) obj)
			   (set! (obj n) (seq2 k))
			   (set! n (+ n 1)))
			 obj)))
	      (if (null (predicate (key (seq1 i)) (key (seq2 j))))
		  (begin
		    (set! (obj n) (seq2 j))
		    (set! j (+ j 1)))
		  (begin
		    (set! (obj n) (seq1 i))
		    (set! i (+ i 1)))))))
	
	(define* (search seq1 seq2 from-end (test eql) (key identity) (start1 0) (start2 0) end1 end2)
	  (let* ((len1 (length seq1))
		 (len2 (length seq2))
		 (nd1 (or (and (number? end1) end1) len1))
		 (nd2 (or (and (number? end2) end2) len2)))
	    (set! len1 (min len1 (- nd1 start1)))
	    (set! len2 (min len2 (- nd2 start2)))
	    (if (or (= len2 0)
		    (> len1 len2))
		'()
		(call-with-exit
		 (lambda (return)
		   (if (or (not from-end) (null? from-end))
		       (do ((i start2 (+ i 1)))
			   ((> i (- nd2 len1)) '())
			 (do ((j start1 (+ j 1))
			      (k i (+ k 1)))
			     ((or (= j nd1)
				  (not (test (key (seq1 j)) (key (seq2 k)))))
			      (if (= j nd1)
				  (return i)))))
		       (do ((i (- nd2 len1) (- i 1)))
			   ((< i start2) '())
			 (do ((j start1 (+ j 1))
			      (k i (+ k 1)))
			     ((or (= j nd1)
				  (not (test (key (seq1 j)) (key (seq2 k)))))
			      (if (= j nd1)
				  (return i)))))))))))
	
	(define* (mismatch seq1 seq2 from-end (test eql) (key identity) (start1 0) (start2 0) end1 end2)
	  (let* ((nd1 (or (and (number? end1) end1) (length seq1)))
		 (nd2 (or (and (number? end2) end2) (length seq2))))
	    (if (not from-end)
		(do ((i start1 (+ i 1))
		     (j start2 (+ j 1)))
		    ((or (= i nd1)
			 (= j nd2)
			 (not (test (key (seq1 i)) (key (seq2 j)))))
		     (if (and (= i nd1) (= j nd2))
			 '()
			 i)))
		(do ((i (- nd1 1) (- i 1))
		     (j (- nd2 1) (- j 1)))
		    ((or (< i start1)
			 (< j start2)
			 (not (test (key (seq1 i)) (key (seq2 j)))))
		     (if (and (< i start1) (< j start2))
			 '()
			 (+ i 1)))))))
	
	
	;; -------- strings
	
	(define char string-ref)
	(define schar string-ref)
	(define* (cl-make-string size (initial-element #\null)) (make-string size initial-element))
	
	(define (cl-string x)
	  (if (string? x) x
	      (if (char? x)
		  (string x)
		  (if (symbol? x) (symbol->string x)
		      (error "string ~A?" x)))))
	
	(define* (string= str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2))))
	    (if (and (not end1) (not end2) (= start1 0) (= start2 0))
		(string=? str1 str2)
		(string=? (subseq str1 start1 nd1)
			  (subseq str2 start2 nd2)))))
	
	(define* (string-equal str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2))))
	    (if (and (not end1) (not end2) (= start1 0) (= start2 0))
		(string-ci=? str1 str2)
		(string-ci=? (subseq str1 start1 nd1)
			     (subseq str2 start2 nd2)))))
	
	(define (string-prefixes-equal str1 str2 start1 nd1 start2 nd2)
	  (do ((i start1 (+ i 1))
	       (j start2 (+ j 1)))
	      ((or (= i nd1)
		   (= j nd2)
		   (not (char=? (str1 i) (str2 j))))
	       i)))
	
	(define (string-prefixes-equal-ci str1 str2 start1 nd1 start2 nd2)
	  (do ((i start1 (+ i 1))
	       (j start2 (+ j 1)))
	      ((or (= i nd1)
		   (= j nd2)
		   (not (char-ci=? (str1 i) (str2 j))))
	       i)))
	
	(define* (string< str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (string<? str1 str2)
			  (string<? (subseq str1 start1 nd1)
				    (subseq str2 start2 nd2)))))
	    (and val (string-prefixes-equal str1 str2 start1 nd1 start2 nd2))))

	(define* (string-lessp str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (string-ci<? str1 str2)
			  (string-ci<? (subseq str1 start1 nd1)
				       (subseq str2 start2 nd2)))))
	    (and val (string-prefixes-equal-ci str1 str2 start1 nd1 start2 nd2))))

	(define* (string<= str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (string<=? str1 str2)
			  (string<=? (subseq str1 start1 nd1)
				     (subseq str2 start2 nd2)))))
	    (and val (string-prefixes-equal str1 str2 start1 nd1 start2 nd2))))

	(define* (string-not-greaterp str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (string-ci<=? str1 str2)
			  (string-ci<=? (subseq str1 start1 nd1)
					(subseq str2 start2 nd2)))))
	    (and val (string-prefixes-equal-ci str1 str2 start1 nd1 start2 nd2))))

	(define* (string> str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (string>? str1 str2)
			  (string>? (subseq str1 start1 nd1)
				    (subseq str2 start2 nd2)))))
	    (and val (string-prefixes-equal str1 str2 start1 nd1 start2 nd2))))

	(define* (string-greaterp str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (string-ci>? str1 str2)
			  (string-ci>? (subseq str1 start1 nd1)
				       (subseq str2 start2 nd2)))))
	    (and val (string-prefixes-equal-ci str1 str2 start1 nd1 start2 nd2))))

	(define* (string>= str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (string>=? str1 str2)
			  (string>=? (subseq str1 start1 nd1)
				     (subseq str2 start2 nd2)))))
	    (and val (string-prefixes-equal str1 str2 start1 nd1 start2 nd2))))

	(define* (string-not-lessp str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (string-ci>=? str1 str2)
			  (string-ci>=? (subseq str1 start1 nd1)
					(subseq str2 start2 nd2)))))
	    (and val (string-prefixes-equal-ci str1 str2 start1 nd1 start2 nd2))))

	(define* (string/= str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (not (string=? str1 str2))
			  (not (string=? (subseq str1 start1 nd1)
					 (subseq str2 start2 nd2))))))
	    (and val (string-prefixes-equal str1 str2 start1 nd1 start2 nd2))))
	
	(define* (string-not-equal str-1 str-2 (start1 0) end1 (start2 0) end2)
	  (let* ((str1 (cl-string str-1))
		 (str2 (cl-string str-2))
		 (nd1 (if (number? end1) end1 (length str1)))
		 (nd2 (if (number? end2) end2 (length str2)))
		 (val (if (and (not end1) (not end2) (= start1 0) (= start2 0))
			  (not (string-ci=? str1 str2))
			  (not (string-ci=? (subseq str1 start1 nd1)
					    (subseq str2 start2 nd2))))))
	    (and val (string-prefixes-equal-ci str1 str2 start1 nd1 start2 nd2))))

	(define (string-left-trim bag str-1)
	  (let ((str (cl-string str-1)))
	    (if (string? bag) (set! bag (string->list bag)))
	    (let ((len (length str)))
	      (do ((i 0 (+ i 1)))
		  ((or (= i len)
		       (not (member (str i) bag)))
		   (if (= i 0)
		       str
		       (subseq str i)))))))
		 
	(define (string-right-trim bag str-1)
	  (let ((str (cl-string str-1)))
	    (if (string? bag) (set! bag (string->list bag)))
	    (let ((len (length str)))
	      (do ((i (- len 1) (- i 1)))
		  ((or (< i 0)
		       (not (member (str i) bag)))
		   (if (= i (- len 1))
		       str
		       (subseq str 0 (+ i 1))))))))
		 
	(define (string-trim bag str)
	  (string-right-trim bag (string-left-trim bag str)))

	(define* (nstring-upcase str (start 0) end)
	  (let ((nd (if (number? end) end (length str))))
	    (do ((i start (+ i 1)))
		((= i nd) str)
	      (set! (str i) (char-upcase (str i))))))

	(define* (string-upcase str-1 (start 0) end)
	  (let ((str (cl-string str-1)))
	    (nstring-upcase (copy str) start end)))

	(define* (nstring-downcase str (start 0) end)
	  (let ((nd (if (number? end) end (length str))))
	    (do ((i start (+ i 1)))
		((= i nd) str)
	      (set! (str i) (char-downcase (str i))))))

	(define* (string-downcase str-1 (start 0) end)
	  (let ((str (cl-string str-1)))
	    (nstring-downcase (copy str) start end)))

	(define* (nstring-capitalize str-1 (start 0) end)
	  (define (alpha? c) 
	    (or (char-alphabetic? c) 
		(char-numeric? c)))
	  (let ((str (cl-string str-1)))
	    (let ((nd (if (number? end) end (length str))))
	      (do ((i start (+ i 1)))
		  ((= i nd) str)
		(if (alpha? (str i))
		    (if (or (= i 0)
			    (not (alpha? (str (- i 1)))))
			(set! (str i) (char-upcase (str i)))
			(set! (str i) (char-downcase (str i)))))))))

	(define* (string-capitalize str-1 (start 0) end)
	  (let ((str (cl-string str-1)))
	    (nstring-capitalize (copy str) start end)))


	;; -------- vectors

	;; vector is ok

	(define svref vector-ref)
	(define aref vector-ref)
        (define array-dimensions vector-dimensions) 
	(define array-total-size vector-length)
        (define (array-dimension array num) (list-ref (vector-dimensions array) num))

	(define-constant array-dimension-limit 16777215)
	(define-constant array-rank-limit 4096)
	(define-constant array-total-size-limit 16777215)

	(define* (make-array dimensions element-type initial-element initial-contents adjustable fill-pointer displaced-to displaced-index-offset)
	  (if (eq? element-type 'character)
	      (or (and initial-contents
		       (string-copy initial-contents))
		  (cl-make-string dimensions initial-element))
	      (make-vector (or dimensions 1) initial-element)))

	(define (array-in-bounds-p array . subscripts)
	  (define (in-bounds dims subs)
	    (or (null? subs)
		(null? dims)
		(and (< (car subs) (car dims))
		     (in-bounds (cdr dims) (cdr subs)))))
	  (in-bounds (vector-dimensions array) subscripts))

	(define (row-major-index array . subscripts) 
	  (apply + (maplist (lambda (x y)
			      (* (car x) (apply * (cdr y))))
			    subscripts
			    (vector-dimensions array))))


	;; -------- defstruct

	(defmacro defstruct (struct-name . fields)
	  (let* ((name (if (list? struct-name) (car struct-name) struct-name))
		 (sname (if (string? name) name (symbol->string name)))
		 
		 (fsname (if (list? struct-name)
			     (let ((cname (assoc :conc-name (cdr struct-name))))
			       (if cname 
				   (symbol->string (cadr cname))
				   sname))
			     sname))
		 
		 (make-name (if (list? struct-name)
				(let ((cname (assoc :constructor (cdr struct-name))))
				  (if cname 
				      (cadr cname)
				      (string->symbol (string-append "make-" sname))))
				(string->symbol (string-append "make-" sname))))
		 
		 (copy-name (if (list? struct-name)
				(let ((cname (assoc :copier (cdr struct-name))))
				  (if cname 
				      (cadr cname)
				      (string->symbol (string-append "copy-" sname))))
				(string->symbol (string-append "copy-" sname))))
		 
		 (field-names (map (lambda (n)
				     (symbol->string (if (list? n) (car n) n)))
				   fields))
		 
		 (field-types (map (lambda (field)
				     (if (list? field)
					 (apply (lambda* (val type read-only) type) (cdr field))
					 #f))
				   fields))
		 
		 (field-read-onlys (map (lambda (field)
					  (if (list? field)
					      (apply (lambda* (val type read-only) read-only) (cdr field))
					      #f))
					fields)))
	    `(begin
	       
	       (define ,(string->symbol (string-append sname "?"))
		 (lambda (obj)
		   (and (vector? obj)
			(eq? (obj 0) ',(string->symbol sname)))))
	       
	       (define* (,make-name
			 ,@(map (lambda (n)
				  (if (and (list? n)
					   (>= (length n) 2))
				      (list (car n) (cadr n))
				      (list n #f)))
				fields))
		 (vector ',(string->symbol sname) ,@(map string->symbol field-names)))
	       
	       (define ,copy-name copy)
	       
	       ,@(map (let ((ctr 1))
			(lambda (n type read-only)
			  (let ((val (if read-only
					 `(define ,(string->symbol (string-append fsname "-" n))
					    (lambda (arg) (arg ,ctr)))
					 `(define ,(string->symbol (string-append fsname "-" n))
					    (make-procedure-with-setter 
					     (lambda (arg) (arg ,ctr)) 
					     (lambda (arg val) (set! (arg ,ctr) val)))))))
			    (set! ctr (+ 1 ctr))
			    val)))
		      field-names field-types field-read-onlys))))
	
	;; not yet implemented: :print-function :include :named :type :initial-offset
	;;   also the explicit constructor business

	(define-macro (enum . args) ; (enum zero one two)
	  `(begin
	     ,@(let ((names '()))
		 (do ((arg args (cdr arg))
		      (i 0 (+ i 1)))
		     ((null? arg) names)
		   (set! names (cons
				`(define ,(car arg) ,i)
				names))))))

	(define-macro (let*-values vals . body)
	  (let ((args '())
		(exprs '()))
	    (for-each
	     (lambda (arg+expr)
	       (set! args (cons (car arg+expr) args))
	       (set! exprs (cons (cadr arg+expr) exprs)))
	     vals)
	    (let ((form `((lambda ,(car args) ,@body) ,(car exprs))))
	      (if (not (null? (cdr args)))
		  (for-each
		   (lambda (arg expr)
		     (set! form `((lambda ,arg ,form) ,expr)))
		   (cdr args)
		   (cdr exprs)))
	      form)))

        (let ()

          ;; this is the nbody computer shootout benchmark taken from mzscheme
          ;; if we were serious about benchmarks, this could use run.

	  (define +days-per-year+ 365.24)
	  (define +solar-mass+ (* 4 pi pi))
	  (defstruct body x y z vx vy vz mass)
	  
	  (define *sun*
	    (make-body 0.0 0.0 0.0 0.0 0.0 0.0 +solar-mass+))
	  
	  (define *jupiter*
	    (make-body 4.84143144246472090
		       -1.16032004402742839
		       -1.03622044471123109e-1
		       (* 1.66007664274403694e-3 +days-per-year+)
		       (* 7.69901118419740425e-3 +days-per-year+)
		       (* -6.90460016972063023e-5 +days-per-year+)
		       (* 9.54791938424326609e-4 +solar-mass+)))
	  
	  (define *saturn*
	    (make-body 8.34336671824457987
		       4.12479856412430479
		       -4.03523417114321381e-1
		       (* -2.76742510726862411e-3 +days-per-year+)
		       (* 4.99852801234917238e-3 +days-per-year+)
		       (* 2.30417297573763929e-5 +days-per-year+)
		       (* 2.85885980666130812e-4 +solar-mass+)))
	  
	  (define *uranus*
	    (make-body 1.28943695621391310e1
		       -1.51111514016986312e1
		       -2.23307578892655734e-1
		       (* 2.96460137564761618e-03 +days-per-year+)
		       (* 2.37847173959480950e-03 +days-per-year+)
		       (* -2.96589568540237556e-05 +days-per-year+)
		       (*  4.36624404335156298e-05 +solar-mass+)))
	  
	  (define *neptune*
	    (make-body 1.53796971148509165e+01
		       -2.59193146099879641e+01
		       1.79258772950371181e-01
		       (* 2.68067772490389322e-03 +days-per-year+)
		       (* 1.62824170038242295e-03 +days-per-year+)
		       (* -9.51592254519715870e-05 +days-per-year+)
		       (* 5.15138902046611451e-05 +solar-mass+)))
	  
	  (define (offset-momentum system)
	    (let loop-i ((i system) (px 0.0) (py 0.0) (pz 0.0))
	      (if (null? i)
		  (begin
		    (set! (body-vx (car system)) (/ (- px) +solar-mass+))
		    (set! (body-vy (car system)) (/ (- py) +solar-mass+))
		    (set! (body-vz (car system)) (/ (- pz) +solar-mass+)))
		  (loop-i (cdr i)
			  (+ px (* (body-vx (car i)) (body-mass (car i))))
			  (+ py (* (body-vy (car i)) (body-mass (car i))))
			  (+ pz (* (body-vz (car i)) (body-mass (car i))))))))
	  
	  (define (energy system)
	    (let loop-o ((o system) (e 0.0))
	      (if (null? o)
		  e
		  (let ((e (+ e (* 0.5 (body-mass (car o))
				   (+ (* (body-vx (car o)) (body-vx (car o)))
				      (* (body-vy (car o)) (body-vy (car o)))
				      (* (body-vz (car o)) (body-vz (car o))))))))
		    (let loop-i ((i (cdr o)) (e e))
		      (if (null? i)
			  (loop-o (cdr o) e)
			  (let* ((dx (- (body-x (car o)) (body-x (car i))))
				 (dy (- (body-y (car o)) (body-y (car i))))
				 (dz (- (body-z (car o)) (body-z (car i))))
				 (distance (sqrt (+ (* dx dx) (* dy dy) (* dz dz)))))
			    (let ((e  (- e (/ (* (body-mass (car o)) (body-mass (car i))) distance))))
			      (loop-i (cdr i) e)))))))))
	  
	  (define (advance system dt)
	    (let loop-o ((o system))
	      (unless (null? o)
		      (let loop-i ((i (cdr o)))
			(unless (null? i)
				(let* ((o1 (car o))
				       (i1 (car i))
				       (dx (- (body-x o1) (body-x i1)))
				       (dy (- (body-y o1) (body-y i1)))
				       (dz (- (body-z o1) (body-z i1)))
				       (distance (sqrt (+ (* dx dx) (* dy dy) (* dz dz))))
				       (mag (/ dt (* distance distance distance)))
				       (dxmag (* dx mag))
				       (dymag (* dy mag))
				       (dzmag (* dz mag))
				       (om (body-mass o1))
				       (im (body-mass i1)))
				  (set! (body-vx o1) (- (body-vx o1) (* dxmag im)))
				  (set! (body-vy o1) (- (body-vy o1) (* dymag im)))
				  (set! (body-vz o1) (- (body-vz o1) (* dzmag im)))
				  (set! (body-vx i1) (+ (body-vx i1) (* dxmag om)))
				  (set! (body-vy i1) (+ (body-vy i1) (* dymag om)))
				  (set! (body-vz i1) (+ (body-vz i1) (* dzmag om)))
				  (loop-i (cdr i)))))
		      (loop-o (cdr o))))
	    (let loop-o ((o system))
	      (unless (null? o)
		      (let ((o1 (car o)))
			(set! (body-x o1) (+ (body-x o1) (* dt (body-vx o1))))
			(set! (body-y o1) (+ (body-y o1) (* dt (body-vy o1))))
			(set! (body-z o1) (+ (body-z o1) (* dt (body-vz o1))))
			(loop-o (cdr o))))))
	  
	  ;; (define (nbody-test)
	  
	  (let ((n 10) ;(n 1000) ; (command-line #:args (n) (string->number n)))
		(system (list *sun* *jupiter* *saturn* *uranus* *neptune*)))
	    (offset-momentum system)
	    (let ((initial (energy system)))
	      (do ((i 1 (+ i 1)))
		  ((< n i))
		(advance system 0.01))
	      (let ((final (energy system)))
		(num-test initial -0.16907516382852)
		(num-test final -0.16908760523461)
					;(list initial final))))) ; (-0.16907516382852 -0.16908760523461)
		))))
	

	;;; ----------------
	;;; some of these tests are taken (with modifications) from sacla which has 
	;;;  the following copyright notice:
	;;;
	;; Copyright (C) 2002-2004, Yuji Minejima <ggb01164@nifty.ne.jp>
	;; ALL RIGHTS RESERVED.
	;;
	;; Redistribution and use in source and binary forms, with or without
	;; modification, are permitted provided that the following conditions
	;; are met:
	;; 
	;;  * Redistributions of source code must retain the above copyright
	;;    notice, this list of conditions and the following disclaimer.
	;;  * Redistributions in binary form must reproduce the above copyright
	;;    notice, this list of conditions and the following disclaimer in
	;;    the documentation and/or other materials provided with the
	;;    distribution.
	;; 
	;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	;; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	;; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	;; A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	;; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	;; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	;; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	;; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	(test-t (equal 'a 'a))
	(test-t (not (equal 'a 'b)))
	(test-t (equal 'abc 'abc))
	(test-t (equal 1 1))
	(test-t (equal 2 2))
	(test-t (equal 0.1 0.1))
	(test-t (equal 1/3 1/3))
	(test-t (not (equal 0 1)))
	(test-t (not (equal 1 1.0)))
	(test-t (not (equal 1/3 1/4)))
	(test-t (equal #\a #\a))
	(test-t (equal #\b #\b))
	(test-t (not (equal #\b #\B)))
	(test-t (not (equal #\C #\c)))
	(test-t (equal '(0) '(0)))
	(test-t (equal '(0 #\a) '(0 #\a)))
	(test-t (equal '(0 #\a x) '(0 #\a x)))
	(test-t (equal '(0 #\a x (0)) '(0 #\a x (0))))

	(test-t (eql (identity 101) 101))
	(test-t (eq (identity 'x) 'x))

	;; chars
	(test-t (char= #\d #\d))
	(test-t (not (char= #\A #\a)))
	(test-t (not (char= #\d #\x)))
	(test-t (not (char= #\d #\D)))
	(test-t (not (char/= #\d #\d)))
	(test-t (char/= #\d #\x))
	(test-t (char/= #\d #\D))
	(test-t (char= #\d #\d #\d #\d))
	(test-t (not (char/= #\d #\d #\d #\d)))
	(test-t (not (char= #\d #\d #\x #\d)))
	(test-t (not (char/= #\d #\d #\x #\d)))
	(test-t (not (char= #\d #\y #\x #\c)))
	(test-t (char/= #\d #\y #\x #\c))
	(test-t (not (char= #\d #\c #\d)))
	(test-t (not (char/= #\d #\c #\d)))
	(test-t (char< #\d #\x))
	(test-t (char<= #\d #\x))
	(test-t (not (char< #\d #\d)))
	(test-t (char<= #\d #\d))
	(test-t (char< #\a #\e #\y #\z))
	(test-t (char<= #\a #\e #\y #\z))
	(test-t (not (char< #\a #\e #\e #\y)))
	(test-t (char<= #\a #\e #\e #\y))
	(test-t (char> #\e #\d))
	(test-t (char>= #\e #\d))
	(test-t (char> #\d #\c #\b #\a))
	(test-t (char>= #\d #\c #\b #\a))
	(test-t (not (char> #\d #\d #\c #\a)))
	(test-t (char>= #\d #\d #\c #\a))
	(test-t (not (char> #\e #\d #\b #\c #\a)))
	(test-t (not (char>= #\e #\d #\b #\c #\a)))
	(test-t (char-equal #\A #\a))
	(test-t (char= #\a))
	(test-t (char= #\a #\a))
	(test-t (char= #\a #\a #\a))
	(test-t (char= #\a #\a #\a #\a))
	(test-t (char= #\a #\a #\a #\a #\a))
	(test-t (char= #\a #\a #\a #\a #\a #\a))
	(test-t (let ((c #\z))  (and (eq c c)       (char= c c))))
	(test-t (not (char= #\Z #\z)))
	(test-t (not (char= #\z #\z #\z #\a)))
	(test-t (not (char= #\a #\z #\z #\z #\a)))
	(test-t (not (char= #\z #\i #\z #\z)))
	(test-t (not (char= #\z #\z #\Z #\z)))
	(test-t (char/= #\a))
	(test-t (char/= #\a #\b))
	(test-t (char/= #\a #\b #\c))
	(test-t (char/= #\a #\b #\c #\d))
	(test-t (char/= #\a #\b #\c #\d #\e))
	(test-t (char/= #\a #\b #\c #\d #\e #\f))
	(test-t (let ((c #\z))  (and (eq c c)       (not (char/= c c)))))
	(test-t (char/= #\Z #\z))
	(test-t (not (char/= #\z #\z #\z #\a)))
	(test-t (not (char= #\a #\z #\z #\z #\a)))
	(test-t (not (char= #\z #\i #\z #\z)))
	(test-t (not (char= #\z #\z #\Z #\z)))
	(test-t (not (char/= #\a #\a #\b #\c)))
	(test-t (not (char/= #\a #\b #\a #\c)))
	(test-t (not (char/= #\a #\b #\c #\a)))
	(test-t (char< #\a))
	(test-t (char< #\a #\z))
	(test-t (char< #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m       #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z))
	(test-t (not (char< #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n	    #\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a)))
	(test-t (char< #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M       #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z))
	(test-t (not (char< #\Z #\Y #\X #\W #\V #\U #\T #\S #\R #\Q #\P #\O #\N	    #\M #\L #\K #\J #\I #\H #\G #\F #\E #\D #\C #\B #\A)))
	(test-t (char< #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))
	(test-t (not (char< #\9 #\8 #\7 #\6 #\5 #\4 #\3 #\2 #\1 #\0)))
	(test-t (or (char< #\9 #\A)    (char< #\Z #\0)))
	(test-t (or (char< #\9 #\a)    (char< #\z #\0)))
	(test-t (not (char< #\a #\a #\b #\c)))
	(test-t (not (char< #\a #\b #\a #\c)))
	(test-t (not (char< #\a #\b #\c #\a)))
	(test-t (not (char< #\9 #\0)))
	(test-t (char> #\a))
	(test-t (not (char> #\a #\z)))
	(test-t (char> #\z #\a))
	(test-t (not (char> #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m	    #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)))
	(test-t (char> #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n       #\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a))
	(test-t (not (char> #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M	    #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z)))
	(test-t (char> #\Z #\Y #\X #\W #\V #\U #\T #\S #\R #\Q #\P #\O #\N      #\M #\L #\K #\J #\I #\H #\G #\F #\E #\D #\C #\B #\A))
	(test-t (not (char> #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))
	(test-t (char> #\9 #\8 #\7 #\6 #\5 #\4 #\3 #\2 #\1 #\0))
	(test-t (or (char> #\A #\9)    (char> #\0 #\Z)))
	(test-t (or (char> #\a #\9)    (char> #\0 #\z)))
	(test-t (not (char> #\a #\a #\b #\c)))
	(test-t (not (char> #\a #\b #\a #\c)))
	(test-t (not (char> #\a #\b #\c #\a)))
	(test-t (char> #\9 #\0))
	(test-t (char<= #\a))
	(test-t (char<= #\a #\z))
	(test-t (char<= #\a #\a))
	(test-t (char<= #\Z #\Z))
	(test-t (char<= #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m	#\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z))
	(test-t (char<= #\a #\a #\b #\b #\c #\c #\d #\d #\e #\e #\f #\f #\g #\g #\h #\h 
			#\i #\i #\j #\j #\k #\k #\l #\l #\m #\m	#\n #\n #\o #\o #\p #\p #\q #\q #\r #\r #\s #\s	
			#\t #\t #\u #\u #\v #\v #\w #\w #\x #\x #\y #\y #\z #\z))
	(test-t (not (char<= #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n     #\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a)))
	(test-t (char<= #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M	#\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z))
	(test-t (char<= #\A #\B #\B #\C #\D #\E #\E #\F #\G #\H #\I #\I #\J #\K #\L #\M	#\N #\N #\O #\P #\Q #\R #\S #\T #\T #\U #\V #\W #\X #\Y #\Z))
	(test-t (not (char<= #\Z #\Y #\X #\W #\V #\U #\T #\S #\R #\Q #\P #\O #\N     #\M #\L #\K #\J #\I #\H #\G #\F #\E #\D #\C #\B #\A)))
	(test-t (char<= #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))
	(test-t (char<= #\0 #\1 #\2 #\2 #\3 #\3 #\3 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\9))
	(test-t (not (char<= #\9 #\8 #\7 #\6 #\5 #\4 #\3 #\2 #\1 #\0)))
	(test-t (or (char<= #\9 #\A)    (char<= #\Z #\0)))
	(test-t (or (char<= #\9 #\a)    (char<= #\z #\0)))
	(test-t (char<= #\a #\a #\b #\c))
	(test-t (not (char<= #\a #\b #\a #\c)))
	(test-t (not (char<= #\a #\b #\c #\a)))
	(test-t (not (char<= #\9 #\0)))
	(test-t (char>= #\a))
	(test-t (not (char>= #\a #\z)))
	(test-t (char>= #\z #\a))
	(test-t (char>= #\a #\a))
	(test-t (char>= #\Z #\Z))
	(test-t (not (char>= #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m     #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)))
	(test-t (char>= #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n	#\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a))
	(test-t (char>= #\z #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n #\n	#\m #\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a #\a))
	(test-t (not (char>= #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M     #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z)))
	(test-t (char>= #\Z #\Y #\X #\W #\V #\U #\T #\S #\R #\Q #\P #\O #\N	#\M #\L #\K #\J #\I #\H #\G #\F #\E #\D #\C #\B #\A))
	(test-t (char>= #\Z #\Y #\X #\W #\V #\U #\U #\T #\T #\S #\S #\R #\Q #\P #\O #\N	#\M #\L #\K #\J #\I #\H #\H #\G #\G #\F #\F #\E #\D #\C #\B #\A))
	(test-t (not (char>= #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))
	(test-t (char>= #\9 #\8 #\7 #\6 #\5 #\4 #\3 #\2 #\1 #\0))
	(test-t (char>= #\9 #\8 #\8 #\8 #\7 #\6 #\5 #\4 #\3 #\3 #\3 #\2 #\1 #\0))
	(test-t (or (char>= #\A #\9)    (char>= #\0 #\Z)))
	(test-t (or (char>= #\a #\9)    (char>= #\0 #\z)))
	(test-t (char>= #\c #\b #\a #\a))
	(test-t (not (char>= #\c #\b #\a #\a #\b #\c)))
	(test-t (not (char>= #\c #\b #\a #\c)))
	(test-t (not (char>= #\c #\b #\c #\a)))
	(test-t (char>= #\9 #\0))
	(test-t (not (char>= #\0 #\9)))
	(test-t (char-equal #\a))
	(test-t (char-equal #\a #\a))
	(test-t (char-equal #\a #\a #\a))
	(test-t (char-equal #\a #\a #\a #\a))
	(test-t (char-equal #\a #\a #\a #\a #\a))
	(test-t (char-equal #\a #\a #\a #\a #\a #\a))
	(test-t (char-equal #\a #\A))
	(test-t (char-equal #\a #\A #\a))
	(test-t (char-equal #\a #\a #\A #\a))
	(test-t (char-equal #\a #\a #\a #\A #\a))
	(test-t (char-equal #\a #\a #\a #\a #\A #\a))
	(test-t (let ((c #\z))  (and (eq c c)       (char-equal c c))))
	(test-t (char-equal #\Z #\z))
	(test-t (not (char-equal #\z #\z #\z #\a)))
	(test-t (not (char-equal #\a #\z #\z #\z #\a)))
	(test-t (not (char-equal #\z #\i #\z #\z)))
	(test-t (char-equal #\z #\z #\Z #\z))
	(test-t (char-equal #\a #\A #\a #\A #\a #\A #\a #\A #\a #\A))
	(test-t (char-not-equal #\a))
	(test-t (char-not-equal #\a #\b))
	(test-t (char-not-equal #\a #\b #\c))
	(test-t (char-not-equal #\a #\b #\c #\d))
	(test-t (char-not-equal #\a #\b #\c #\d #\e))
	(test-t (char-not-equal #\a #\b #\c #\d #\e #\f))
	(test-t (let ((c #\z))  (and (eq c c)       (not (char-not-equal c c)))))
	(test-t (not (char-not-equal #\Z #\z)))
	(test-t (not (char-not-equal #\z #\z #\z #\a)))
	(test-t (not (char= #\a #\z #\z #\z #\a)))
	(test-t (not (char= #\z #\i #\z #\z)))
	(test-t (not (char= #\z #\z #\Z #\z)))
	(test-t (not (char-not-equal #\a #\a #\b #\c)))
	(test-t (not (char-not-equal #\a #\b #\a #\c)))
	(test-t (not (char-not-equal #\a #\b #\c #\a)))
	(test-t (not (char-not-equal #\a #\A #\a #\A)))
	(test-t (char-lessp #\a))
	(test-t (char-lessp #\a #\z))
	(test-t (char-lessp #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m       #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z))
	(test-t (not (char-lessp #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n	    #\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a)))
	(test-t (char-lessp #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M       #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z))
	(test-t (not (char-lessp #\Z #\Y #\X #\W #\V #\U #\T #\S #\R #\Q #\P #\O #\N	    #\M #\L #\K #\J #\I #\H #\G #\F #\E #\D #\C #\B #\A)))
	(test-t (char-lessp #\a #\B #\c #\D #\e #\F #\g #\H #\i #\J #\k #\L #\m       #\N #\o #\P #\q #\R #\s #\T #\u #\V #\w #\X #\y #\Z))
	(test-t (char-lessp #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))
	(test-t (not (char-lessp #\9 #\8 #\7 #\6 #\5 #\4 #\3 #\2 #\1 #\0)))
	(test-t (or (char-lessp #\9 #\A)    (char-lessp #\Z #\0)))
	(test-t (or (char-lessp #\9 #\a)    (char-lessp #\z #\0)))
	(test-t (not (char-lessp #\a #\a #\b #\c)))
	(test-t (not (char-lessp #\a #\b #\a #\c)))
	(test-t (not (char-lessp #\a #\b #\c #\a)))
	(test-t (not (char-lessp #\9 #\0)))
	(test-t (and (char-lessp #\a #\Z)     (char-lessp #\A #\z)))
	(test-t (char-greaterp #\a))
	(test-t (not (char-greaterp #\a #\z)))
	(test-t (char-greaterp #\z #\a))
	(test-t (not (char-greaterp #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m	    #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)))
	(test-t (char-greaterp #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n       #\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a))
	(test-t (not (char-greaterp #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M	    #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z)))
	(test-t (char-greaterp #\Z #\Y #\X #\W #\V #\U #\T #\S #\R #\Q #\P #\O #\N   #\M #\L #\K #\J #\I #\H #\G #\F #\E #\D #\C #\B #\A))
	(test-t (char-greaterp #\z #\Y #\x #\W #\v #\U #\t #\S #\r #\Q #\p #\O #\n   #\M #\l #\K #\j #\I #\h #\G #\f #\E #\d #\C #\b #\A))
	(test-t (not (char-greaterp #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))
	(test-t (char-greaterp #\9 #\8 #\7 #\6 #\5 #\4 #\3 #\2 #\1 #\0))
	(test-t (or (char-greaterp #\A #\9)    (char-greaterp #\0 #\Z)))
	(test-t (or (char-greaterp #\a #\9)    (char-greaterp #\0 #\z)))
	(test-t (not (char-greaterp #\a #\a #\b #\c)))
	(test-t (not (char-greaterp #\a #\b #\a #\c)))
	(test-t (not (char-greaterp #\a #\b #\c #\a)))
	(test-t (char-greaterp #\9 #\0))
	(test-t (and (char-greaterp #\z #\A)     (char-greaterp #\Z #\a)))
	(test-t (char-not-greaterp #\a))
	(test-t (char-not-greaterp #\a #\z))
	(test-t (char-not-greaterp #\a #\a))
	(test-t (char-not-greaterp #\Z #\Z))
	(test-t (char-not-greaterp #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z))
	(test-t (char-not-greaterp #\a #\a #\b #\b #\c #\c #\d #\d #\e #\e #\f #\f #\g #\g #\h #\h #\i #\i 
				   #\j #\j #\k #\k #\l #\l #\m #\m #\n #\n #\o #\o #\p #\p #\q #\q #\r #\r #\s #\s #\t 
				   #\t #\u #\u #\v #\v #\w #\w #\x #\x #\y #\y #\z #\z))
	(test-t (char-not-greaterp #\a #\A #\b #\B #\c #\C #\d #\D #\e #\E #\f #\F #\g #\G #\h #\H #\i #\I #\j #\J 
				   #\k #\K #\l #\L #\m #\M #\n #\N #\o #\O #\p #\P #\q #\Q #\r #\R #\s #\S #\t #\T 
				   #\u #\U #\v #\V #\w #\W #\x #\X #\y #\Y #\z #\z))
	(test-t (not (char-not-greaterp      #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n      #\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a)))
	(test-t (char-not-greaterp #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z))
	(test-t (char-not-greaterp #\A #\B #\B #\C #\D #\E #\E #\F #\G #\H #\I #\I #\J #\K #\L #\M #\N #\N #\O #\P #\Q #\R #\S #\T #\T #\U #\V #\W #\X #\Y #\Z))
	(test-t (not (char-not-greaterp      #\Z #\Y #\X #\W #\V #\U #\T #\S #\R #\Q #\P #\O #\N      #\M #\L #\K #\J #\I #\H #\G #\F #\E #\D #\C #\B #\A)))
	(test-t (char-not-greaterp #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))
	(test-t (char-not-greaterp #\0 #\1 #\2 #\2 #\3 #\3 #\3 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\9))
	(test-t (not (char-not-greaterp #\9 #\8 #\7 #\6 #\5 #\4 #\3 #\2 #\1 #\0)))
	(test-t (or (char-not-greaterp #\9 #\A)    (char-not-greaterp #\Z #\0)))
	(test-t (or (char-not-greaterp #\9 #\a)    (char-not-greaterp #\z #\0)))
	(test-t (char-not-greaterp #\a #\a #\b #\c))
	(test-t (not (char-not-greaterp #\a #\b #\a #\c)))
	(test-t (not (char-not-greaterp #\a #\b #\c #\a)))
	(test-t (not (char-not-greaterp #\9 #\0)))
	(test-t (and (char-not-greaterp #\A #\z)     (char-not-greaterp #\a #\Z)))
	(test-t (char-not-lessp #\a))
	(test-t (not (char-not-lessp #\a #\z)))
	(test-t (char-not-lessp #\z #\a))
	(test-t (char-not-lessp #\a #\a))
	(test-t (char-not-lessp #\Z #\Z))
	(test-t (not (char-not-lessp #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m  #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)))
	(test-t (char-not-lessp #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n	#\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a))
	(test-t (char-not-lessp #\z #\z #\y #\x #\w #\v #\u #\t #\s #\r #\q #\p #\o #\n #\n	#\m #\m #\l #\k #\j #\i #\h #\g #\f #\e #\d #\c #\b #\a #\a))
	(test-t (not (char-not-lessp #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\m     #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z)))
	(test-t (char-not-lessp #\Z #\Y #\X #\W #\V #\U #\T #\S #\R #\Q #\P #\O #\N	#\M #\L #\K #\J #\I #\H #\G #\F #\E #\D #\C #\B #\A))
	(test-t (char-not-lessp #\Z #\Y #\X #\W #\V #\U #\U #\T #\T #\S #\S #\R #\Q #\P #\O #\N	#\M #\L #\K #\J #\I #\H #\H #\G #\G #\F #\F #\E #\D #\C #\B #\A))
	(test-t (char-not-lessp #\z #\Z #\y #\x #\w #\V #\v #\u #\t #\s #\r #\q #\p #\o #\n #\n	#\m #\M #\l #\k #\K #\j #\i #\h #\g #\f #\e #\d #\c #\b #\A #\a))
	(test-t (not (char-not-lessp #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))
	(test-t (char-not-lessp #\9 #\8 #\7 #\6 #\5 #\4 #\3 #\2 #\1 #\0))
	(test-t (char-not-lessp #\9 #\8 #\8 #\8 #\7 #\6 #\5 #\4 #\3 #\3 #\3 #\2 #\1 #\0))
	(test-t (or (char-not-lessp #\A #\9)    (char-not-lessp #\0 #\Z)))
	(test-t (or (char-not-lessp #\a #\9)    (char-not-lessp #\0 #\z)))
	(test-t (char-not-lessp #\c #\b #\a #\a))
	(test-t (not (char-not-lessp #\c #\b #\a #\a #\b #\c)))
	(test-t (not (char-not-lessp #\c #\b #\a #\c)))
	(test-t (not (char-not-lessp #\c #\b #\c #\a)))
	(test-t (char-not-lessp #\9 #\0))
	(test-t (not (char-not-lessp #\0 #\9)))
	(test-t (and (char-not-lessp #\z #\A)     (char-not-lessp #\Z #\a)))
	(test-t (char= (character #\a) #\a))
	(test-t (char= (character #\b) #\b))
;	(test-t (char= (character #\Space) #\Space))
	(test-t (char= (character "a") #\a))
	(test-t (char= (character "X") #\X))
	(test-t (char= (character "z") #\z))
	(test-t (char= (character 'a) #\a))
;	(test-t (char= (character '\a) #\a))
	(test-t (alpha-char-p #\a))
	(test-t (every alpha-char-p '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)))
	(test-t (every alpha-char-p '(#\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z)))
	(test-t (notany alpha-char-p '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))
;	(test-t (not (alpha-char-p #\Newline)))
	(test-t (alphanumericp #\Z))
	(test-t (alphanumericp #\9))
	(test-t (every alphanumericp '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m  #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z)))
	(test-t (every alphanumericp '(#\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M  #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z)))
	(test-t (every alphanumericp '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)))
;	(test-t (not (alphanumericp #\Newline)))
	(test-t (not (alphanumericp #\#)))
	(test-t (char= (digit-char 0) #\0))
;	(test-t (char= (digit-char 10 11) #\A))
	(test-t (null (digit-char 10 10)))
	(test-t (char= (digit-char 7) #\7))
	(test-t (null (digit-char 12)))
;	(test-t (char= (digit-char 12 16) #\C))
	(test-t (null (digit-char 6 2))) 
	(test-t (char= (digit-char 1 2) #\1))
;	(test-t (char= (digit-char 35 36) #\Z))
	(test-t (= (digit-char-p #\0) 0))
	(test-t (= (digit-char-p #\5) 5))
	(test-t (not (digit-char-p #\5 2)))
	(test-t (not (digit-char-p #\A)))
	(test-t (not (digit-char-p #\a)))
;	(test-t (= (digit-char-p #\A 11) 10))
	(test-t (= (digit-char-p #\a 11) 10))
;	(test-t (standard-char-p #\a))
;	(test-t (standard-char-p #\z))
;	(test-t (standard-char-p #\Newline))
;	(test-t (every standard-char-p " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_'abcdefghijklmnopqrstuvwxyz{|}~"))
	(test-t (char= (char-upcase #\a) #\A))
	(test-t (char= (char-upcase #\A) #\A))
	(test-t (char= (char-upcase #\-) #\-))
	(test-t (char= (char-downcase #\A) #\a))
	(test-t (char= (char-downcase #\a) #\a))
	(test-t (char= (char-downcase #\-) #\-))
	(test-t (not (upper-case-p #\a)))
	(test-t (upper-case-p #\A))
	(test-t (not (upper-case-p #\-)))
	(test-t (not (lower-case-p #\A)))
	(test-t (lower-case-p #\a))
	(test-t (not (lower-case-p #\-)))
;	(test-t (char= #\Space (name-char (char-name #\Space))))
;	(test-t (char= #\Newline (name-char (char-name #\Newline))))


	(test-t (simple-string-p ""))
	(test-t (simple-string-p "abc"))
	(test-t (not (simple-string-p 'not-a-string)))
	(test-t (char= (char "abc" 0) #\a))
	(test-t (char= (char "abc" 1) #\b))
	(test-t (char= (char "abc" 2) #\c))
	(test-t (char= (schar "abc" 0) #\a))
	(test-t (char= (schar "abc" 1) #\b))
	(test-t (char= (schar "abc" 2) #\c))
	(test-t (string= (cl-string "") ""))
	(test-t (string= (cl-string "abc") "abc"))
	(test-t (string= (cl-string "a") "a"))
	(test-t (string= (cl-string 'abc) "abc"))
	(test-t (string= (cl-string 'a) "a"))
	(test-t (string= (cl-string #\a) "a"))
	(test-t (string= (string-upcase "abcde") "ABCDE"))
	(test-t (string= (string-upcase "Dr. Livingston, I presume?")	 "DR. LIVINGSTON, I PRESUME?"))
	(test-t (string= (string-upcase "Dr. Livingston, I presume?" :start 6 :end 10)	 "Dr. LiVINGston, I presume?"))
	(test-t (string= (string-upcase 'Kludgy-HASH-Search) "KLUDGY-HASH-SEARCH"))
	(test-t (string= (string-upcase "abcde" :start 2 :end nil) "abCDE"))
	(test-t (string= (string-downcase "Dr. Livingston, I presume?")	 "dr. livingston, i presume?"))
	(test-t (string= (string-downcase 'Kludgy-HASH-Search) "kludgy-hash-search"))
	(test-t (string= (string-downcase "A FOOL" :start 2 :end nil) "A fool"))
	(test-t (string= (string-capitalize "elm 13c arthur;fig don't")	 "Elm 13c Arthur;Fig Don'T"))
	(test-t (string= (string-capitalize " hello ") " Hello "))
	(test-t (string= (string-capitalize  "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION") "Occluded Casements Forestall Inadvertent Defenestration"))
	(test-t (string= (string-capitalize 'kludgy-hash-search) "Kludgy-Hash-Search"))
	(test-t (string= (string-capitalize "DON'T!") "Don'T!"))
	(test-t (string= (string-capitalize "pipe 13a, foo16c") "Pipe 13a, Foo16c"))
	(test-t (string= (string-capitalize "a fool" :start 2 :end nil) "a Fool"))
	(test-t (let ((str (copy-seq "0123ABCD890a")))  (and (string= (nstring-downcase str :start 5 :end 7) "0123AbcD890a")       (string= str "0123AbcD890a"))))
	(test-t (let* ((str0 (copy-seq "abcde"))  (str  (nstring-upcase str0)))  (and (eq str0 str)       (string= str "ABCDE"))))
	(test-t (let* ((str0 (copy-seq "Dr. Livingston, I presume?")) (str  (nstring-upcase str0))) (and (eq str0 str) (string= str "DR. LIVINGSTON, I PRESUME?"))))
	(test-t (let* ((str0 (copy-seq "Dr. Livingston, I presume?")) (str  (nstring-upcase str0 :start 6 :end 10))) (and (eq str0 str) (string= str "Dr. LiVINGston, I presume?"))))
	(test-t (let* ((str0 (copy-seq "abcde")) (str (nstring-upcase str0 :start 2 :end nil)))  (string= str "abCDE")))
	(test-t (let* ((str0 (copy-seq "Dr. Livingston, I presume?")) (str  (nstring-downcase str0))) (and (eq str0 str) (string= str "dr. livingston, i presume?"))))
	(test-t (let* ((str0 (copy-seq "ABCDE")) (str (nstring-downcase str0 :start 2 :end nil)))  (string= str "ABcde")))
	(test-t (let* ((str0 (copy-seq "elm 13c arthur;fig don't")) (str  (nstring-capitalize str0))) (and (eq str0 str) (string= str "Elm 13c Arthur;Fig Don'T"))))
	(test-t (let* ((str0 (copy-seq " hello ")) (str  (nstring-capitalize str0)))  (and (eq str0 str) (string= str " Hello "))))
	(test-t (let* ((str0 (copy-seq "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION")) (str (nstring-capitalize str0))) (and (eq str0 str) (string= str		"Occluded Casements Forestall Inadvertent Defenestration"))))
	(test-t (let* ((str0 (copy-seq "DON'T!"))  (str  (nstring-capitalize str0))) (and (eq str0 str)  (string= str "Don'T!"))))
	(test-t (let* ((str0 (copy-seq "pipe 13a, foo16c"))       (str  (nstring-capitalize str0)))  (and (eq str0 str)       (string= str "Pipe 13a, Foo16c"))))
	(test-t (let* ((str0 (copy-seq "a fool"))       (str (nstring-capitalize str0 :start 2 :end nil)))  (string= str "a Fool")))
	(test-t (string= (string-trim "abc" "abcaakaaakabcaaa") "kaaak"))
	(test-t (string= (string-trim '(#\space) " garbanzo beans        ") "garbanzo beans"))
	(test-t (string= (string-trim " (*)" " ( *three (silly) words* ) ")	 "three (silly) words"))
	(test-t (string= (string-left-trim "abc" "labcabcabc") "labcabcabc"))
	(test-t (string= (string-left-trim " (*)" " ( *three (silly) words* ) ")	 "three (silly) words* ) "))
	(test-t (string= (string-right-trim " (*)" " ( *three (silly) words* ) ") 	 " ( *three (silly) words"))
	(test-t (string= (string-trim "ABC" "abc") "abc"))
	(test-t (string= (string-trim "AABBCC" "abc") "abc"))
	(test-t (string= (string-trim "" "abc") "abc"))
	(test-t (string= (string-trim "ABC" "") ""))
	(test-t (string= (string-trim "cba" "abc") ""))
	(test-t (string= (string-trim "cba" "abccba") ""))
	(test-t (string= (string-trim "ccbbba" "abccba") ""))
	(test-t (string= (string-trim "cba" "abcxabc") "x"))
	(test-t (string= (string-trim "xyz" "xxyabcxyyz") "abc"))
	(test-t (string= (string-trim "a" #\a) ""))
	(test-t (string= (string-left-trim "ABC" "abc") "abc"))
	(test-t (string= (string-left-trim "" "abc") "abc"))
	(test-t (string= (string-left-trim "ABC" "") ""))
	(test-t (string= (string-left-trim "cba" "abc") ""))
	(test-t (string= (string-left-trim "cba" "abccba") ""))
	(test-t (string= (string-left-trim "cba" "abcxabc") "xabc"))
	(test-t (string= (string-left-trim "xyz" "xxyabcxyz") "abcxyz"))
	(test-t (string= (string-left-trim "a" #\a) ""))
	(test-t (string= (string-right-trim "ABC" "abc") "abc"))
	(test-t (string= (string-right-trim "" "abc") "abc"))
	(test-t (string= (string-right-trim "ABC" "") ""))
	(test-t (string= (string-right-trim "cba" "abc") ""))
	(test-t (string= (string-right-trim "cba" "abccba") ""))
	(test-t (string= (string-right-trim "cba" "abcxabc") "abcx"))
	(test-t (string= (string-right-trim "xyz" "xxyabcxyz") "xxyabc"))
	(test-t (string= (string-right-trim "a" #\a) ""))
	(test-t (string= (cl-string "already a string") "already a string"))
	(test-t (string=  (cl-string #\c) "c"))
	(test-t (string= "foo" "foo"))
	(test-t (not (string= "foo" "Foo")))
	(test-t (not (string= "foo" "bar")))
	(test-t (string= "together" "frog" :start1 1 :end1 3 :start2 2))
	(test-t (string-equal "foo" "Foo"))
	(test-t (string= "abcd" "01234abcd9012" :start2 5 :end2 9))
	(test-t (eql (string< "aaaa" "aaab") 3))
	(test-t (eql (string>= "aaaaa" "aaaa") 4))
	(test-t (eql (string-not-greaterp "Abcde" "abcdE") 5))
	(test-t (eql (string-lessp "012AAAA789" "01aaab6"   :start1 3 :end1 7   :start2 2 :end2 6) 6))
	(test-t (not (string-not-equal "AAAA" "aaaA")))
	(test-t (string= "" ""))
	(test-t (not (string= "abc" "")))
	(test-t (not (string= "" "abc")))
	(test-t (not (string= "A" "a")))
	(test-t (string= "abc" "xyz" :start1 3 :start2 3))
	(test-t (string= "abc" "xyz" :start1 1 :end1 1 :start2 0 :end2 0))
	(test-t (string= "axyza" "xyz" :start1 1 :end1 4))
	(test-t (string= "axyza" "xyz" :start1 1 :end1 4 :start2 0 :end2 nil))
	(test-t (string= "abxyz" "xyabz" :end1 2 :start2 2 :end2 4))
	(test-t (not (string= "love" "hate")))
	(test-t (string= 'love 'love))
	(test-t (not (string= 'love "hate")))
	(test-t (string= #\a #\a))
	(test-t (not (string/= "" "")))
	(test-t (eql (string/= "abc" "") 0))
	(test-t (eql (string/= "" "abc") 0))
	(test-t (eql (string/= "A" "a") 0))
	(test-t (not (string/= "abc" "xyz" :start1 3 :start2 3)))
	(test-t (not (string/= "abc" "xyz" :start1 1 :end1 1 :start2 0 :end2 0)))
	(test-t (not (string/= "axyza" "xyz" :start1 1 :end1 4)))
	(test-t (not (string/= "axyza" "xyz" :start1 1 :end1 4 :start2 0 :end2 nil)))
	(test-t (not (string/= "abxyz" "xyabz" :end1 2 :start2 2 :end2 4)))
	(test-t (eql (string/= "love" "hate") 0))
	(test-t (eql (string/= "love" "loVe") 2))
	(test-t (not (string/= "life" "death" :start1 3 :start2 1 :end2 2)))
	(test-t (eql (string/= "abcxyz" "ABCxyZ" :start1 3 :start2 3) 5))
	(test-t (eql (string/= "abcxyz" "ABCxyZ" :start1 3 :end1 nil :start2 3 :end2 nil) 5))
	(test-t (eql (string/= "abcxyz" "ABCxyZ" :end1 nil :start2 3 :end2 3) 0))
	(test-t (eql (string/= "abc" "abcxyz") 3))
	(test-t (eql (string/= "abcxyz" "abc") 3))
	(test-t (eql (string/= "abcxyz" "") 0))
	(test-t (eql (string/= "AbcDef" "cdef" :start1 2) 3))
	(test-t (eql (string/= "cdef" "AbcDef" :start2 2) 1))
	(test-t (= (string/= 'love "hate") 0))
	(test-t (not (string/= 'love 'love)))
	(test-t (not (string/= #\a #\a)))
	(test-t (= (string/= #\a #\b) 0))
	(test-t (not (string< "" "")))
	(test-t (not (string< "dog" "dog")))
	(test-t (not (string< " " " ")))
	(test-t (not (string< "abc" "")))
	(test-t (eql (string< "" "abc") 0))
	(test-t (eql (string< "ab" "abc") 2))
	(test-t (not (string< "abc" "ab")))
	(test-t (eql (string< "aaa" "aba") 1))
	(test-t (not (string< "aba" "aaa")))
	(test-t (not (string< "my cat food" "your dog food" :start1 6 :start2 8)))
	(test-t (not (string< "cat food 2 dollars" "dog food 3 dollars"	      :start1 3 :end1 9 :start2 3 :end2 9)))
	(test-t (eql (string< "xyzabc" "abcd" :start1 3) 6))
	(test-t (eql (string< "abc" "abc" :end1 1) 1))
	(test-t (eql (string< "xyzabc" "abc" :start1 3 :end1 5) 5))
	(test-t (eql (string< "xyz" "abcxyzXYZ" :start2 3) 3))
	(test-t (not (string< "abc" "abcxyz" :end2 3)))
	(test-t (eql (string< "xyz" "abcxyz" :end1 2 :start2 3) 2))
	(test-t (not (string< "xyzabc" "abcdef" :start1 3 :end2 3)))
	(test-t (eql (string< "aaaa" "z") 0))
	(test-t (eql (string< "pppTTTaTTTqqq" "pTTTxTTT" :start1 3 :start2 1) 6))
	(test-t (eql (string< "pppTTTaTTTqqq" "pTTTxTTT"     :start1 6 :end1 7     :start2 4 :end2 5) 6))
	(test-t (not (string< 'love 'hate)))
	(test-t (= (string< 'peace 'war) 0))
	(test-t (not (string< 'love 'love)))
	(test-t (not (string< #\a #\a)))
	(test-t (= (string< #\a #\b) 0))
	(test-t (not (string> "" "")))
	(test-t (not (string> "dog" "dog")))
	(test-t (not (string> " " " ")))
	(test-t (eql (string> "abc" "") 0))
	(test-t (not (string> "" "abc")))
	(test-t (not (string> "ab" "abc")))
	(test-t (eql (string> "abc" "ab") 2))
	(test-t (eql (string> "aba" "aaa") 1))
	(test-t (not (string> "aaa" "aba")))
	(test-t (not (string> "my cat food" "your dog food" :start1 6 :start2 8)))
	(test-t (not (string> "cat food 2 dollars" "dog food 3 dollars"	     :start1 3 :end1 9 :start2 3 :end2 9)))
	(test-t (eql (string> "xyzabcde" "abcd" :start1 3) 7))
	(test-t (not (string> "abc" "abc" :end1 1)))
	(test-t (eql (string> "xyzabc" "a" :start1 3 :end1 5) 4))
	(test-t (eql (string> "xyzXYZ" "abcxyz" :start2 3) 3))
	(test-t (eql (string> "abcxyz" "abcxyz" :end2 3) 3))
	(test-t (not (string> "xyzXYZ" "abcxyz" :end1 2 :start2 3)))
	(test-t (not (string> "xyzabc" "abcdef" :start1 3 :end2 3)))
	(test-t (eql (string> "z" "aaaa") 0))
	(test-t (eql (string> "pTTTxTTTqqq" "pppTTTaTTT" :start1 1 :start2 3) 4))
	(test-t (eql (string> "pppTTTxTTTqqq" "pTTTaTTT"     :start1 6 :end1 7      :start2 4 :end2 5) 6))
	(test-t (= (string> 'love 'hate) 0))
	(test-t (not (string> 'peace 'war)))
	(test-t (not (string> 'love 'love)))
	(test-t (not (string> #\a #\a)))
	(test-t (not (string> #\a #\b)))
	(test-t (= (string> #\z #\a) 0))
	(test-t (eql (string<= "" "") 0))
	(test-t (eql (string<= "dog" "dog") 3))
	(test-t (eql (string<= " " " ") 1))
	(test-t (not (string<= "abc" "")))
	(test-t (eql (string<= "ab" "abc") 2))
	(test-t (eql (string<= "aaa" "aba") 1))
	(test-t (not (string<= "aba" "aaa")))
	(test-t (eql (string<= "my cat food" "your dog food" :start1 6 :start2 8) 11))
	(test-t (eql (string<= "cat food 2 dollars" "dog food 3 dollars"      :start1 3 :end1 9 :start2 3 :end2 9) 9))
	(test-t (eql (string<= "xyzabc" "abcd" :start1 3) 6))
	(test-t (eql (string<= "abc" "abc" :end1 1) 1))
	(test-t (eql (string<= "xyzabc" "abc" :start1 3 :end1 5) 5))
	(test-t (eql (string<= "xyz" "abcxyzXYZ" :start2 3) 3))
	(test-t (eql (string<= "abc" "abcxyz" :end2 3) 3))
	(test-t (eql (string<= "xyz" "abcxyz" :end1 2 :start2 3) 2))
	(test-t (eql (string<= "xyzabc" "abcdef" :start1 3 :end2 3) 6))
	(test-t (eql (string<= "aaaa" "z") 0))
	(test-t (eql (string<= "pppTTTaTTTqqq" "pTTTxTTT" :start1 3 :start2 1) 6))
	(test-t (eql (string<= "pppTTTaTTTqqq" "pTTTxTTT"      :start1 6 :end1 7     :start2 4 :end2 5) 6))
	(test-t (not (string<= 'love 'hate)))
	(test-t (= (string<= 'peace 'war) 0))
	(test-t (= (string<= 'love 'love) 4))
	(test-t (= (string<= #\a #\a) 1))
	(test-t (= (string<= #\a #\b) 0))
	(test-t (not (string<= #\z #\a)))
	(test-t (eql (string>= "" "") 0))
	(test-t (eql (string>= "dog" "dog") 3))
	(test-t (eql (string>= " " " ") 1))
	(test-t (eql (string>= "abc" "") 0))
	(test-t (not (string>= "" "abc")))
	(test-t (not (string>= "ab" "abc")))
	(test-t (eql (string>= "abc" "ab") 2))
	(test-t (eql (string>= "aba" "aaa") 1))
	(test-t (not (string>= "aaa" "aba")))
	(test-t (eql (string>= "my cat food" "your dog food" :start1 6 :start2 8) 11))
	(test-t (eql (string>= "cat food 2 dollars" "dog food 3 dollars"      :start1 3 :end1 9 :start2 3 :end2 9) 9))
	(test-t (eql (string>= "xyzabcde" "abcd" :start1 3) 7))
	(test-t (not (string>= "abc" "abc" :end1 1)))
	(test-t (eql (string>= "xyzabc" "a" :start1 3 :end1 5) 4))
	(test-t (eql (string>= "xyzXYZ" "abcxyz" :start2 3) 3))
	(test-t (eql (string>= "abcxyz" "abcxyz" :end2 3) 3))
	(test-t (not (string>= "xyzXYZ" "abcxyz" :end1 2 :start2 3)))
	(test-t (eql (string>= "xyzabc" "abcdef" :start1 3 :end2 3) 6))
	(test-t (eql (string>= "z" "aaaa") 0))
	(test-t (eql (string>= "pTTTxTTTqqq" "pppTTTaTTT" :start1 1 :start2 3) 4))
	(test-t (eql (string>= "pppTTTxTTTqqq" "pTTTaTTT"     :start1 6 :end1 7      :start2 4 :end2 5) 6))
	(test-t (= (string>= 'love 'hate) 0))
	(test-t (not (string>= 'peace 'war)))
	(test-t (= (string>= 'love 'love) 4))
	(test-t (= (string>= #\a #\a) 1))
	(test-t (not (string>= #\a #\b)))
	(test-t (= (string>= #\z #\a) 0))
	(test-t (string-equal "" ""))
	(test-t (not (string-equal "abc" "")))
	(test-t (not (string-equal "" "abc")))
	(test-t (string-equal "A" "a"))
	(test-t (string-equal "abc" "xyz" :start1 3 :start2 3))
	(test-t (string-equal "abc" "xyz" :start1 1 :end1 1 :start2 0 :end2 0))
	(test-t (string-equal "axyza" "xyz" :start1 1 :end1 4))
	(test-t (string-equal "axyza" "xyz" :start1 1 :end1 4 :start2 0 :end2 nil))
	(test-t (string-equal "abxyz" "xyabz" :end1 2 :start2 2 :end2 4))
	(test-t (not (string-equal "love" "hate")))
	(test-t (string-equal "xyz" "XYZ"))
	(test-t (not (string-equal 'love 'hate)))
	(test-t (not (string-equal 'peace 'war)))
	(test-t (string-equal 'love 'love))
	(test-t (string-equal #\a #\a))
	(test-t (not (string-equal #\a #\b)))
	(test-t (not (string-equal #\z #\a)))
	(test-t (not (string-not-equal "" "")))
	(test-t (eql (string-not-equal "abc" "") 0))
	(test-t (eql (string-not-equal "" "abc") 0))
	(test-t (not (string-not-equal "A" "a")))
	(test-t (not (string-not-equal "abc" "xyz" :start1 3 :start2 3)))
	(test-t (not (string-not-equal "abc" "xyz" :start1 1 :end1 1 :start2 0 :end2 0)))
	(test-t (not (string-not-equal "axyza" "xyz" :start1 1 :end1 4)))
	(test-t (not (string-not-equal "axyza" "xyz" :start1 1 :end1 4 :start2 0 :end2 nil)))
	(test-t (not (string-not-equal "abxyz" "xyabz" :end1 2 :start2 2 :end2 4)))
	(test-t (eql (string-not-equal "love" "hate") 0))
	(test-t (not (string-not-equal "love" "loVe")))
	(test-t (not (string-not-equal "life" "death" :start1 3 :start2 1 :end2 2)))
	(test-t (not (string-not-equal "abcxyz" "ABCxyZ" :start1 3 :start2 3)))
	(test-t (not (string-not-equal "abcxyz" "ABCxyZ" :start1 3 :end1 nil :start2 3 :end2 nil)))
	(test-t (eql (string-not-equal "abcxyz" "ABCxyZ" :end1 nil :start2 3 :end2 3) 0))
	(test-t (eql (string-not-equal "abc" "abcxyz") 3))
	(test-t (eql (string-not-equal "abcxyz" "abc") 3))
	(test-t (eql (string-not-equal "abcxyz" "") 0))
	(test-t (not (string-not-equal "AbcDef" "cdef" :start1 2)))
	(test-t (not (string-not-equal "cdef" "AbcDef" :start2 2)))
	(test-t (not (string-not-equal "ABC" "abc")))
	(test-t (= (string-not-equal 'love 'hate) 0))
	(test-t (= (string-not-equal 'peace 'war) 0))
	(test-t (not (string-not-equal 'love 'love)))
	(test-t (not (string-not-equal #\a #\a)))
	(test-t (= (string-not-equal #\a #\b) 0))
	(test-t (= (string-not-equal #\z #\a) 0))
	(test-t (not (string-lessp "" "")))
	(test-t (not (string-lessp "dog" "dog")))
	(test-t (not (string-lessp " " " ")))
	(test-t (not (string-lessp "abc" "")))
	(test-t (eql (string-lessp "" "abc") 0))
	(test-t (eql (string-lessp "ab" "abc") 2))
	(test-t (not (string-lessp "abc" "ab")))
	(test-t (eql (string-lessp "aaa" "aba") 1))
	(test-t (not (string-lessp "aba" "aaa")))
	(test-t (not (string-lessp "my cat food" "your dog food" :start1 6 :start2 8)))
	(test-t (not (string-lessp "cat food 2 dollars" "dog food 3 dollars"   :start1 3 :end1 9 :start2 3 :end2 9)))
	(test-t (eql (string-lessp "xyzabc" "abcd" :start1 3) 6))
	(test-t (eql (string-lessp "abc" "abc" :end1 1) 1))
	(test-t (eql (string-lessp "xyzabc" "abc" :start1 3 :end1 5) 5))
	(test-t (eql (string-lessp "xyz" "abcxyzXYZ" :start2 3) 3))
	(test-t (not (string-lessp "abc" "abcxyz" :end2 3)))
	(test-t (eql (string-lessp "xyz" "abcxyz" :end1 2 :start2 3) 2))
	(test-t (not (string-lessp "xyzabc" "abcdef" :start1 3 :end2 3)))
	(test-t (eql (string-lessp "aaaa" "z") 0))
	(test-t (eql (string-lessp "pppTTTaTTTqqq" "pTTTxTTT" :start1 3 :start2 1) 6))
	(test-t (eql (string-lessp "pppTTTaTTTqqq" "pTTTxTTT"   :start1 6 :end1 7   :start2 4 :end2 5) 6))
	(test-t (and (not (string-lessp "abc" "ABC"))     (not (string-lessp "ABC" "abc"))))
	(test-t (not (string-lessp 'love 'hate)))
	(test-t (= (string-lessp 'peace 'war) 0))
	(test-t (not (string-lessp 'love 'love)))
	(test-t (not (string-lessp #\a #\a)))
	(test-t (= (string-lessp #\a #\b) 0))
	(test-t (not (string-lessp #\z #\a)))
	(test-t (not (string-greaterp "" "")))
	(test-t (not (string-greaterp "dog" "dog")))
	(test-t (not (string-greaterp " " " ")))
	(test-t (eql (string-greaterp "abc" "") 0))
	(test-t (not (string-greaterp "" "abc")))
	(test-t (not (string-greaterp "ab" "abc")))
	(test-t (eql (string-greaterp "abc" "ab") 2))
	(test-t (eql (string-greaterp "aba" "aaa") 1))
	(test-t (not (string-greaterp "aaa" "aba")))
	(test-t (not (string-greaterp "my cat food" "your dog food" :start1 6 :start2 8)))
	(test-t (not (string-greaterp "cat food 2 dollars" "dog food 3 dollars"      :start1 3 :end1 9 :start2 3 :end2 9)))
	(test-t (eql (string-greaterp "xyzabcde" "abcd" :start1 3) 7))
	(test-t (not (string-greaterp "abc" "abc" :end1 1)))
	(test-t (eql (string-greaterp "xyzabc" "a" :start1 3 :end1 5) 4))
	(test-t (eql (string-greaterp "xyzXYZ" "abcxyz" :start2 3) 3))
	(test-t (eql (string-greaterp "abcxyz" "abcxyz" :end2 3) 3))
	(test-t (not (string-greaterp "xyzXYZ" "abcxyz" :end1 2 :start2 3)))
	(test-t (not (string-greaterp "xyzabc" "abcdef" :start1 3 :end2 3)))
	(test-t (eql (string-greaterp "z" "aaaa") 0))
	(test-t (eql (string-greaterp "pTTTxTTTqqq" "pppTTTaTTT" :start1 1 :start2 3) 4))
	(test-t (eql (string-greaterp "pppTTTxTTTqqq" "pTTTaTTT"     :start1 6 :end1 7	     :start2 4 :end2 5) 6))
	(test-t (and (not (string-greaterp "abc" "ABC"))     (not (string-greaterp "ABC" "abc"))))
	(test-t (= (string-greaterp 'love 'hate) 0))
	(test-t (not (string-greaterp 'peace 'war)))
	(test-t (not (string-greaterp 'love 'love)))
	(test-t (not (string-greaterp #\a #\a)))
	(test-t (not (string-greaterp #\a #\b)))
	(test-t (= (string-greaterp #\z #\a) 0))
	(test-t (eql (string-not-greaterp "" "") 0))
	(test-t (eql (string-not-greaterp "dog" "dog") 3))
	(test-t (eql (string-not-greaterp " " " ") 1))
	(test-t (not (string-not-greaterp "abc" "")))
	(test-t (eql (string-not-greaterp "ab" "abc") 2))
	(test-t (eql (string-not-greaterp "aaa" "aba") 1))
	(test-t (not (string-not-greaterp "aba" "aaa")))
	(test-t (eql (string-not-greaterp "my cat food" "your dog food" :start1 6 :start2 8) 11))
	(test-t (eql (string-not-greaterp "cat food 2 dollars" "dog food 3 dollars"  :start1 3 :end1 9 :start2 3 :end2 9) 9))
	(test-t (eql (string-not-greaterp "xyzabc" "abcd" :start1 3) 6))
	(test-t (eql (string-not-greaterp "abc" "abc" :end1 1) 1))
	(test-t (eql (string-not-greaterp "xyzabc" "abc" :start1 3 :end1 5) 5))
	(test-t (eql (string-not-greaterp "xyz" "abcxyzXYZ" :start2 3) 3))
	(test-t (eql (string-not-greaterp "abc" "abcxyz" :end2 3) 3))
	(test-t (eql (string-not-greaterp "xyz" "abcxyz" :end1 2 :start2 3) 2))
	(test-t (eql (string-not-greaterp "xyzabc" "abcdef" :start1 3 :end2 3) 6))
	(test-t (eql (string-not-greaterp "aaaa" "z") 0))
	(test-t (eql (string-not-greaterp "pppTTTaTTTqqq" "pTTTxTTT" :start1 3 :start2 1) 6))
	(test-t (eql (string-not-greaterp "pppTTTaTTTqqq" "pTTTxTTT"  :start1 6 :end1 7	  :start2 4 :end2 5) 6))
	(test-t (and (eql (string-not-greaterp "abc" "ABC") 3)    (eql (string-not-greaterp "ABC" "abc") 3)))
	(test-t (not (string-not-greaterp 'love 'hate)))
	(test-t (= (string-not-greaterp 'peace 'war) 0))
	(test-t (= (string-not-greaterp 'love 'love) 4))
	(test-t (= (string-not-greaterp #\a #\a) 1))
	(test-t (= (string-not-greaterp #\a #\b) 0))
	(test-t (not (string-not-greaterp #\z #\a)))
	(test-t (eql (string-not-lessp "" "") 0))
	(test-t (eql (string-not-lessp "dog" "dog") 3))
	(test-t (eql (string-not-lessp " " " ") 1))
	(test-t (eql (string-not-lessp "abc" "") 0))
	(test-t (not (string-not-lessp "" "abc")))
	(test-t (not (string-not-lessp "ab" "abc")))
	(test-t (eql (string-not-lessp "abc" "ab") 2))
	(test-t (eql (string-not-lessp "aba" "aaa") 1))
	(test-t (not (string-not-lessp "aaa" "aba")))
	(test-t (eql (string-not-lessp "my cat food" "your dog food" :start1 6 :start2 8) 11))
	(test-t (eql (string-not-lessp "cat food 2 dollars" "dog food 3 dollars"  :start1 3 :end1 9 :start2 3 :end2 9) 9))
	(test-t (eql (string-not-lessp "xyzabcde" "abcd" :start1 3) 7))
	(test-t (not (string-not-lessp "abc" "abc" :end1 1)))
	(test-t (eql (string-not-lessp "xyzabc" "a" :start1 3 :end1 5) 4))
	(test-t (eql (string-not-lessp "xyzXYZ" "abcxyz" :start2 3) 3))
	(test-t (eql (string-not-lessp "abcxyz" "abcxyz" :end2 3) 3))
	(test-t (not (string-not-lessp "xyzXYZ" "abcxyz" :end1 2 :start2 3)))
	(test-t (eql (string-not-lessp "xyzabc" "abcdef" :start1 3 :end2 3) 6))
	(test-t (eql (string-not-lessp "z" "aaaa") 0))
	(test-t (eql (string-not-lessp "pTTTxTTTqqq" "pppTTTaTTT" :start1 1 :start2 3) 4))
	(test-t (eql (string-not-lessp "pppTTTxTTTqqq" "pTTTaTTT"       :start1 6 :end1 7       :start2 4 :end2 5) 6))
	(test-t (and (eql (string-not-lessp "abc" "ABC") 3)    (eql (string-not-lessp "ABC" "abc") 3)))
	(test-t (= (string-not-lessp 'love 'hate) 0))
	(test-t (not (string-not-lessp 'peace 'war)))
	(test-t (= (string-not-lessp 'love 'love) 4))
	(test-t (= (string-not-lessp #\a #\a) 1))
	(test-t (not (string-not-lessp #\a #\b)))
	(test-t (= (string-not-lessp #\z #\a) 0))
	(test-t (stringp "aaaaaa"))
	(test-t (not (stringp #\a)))
	(test-t (not (stringp 'a)))
	(test-t (not (stringp '(string))))
	(test-t (string= (cl-make-string 3 :initial-element #\a) "aaa"))
	(test-t (string= (cl-make-string 1 :initial-element #\space) " "))
	(test-t (string= (cl-make-string 0) ""))
	
	(test-t (null (dotimes (i 10))))
	(test-t (= (dotimes (temp-one 10 temp-one)) 10))
	(test-t (let ((temp-two 0)) (and (eq t (dotimes (temp-one 10 t) (incf temp-two)))  (eql temp-two 10))))
	(test-t (let ((count 0))  (eql (dotimes (i 5 count) (incf count)) 5)))
	(test-t (let ((count 0))  (eql (dotimes (i 1 count) (incf count)) 1)))
	(test-t (let ((count 0))  (zerop (dotimes (i 0 count) (incf count)))))
	(test-t (let ((count 0))  (zerop (dotimes (i -1 count) (incf count)))))
	(test-t (let ((count 0))  (zerop (dotimes (i -100 count) (incf count)))))
	(test-t (eql (dotimes (i 3 i)) 3))
	(test-t (eql (dotimes (i 2 i)) 2))
	(test-t (eql (dotimes (i 1 i)) 1))
	(test-t (eql (dotimes (i 0 i)) 0))
	(test-t (eql (dotimes (i -1 i)) 0))
	(test-t (eql (dotimes (i -2 i)) 0))
	(test-t (eql (dotimes (i -10 i)) 0))
	(test-t (let ((list nil))  (and (eq (dotimes (i 10 t) (push i list)) t)       (equal list '(9 8 7 6 5 4 3 2 1 0)))))
	(test-t (let ((list nil))  (equal (dotimes (i 10 (push i list)) (push i list))	 '(10 9 8 7 6 5 4 3 2 1 0))))
	(test-t (let ((list nil))  (equal (dotimes (i '10 (push i list)) (push i list))	 '(10 9 8 7 6 5 4 3 2 1 0))))
	(test-t (let ((list nil))  (equal (dotimes (i (/ 100 10) (push i list)) (push i list))	 '(10 9 8 7 6 5 4 3 2 1 0))))
	(test-t (= 3 (let ((i 3)) (dotimes (i i i) ))))
	(test-t (= 3 (let ((x 0)) (dotimes (i 3 x) (incf x)))))
	(test-t (= 3 (dotimes (i 3 i) )))
	(test-t (= 3 (let ((x 0)) (dotimes (i 3 x) (declare (fixnum i)) (incf x)))))
	(test-t (null (dolist (x '()))))
	(test-t (null (dolist (x '(a)))))
	(test-t (eq t (dolist (x nil t))))
	(test-t (= 6 (let ((sum 0))       (dolist (x '(0 1 2 3) sum)	 (incf sum x)))))
	(test-t (let ((temp-two '()))  (equal (dolist (temp-one '(1 2 3 4) temp-two) (push temp-one temp-two))	 '(4 3 2 1))))
	(test-t (let ((temp-two 0))  (and (null (dolist (temp-one '(1 2 3 4)) (incf temp-two)))       (eql temp-two 4))))
	(test-t (null (dolist (var nil var))))
	(test-t (let ((list nil))  (equal (dolist (var '(0 1 2 3) list)	   (push var list))	 '(3 2 1 0))))
	(test-t (null (dolist (var '(0 1 2 3)))))
	(test-t (eql (do ((temp-one 1 (1+ temp-one))	  (temp-two 0 (1- temp-two)))	 ((> (- temp-one temp-two) 5) temp-one))     4))
	(test-t (eql (do ((temp-one 1 (1+ temp-one))	  (temp-two 0 (1+ temp-one)))     	 ((= 3 temp-two) temp-one))     3))
	(test-t (eql (do* ((temp-one 1 (1+ temp-one))	   (temp-two 0 (1+ temp-one)))	 ((= 3 temp-two) temp-one))     2))
	
	(test-t (let ((a-vector (vector 1 nil 3 nil)))
		  (do ((i 0 (+ i 1))
		       (n (array-dimension a-vector 0)))
		      ((= i n))
		    (when (null (aref a-vector i))
			  (setf (aref a-vector i) 0)))
		  (equalp a-vector #(1 0 3 0))))
	
	(test-t (let ((vec (vector 0 1 2 3 4 5 6 7 8 9)))
		  (equalp (do ((i 0 (1+ i))
			       (n #f)
			       (j 9 (1- j)))
			      ((>= i j) vec)
			    (setq n (aref vec i))
			    (setf (aref vec i) (aref vec j))
			    (setf (aref vec j) n))
			  #(9 8 7 6 5 4 3 2 1 0))))
	
	(test-t (let ((vec (vector 0 1 2 3 4 5 6 7 8 9)))
		  (and (null (do ((i 0 (1+ i))
				  (n #f)
				  (j 9 (1- j)))
				 ((>= i j))
			       (setq n (aref vec i))
			       (setf (aref vec i) (aref vec j))
			       (setf (aref vec j) n)))
		       (equalp vec #(9 8 7 6 5 4 3 2 1 0)))))
	
	(test-t (let ((vec (vector 0 1 2 3 4 5 6 7 8 9)))
		  (and (null (do ((i 0 (1+ i))
				  (n #f)
				  (j 9 (1- j)))
				 ((>= i j))
			       (setq n (aref vec i))
			       (setf (aref vec i) (aref vec j))
			       (setf (aref vec j) n)))
		       (equalp vec #(9 8 7 6 5 4 3 2 1 0)))))
	
	(test-t (let ((vec (vector 0 1 2 3 4 5 6 7 8 9)))
		  (and (null (do ((i 0 (1+ i))
				  (n #f)
				  (j 9 (1- j)))
				 ((>= i j))
			       (setq n (aref vec i))
			       (setf (aref vec i) (aref vec j))
			       (setf (aref vec j) n)))
		       (equalp vec #(9 8 7 6 5 4 3 2 1 0)))))
	
	(test-t (let ((vec (vector 0 1 2 3 4 5 6 7 8 9)))
		  (and (null (do ((n #f)
				  (i 0 (1+ i))
				  (j 9 (1- j)))
				 ((>= i j))
			       (setq n (aref vec i))
			       (setf (aref vec i) (aref vec j))
			       (setf (aref vec j) n)))
		       (equalp vec #(9 8 7 6 5 4 3 2 1 0)))))
	
	(test-t (let ((vec (vector 0 1 2 3 4 5 6 7 8 9)))
		  (and (null (do ((i 0 (1+ i))
				  (j 9 (1- j))
				  (n #f))
				 ((>= i j))
			       (setq n (aref vec i))
			       (setf (aref vec i) (aref vec j))
			       (setf (aref vec j) n)))
		       (equalp vec #(9 8 7 6 5 4 3 2 1 0)))))
	
	(test-t (= (funcall (lambda (x) (+ x 3)) 4) 7))
	(test-t (= (funcall (lambda args (apply + args)) 1 2 3 4) 10))
	(test-t (functionp (lambda args (apply + args))))
	
	(test-t (consp (cons 'a 'b)))
	(test-t (consp '(1 . 2)))
	(test-t (consp (list nil)))
	(test-t (not (consp 'a)))
	(test-t (not (consp nil)))
	(test-t (not (consp 1)))
	(test-t (not (consp #\a)))
	(test-t (let ((a (cons 1 2))) (and (eql (car a) 1) (eql (cdr a) 2))))
	(test-t (equal (cons 1 nil) '(1)))
	(test-t (equal (cons nil nil) '(())))
	(test-t (equal (cons 'a (cons 'b (cons 'c '()))) '(a b c)))
	(test-t (atom 'a))
	(test-t (atom nil))
	(test-t (atom 1))
	(test-t (atom #\a))
	(test-t (not (atom (cons 1 2))))
	(test-t (not (atom '(a . b))))
	(test-t (not (atom (list nil))))
	(test-t (listp nil))
	(test-t (listp '(a b c)))
	(test-t (listp '(a . b)))
	(test-t (listp (cons 'a 'b)))
	(test-t (not (listp 1)))
	(test-t (not (listp 't)))
	(test-t (null '()))
	(test-t (null nil))
	(test-t (not (null t)))
	(test-t (null (cdr '(a))))
	(test-t (not (null (cdr '(1 . 2)))))
	(test-t (not (null 'a)))
	(test-t (endp '()))
	(test-t (not (endp '(1))))
	(test-t (not (endp '(1 2))))
	(test-t (not (endp '(1 2 3))))
	(test-t (not (endp (cons 1 2))))
	(test-t (endp (cddr '(1 2))))
	(test-t (let ((a (cons 1 2))) (and (eq (rplaca a 0) a) (equal a '(0 . 2)))))
	(test-t (let ((a (list 1 2 3))) (and (eq (rplaca a 0) a) (equal a '(0 2 3)))))
	(test-t (let ((a (cons 1 2))) (and (eq (rplacd a 0) a) (equal a '(1 . 0)))))
	(test-t (let ((a (list 1 2 3))) (and (eq (rplacd a 0) a) (equal a '(1 . 0)))))
	(test-t (eq (car '(a . b)) 'a))
	(test-t (let ((a (cons 1 2))) (eq (car (list a)) a)))
	(test-t (eq (cdr '(a . b)) 'b))
	(test-t (eq (rest '(a . b)) 'b))
	(test-t (let ((a (cons 1 2))) (eq (cdr (cons 1 a)) a)))
	(test-t (let ((a (cons 1 2))) (eq (rest (cons 1 a)) a)))
	(test-t (eq (caar '((a) b c)) 'a))
	(test-t (eq (cadr '(a b c)) 'b))
	(test-t (eq (cdar '((a . aa) b c)) 'aa))
	(test-t (eq (cddr '(a b . c)) 'c))
	(test-t (eq (caaar '(((a)) b c)) 'a))
	(test-t (eq (caadr '(a (b) c)) 'b))
	(test-t (eq (cadar '((a aa) b c)) 'aa))
	(test-t (eq (caddr '(a b c)) 'c))
	(test-t (eq (cdaar '(((a . aa)) b c)) 'aa))
	(test-t (eq (cdadr '(a (b . bb) c)) 'bb))
	(test-t (eq (cddar '((a aa . aaa) b c)) 'aaa))
	(test-t (eq (cdddr '(a b c . d)) 'd))
	(test-t (eq (caaaar '((((a))) b c)) 'a))
	(test-t (eq (caaadr '(a ((b)) c)) 'b))
	(test-t (eq (caadar '((a (aa)) b c)) 'aa))
	(test-t (eq (caaddr '(a b (c))) 'c))
	(test-t (eq (cadaar '(((a aa)) b c)) 'aa))
	(test-t (eq (cadadr '(a (b bb) c)) 'bb))
	(test-t (eq (caddar '((a aa aaa) b c)) 'aaa))
	(test-t (eq (cadddr '(a b c d)) 'd))
	(test-t (eq (cdaaar '((((a . aa))) b c)) 'aa))
	(test-t (eq (cdaadr '(a ((b . bb)) c)) 'bb))
	(test-t (eq (cdadar '((a (aa . aaa)) b c)) 'aaa))
	(test-t (eq (cdaddr '(a b (c . cc))) 'cc))
	(test-t (eq (cddaar '(((a aa . aaa)) b c)) 'aaa))
	(test-t (eq (cddadr '(a (b bb . bbb) c)) 'bbb))
	(test-t (eq (cdddar '((a aa aaa . aaaa) b c)) 'aaaa))
	(test-t (eq (cddddr '(a b c d . e)) 'e))
	(test-t (eq (copy-tree nil) nil))
	(test-t (let* ((a (list 'a))
		       (b (list 'b))
		       (c (list 'c))
		       (x3 (cons c nil))
		       (x2 (cons b x3))
		       (x (cons a x2))
		       (y (copy-tree x)))
		  (and (not (eq x y))
		       (not (eq (car x) (car y)))
		       (not (eq (cdr x) (cdr y)))
		       (not (eq (cadr x) (cadr y)))
		       (not (eq (cddr x) (cddr y)))
		       (not (eq (caddr x) (caddr y)))
		       (eq (cdddr x) (cdddr y))
		       (equal x y)
		       (eq (car x) a) (eq (car a) 'a) (eq (cdr a) nil)
		       (eq (cdr x) x2)
		       (eq (car x2) b) (eq (car b) 'b) (eq (cdr b) nil)
		       (eq (cdr x2) x3)
		       (eq (car x3) c) (eq (car c) 'c) (eq (cdr c) nil)
		       (eq (cdr x3) nil))))
	(test-t (let* ((x (list (list 'a 1) (list 'b 2) (list 'c 3)))
		       (y (copy-tree x)))
		  (and (not (eq (car x) (car y)))
		       (not (eq (cadr x) (cadr y)))
		       (not (eq (caddr x) (caddr y))))))
	(test-t (let* ((x (list (list (list 1))))
		       (y (copy-tree x)))
		  (and (not (eq x y))
		       (not (eq (car x) (car y)))
		       (not (eq (caar x) (caar y))))))
	(test-t (let ((x (list 'a 'b 'c 'd)))
		  (and (equal (sublis '((a . 1) (b . 2) (c . 3)) x)
			      '(1 2 3 d))
		       (equal x '(a b c d)))))
	(test-t (eq (sublis '() '()) '()))
	(test-t (equal (sublis '() '(1 2 3)) '(1 2 3)))
	(test-t (eq (sublis '((a . 1) (b . 2)) '()) nil))
	(test-t (equal (sublis '((a . 1) (b . 2) (c . 3)) '(((a)) (b) c)) '(((1)) (2) 3)))
	(test-t (equal (sublis '(((a) . 1) ((b) . 2) ((c) . 3)) '((((a))) ((b)) (c))) '((((a))) ((b)) (c))))
	(test-t (equal (sublis '(((a) . 1) ((b) . 2) ((c) . 3)) '((((a))) ((b)) (c)) :test equal) '(((1)) (2) 3)))
	(test-t (equal (nsublis '((a . 1) (b . 2) (c . 3)) (list 'a 'b 'c 'd)) '(1 2 3 d)))
	(test-t (let* ((x (list 'a 'b 'c 'd)) (y (nsublis '((a . 1) (b . 2) (c . 3)) x))) (and (eq x y) (equal x '(1 2 3 d)))))
	(test-t (let ((x (list 'l 'm 'n))) (and (eq (nsublis '((a . 1) (b . 2) (c . 3)) x) x) (equal x '(l m n)))))
	(test-t (let* ((n (cons 'n nil))
		       (m (cons 'm n))
		       (l (cons 'l m))
		       (x (nsublis '((a . 1) (b . 2) (c . 3)) l)))
		  (and (eq x l)
		       (eq (car l) 'l)
		       (eq (cdr l) m)
		       (eq (car m) 'm)
		       (eq (cdr m) n)
		       (eq (car n) 'n)
		       (eq (cdr n) nil))))
	(test-t (eq (nsublis '() '()) '()))
	(test-t (equal (nsublis '() '(1 2 3)) '(1 2 3)))
	(test-t (eq (nsublis '((a . 1) (b . 2)) '()) nil))
	(test-t (equal (nsublis '((a b c) (b c d) (c d e)) (list 'a 'b 'c)) '((b c) (c d) (d e))))
	(test-t (equal (nsublis '((a . 1) (b . 2) (c . 3)) (copy-tree '(((a)) (b) c))) '(((1)) (2) 3)))
	(test-t (equal (nsublis '(((a) . 1) ((b) . 2) ((c) . 3)) (copy-tree '((((a))) ((b)) (c)))) '((((a))) ((b)) (c))))
	(test-t (equal (nsublis '(((a) . 1) ((b) . 2) ((c) . 3)) (copy-tree '((((a))) ((b)) (c))) :test equal) '(((1)) (2) 3)))
	(test-t (let ((tree '(old (old) ((old))))) (equal (subst 'new 'old tree) '(new (new) ((new))))))
	(test-t (eq (subst 'new 'old 'old) 'new))
	(test-t (eq (subst 'new 'old 'not-old) 'not-old))
	(test-t (equal (subst 'new '(b) '(a ((b))) :test equal) '(a (new))))
	(test-t (equal (subst 'x 3 '(1 (1 2) (1 2 3) (1 2 3 4)) :key (lambda (y) (and (listp y) (third y)))) '(1 (1 2) x x)))
	(test-t (equal (subst 'x "D" '("a" ("a" "b") ("a" "b" "c") ("a" "b" "c" "d"))
			      :test equalp
			      :key (lambda (y) (and (listp y) (fourth y))))
		       '("a" ("a" "b") ("a" "b" "c") x)))
	(test-t (equal (subst-if 'new (lambda (x) (eq x 'old)) '(old old)) '(new new)))
	(test-t (eq (subst-if 'new (lambda (x) (eq x 'old)) 'old) 'new))
	(test-t (equal (subst-if 'x (lambda (x) (eql x 3)) '(1 (1 2) (1 2 3) (1 2 3 4)) :key (lambda (y) (and (listp y) (third y)))) '(1 (1 2) x x)))
	(test-t (let ((tree '(old (old) ((old))))) (equal (subst-if 'new (lambda (x) (eq x 'old)) tree) '(new (new) ((new))))))
	(test-t (eq (subst-if 'new (lambda (x) (eq x 'old)) 'old) 'new))
	(test-t (eq (subst-if 'new (lambda (x) (eq x 'old)) 'not-old) 'not-old))
	(test-t (equal (subst-if 'new (lambda (x) (equal x '(b))) '(a ((b)))) '(a (new))))
	(test-t (equal (subst-if 'x (lambda (x) (eql x 3)) '(1 (1 2) (1 2 3) (1 2 3 4)) :key (lambda (y) (and (listp y) (third y)))) '(1 (1 2) x x)))
	(test-t (equal (subst-if 'x
				 (lambda (x) (equalp x "D"))
				 '("a" ("a" "b") ("a" "b" "c") ("a" "b" "c" "d"))
				 :key (lambda (y) (and (listp y) (fourth y))))
		       '("a" ("a" "b") ("a" "b" "c") x)))
	(test-t (equal (subst-if-not 'new (lambda (x) (not (eq x 'old))) '(old old)) '(new new)))
	(test-t (eq (subst-if-not 'new (lambda (x) (not (eq x 'old))) 'old) 'new))
	(test-t (equal (subst-if-not 'x (lambda (x) (not (eql x 3)))
				     '(1 (1 2) (1 2 3) (1 2 3 4))
				     :key (lambda (y) (and (listp y) (third y))))
		       '(1 (1 2) x x)))
	(test-t (let ((tree '(old (old) ((old)))))
		  (equal (subst-if-not 'new (lambda (x) (not (eq x 'old))) tree)
			 '(new (new) ((new))))))
	(test-t (eq (subst-if-not 'new (lambda (x) (not (eq x 'old))) 'old) 'new))
	(test-t (eq (subst-if-not 'new (lambda (x) (not (eq x 'old))) 'not-old) 'not-old))
	(test-t (equal (subst-if-not 'new (lambda (x) (not (equal x '(b)))) '(a ((b)))) '(a (new))))
	(test-t (equal (subst-if-not 'x
				     (lambda (x) (not (eql x 3)))
				     '(1 (1 2) (1 2 3) (1 2 3 4))
				     :key (lambda (y) (and (listp y) (third y))))
		       '(1 (1 2) x x)))
	(test-t (equal (subst-if-not 'x
				     (lambda (x) (not (equalp x "D")))
				     '("a" ("a" "b") ("a" "b" "c") ("a" "b" "c" "d"))
				     :key (lambda (y) (and (listp y) (fourth y))))
		       '("a" ("a" "b") ("a" "b" "c") x)))
	(test-t (let ((tree '(old (old) ((old)))))
		  (equal (nsubst 'new 'old (copy-tree tree))
			 '(new (new) ((new))))))
	(test-t (let* ((tree (copy-tree '(old (old) ((old)))))
		       (new-tree (nsubst 'new 'old tree)))
		  (and (eq tree new-tree)
		       (equal tree '(new (new) ((new)))))))
	(test-t (eq (nsubst 'new 'old 'old) 'new))
	(test-t (eq (nsubst 'new 'old 'not-old) 'not-old))
	(test-t (equal (nsubst 'new '(b) (copy-tree '(a ((b)))) :test equal) '(a (new))))
	(test-t (equal (nsubst 'x 3 (copy-tree '(1 (1 2) (1 2 3) (1 2 3 4)))
			       :key (lambda (y) (and (listp y) (third y))))
		       '(1 (1 2) x x)))
	(test-t (equal (nsubst 'x "D"
			       (copy-tree '("a" ("a" "b") ("a" "b" "c") ("a" "b" "c" "d")))
			       :test equalp
			       :key (lambda (y) (and (listp y) (fourth y))))
		       '("a" ("a" "b") ("a" "b" "c") x)))
	(test-t (equal (nsubst-if 'new (lambda (x) (eq x 'old)) (list 'old 'old)) '(new new)))
	(test-t (eq (nsubst-if 'new (lambda (x) (eq x 'old)) 'old) 'new))
	(test-t (let* ((x (copy-tree '(old (old) ((old)) (old) old)))
		       (y (nsubst-if 'new (lambda (x) (eq x 'old)) x)))
		  (and (eq x y)
		       (equal x '(new (new) ((new)) (new) new)))))
	(test-t (equal (nsubst-if 'x
				  (lambda (x) (eql x 3))
				  (copy-tree '(1 (1 2) (1 2 3) (1 2 3 4)))
				  :key (lambda (y) (and (listp y) (third y))))
		       '(1 (1 2) x x)))
	(test-t (let ((tree '(old (old) ((old)))))
		  (equal (nsubst-if 'new (lambda (x) (eq x 'old)) (copy-tree tree))
			 '(new (new) ((new))))))
	(test-t (eq (nsubst-if 'new (lambda (x) (eq x 'old)) 'old) 'new))
	(test-t (eq (nsubst-if 'new (lambda (x) (eq x 'old)) 'not-old) 'not-old))
	(test-t (equal (nsubst-if 'new (lambda (x) (equal x '(b))) (copy-tree '(a ((b))))) '(a (new))))
	(test-t (equal (nsubst-if 'x
				  (lambda (x) (eql x 3))
				  (copy-tree '(1 (1 2) (1 2 3) (1 2 3 4)))
				  :key (lambda (y) (and (listp y) (third y))))
		       '(1 (1 2) x x)))
	(test-t (equal (nsubst-if 'x
				  (lambda (x) (equalp x "D"))
				  (copy-tree '("a" ("a" "b") ("a" "b" "c") ("a" "b" "c" "d")))
				  :key (lambda (y) (and (listp y) (fourth y))))
		       '("a" ("a" "b") ("a" "b" "c") x)))
	(test-t (equal (nsubst-if-not 'new (lambda (x) (not (eq x 'old)))
				      (list 'old 'old))
		       '(new new)))
	(test-t (eq (nsubst-if-not 'new (lambda (x) (not (eq x 'old))) 'old) 'new))
	(test-t (let* ((x (copy-tree '(old (old) ((old)) (old) old)))
		       (y (nsubst-if-not 'new (lambda (x) (not (eq x 'old))) x)))
		  (and (eq x y)
		       (equal x '(new (new) ((new)) (new) new)))))
	(test-t (equal (nsubst-if-not 'x (lambda (x) (not (eql x 3)))
				      (copy-tree '(1 (1 2) (1 2 3) (1 2 3 4)))
				      :key (lambda (y) (and (listp y) (third y))))
		       '(1 (1 2) x x)))
	(test-t (let ((tree '(old (old) ((old)))))
		  (equal (nsubst-if-not 'new (lambda (x) (not (eq x 'old))) (copy-tree tree))
			 '(new (new) ((new))))))
	(test-t (eq (nsubst-if-not 'new (lambda (x) (not (eq x 'old))) 'old) 'new))
	(test-t (eq (nsubst-if-not 'new (lambda (x) (not (eq x 'old))) 'not-old) 'not-old))
	(test-t (equal (nsubst-if-not 'new (lambda (x) (not (equal x '(b)))) (copy-tree '(a ((b))))) '(a (new))))
	(test-t (equal (nsubst-if-not 'x
				      (lambda (x) (not (eql x 3)))
				      (copy-tree '(1 (1 2) (1 2 3) (1 2 3 4)))
				      :key (lambda (y) (and (listp y) (third y))))
		       '(1 (1 2) x x)))
	(test-t (equal
		 (nsubst-if-not 'x
				(lambda (x) (not (equalp x "D")))
				(copy-tree '("a" ("a" "b") ("a" "b" "c") ("a" "b" "c" "d")))
				:key (lambda (y) (and (listp y) (fourth y))))
		 '("a" ("a" "b") ("a" "b" "c") x)))
	(test-t (tree-equal 'a 'a))
	(test-t (not (tree-equal 'a 'b)))
	(test-t (tree-equal '(a (b (c))) '(a (b (c)))))
	(test-t (tree-equal '(a (b (c))) '(a (b (c))) :test eq))
	(test-t (not (tree-equal '("a" ("b" ("c"))) '("a" ("b" ("c"))))))
	(test-t (tree-equal '("a" ("b" ("c"))) '("a" ("b" ("c"))) :test equal))
	(test-t (not (tree-equal '(a b) '(a (b)))))
	(test-t (eq (copy-list '()) '()))
	(test-t (equal (copy-list '(a b c)) '(a b c)))
	(test-t (equal (copy-list '(a . b)) '(a . b)))
	(test-t (let* ((x '(a b c)) (y (copy-list x))) (and (equal x y) (not (eq x y)))))
	(test-t (let* ((a (list 'a))
		       (b (list 'b))
		       (c (list 'c))
		       (x (list a b c))
		       (y (copy-list x)))
		  (and (equal x y)
		       (not (eq x y))
		       (eq (car x) (car y))
		       (eq (cadr x) (cadr y))
		       (eq (caddr x) (caddr y))
		       (eq (caar x) 'a)
		       (eq (caadr x) 'b)
		       (eq (caaddr x) 'c))))
	(test-t (null (list)))
	(test-t (equal (list 1) '(1)))
	(test-t (equal (list 1 2 3) '(1 2 3)))
	(test-t (equal (list* 1 2 '(3)) '(1 2 3)))
	(test-t (equal (list* 1 2 'x) '(1 2 . x)))
	(test-t (equal (list* 1 2 '(3 4)) '(1 2 3 4)))
	(test-t (eq (list* 'x) 'x))
	(test-t (eql (list-length '()) 0))
	(test-t (eql (list-length '(1)) 1))
	(test-t (eql (list-length '(1 2)) 2))
	(test-t (equal (cl-make-list 5) '(() () () () ())))
	(test-t (equal (cl-make-list 3 :initial-element 'rah) '(rah rah rah)))
	(test-t (equal (cl-make-list 2 :initial-element '(1 2 3)) '((1 2 3) (1 2 3))))
	(test-t (null (cl-make-list 0)))
	(test-t (null (cl-make-list 0 :initial-element 'new-element)))
	(test-t (let ((place nil)) (and (equal (push 0 place) '(0)) (equal place '(0)))))
	(test-t (let ((place (list 1 2 3))) (and (equal (push 0 place) '(0 1 2 3)) (equal place '(0 1 2 3)))))
	(test-t (let ((a (list (list 1 2 3) 9))) (and (equal (push 0 (car a)) '(0 1 2 3)) (equal a '((0 1 2 3) 9)))))
	(test-t (let ((place (list 1 2 3))) (and (eql (pop place) 1) (equal place '(2 3)))))
	(test-t (let ((a (list (list 1 2 3) 9))) (and (eql (pop (car a)) 1) (equal a '((2 3) 9)))))
	(test-t (let ((x (list 'a 'b 'c))) (and (eq (pop (cdr x)) 'b) (equal x '(a c)))))
	(test-t (eq (first '(a . b)) 'a))
	(test-t (null (first nil)))
	(test-t (let ((a (cons 1 2))) (eq (first (list a)) a)))
	(test-t (eql (first '(1 2 3)) '1))
	(test-t (eql (second '(1 2 3)) '2))
	(test-t (eql (third '(1 2 3)) '3))
	(test-t (eql (fourth '(1 2 3 4)) '4))
	(test-t (eql (fifth '(1 2 3 4 5)) '5))
	(test-t (eql (sixth '(1 2 3 4 5 6)) '6))
	(test-t (eql (seventh '(1 2 3 4 5 6 7)) '7))
	(test-t (eql (eighth '(1 2 3 4 5 6 7 8)) '8))
	(test-t (eql (ninth '(1 2 3 4 5 6 7 8 9)) '9))
	(test-t (eql (tenth '(1 2 3 4 5 6 7 8 9 10)) '10))
	(test-t (let ((x '(a b c))) (eq (nthcdr 0 x) x)))
	(test-t (let ((x '(a b c))) (eq (nthcdr 1 x) (cdr x))))
	(test-t (let ((x '(a b c))) (eq (nthcdr 2 x) (cddr x))))
	(test-t (let ((x '(a b c))) (eq (nthcdr 2 x) (cddr x))))
	(test-t (let ((x '(a b c))) (eq (nthcdr 3 x) (cdddr x))))
	(test-t (equal (nthcdr 0 '(0 1 2)) '(0 1 2)))
	(test-t (equal (nthcdr 1 '(0 1 2)) '(1 2)))
	(test-t (equal (nthcdr 2 '(0 1 2)) '(2)))
	(test-t (equal (nthcdr 3 '(0 1 2)) '()))
	(test-t (eql (nthcdr 1 '(0 . 1)) 1))
	(test-t (eql (nth 0 '(a b c)) 'a))
	(test-t (eql (nth 1 '(a b c)) 'b))
	(test-t (eql (nth 2 '(a b c)) 'c))
	(test-t (eql (nth 3 '(a b c)) '()))
	(test-t (eql (nth 4 '(a b c)) '()))
	(test-t (eql (nth 5 '(a b c)) '()))
	(test-t (eql (nth 6 '(a b c)) '()))
	(test-t (let ((x (list 'a 'b 'c))) (and (eq (setf (nth 0 x) 'z) 'z) (equal x '(z b c)))))
	(test-t (let ((x (list 'a 'b 'c))) (and (eq (setf (nth 1 x) 'z) 'z) (equal x '(a z c)))))
	(test-t (let ((x (list 'a 'b 'c))) (and (eq (setf (nth 2 x) 'z) 'z) (equal x '(a b z)))))
	(test-t (let ((0-to-3 (list 0 1 2 3))) (and (equal (setf (nth 2 0-to-3) "two") "two") (equal 0-to-3 '(0 1 "two" 3)))))
	(test-t (let* ((x (list 'a 'b 'c))) (eq (nconc x) x)))
	(test-t (let* ((x (list 'a 'b 'c))
		       (y (list 'd 'e 'f))
		       (list (nconc x y)))
		  (and (eq list x)
		       (eq (nthcdr 3 list) y)
		       (equal list '(a b c d e f)))))
	(test-t (let* ((x (list 'a))
		       (y (list 'b))
		       (z (list 'c))
		       (list (nconc x y z)))
		  (and (eq x list)
		       (eq (first list) 'a)
		       (eq y (cdr list))
		       (eq (second list) 'b)
		       (eq z (cddr list))
		       (eq (third list) 'c))))
	(test-t (equal (append '(a b) '() '(c d) '(e f)) '(a b c d e f)))
	(test-t (null (append)))
	(test-t (null (append '())))
	(test-t (null (append '() '())))
	(test-t (eq (append 'a) 'a))
	(test-t (eq (append '() 'a) 'a))
	(test-t (eq (append '() '() 'a) 'a))
	(test-t (equal (append '(a b) 'c) '(a b . c)))
	(test-t (let* ((x '(a b c))
		       (y '(d e f))
		       (z (append x y)))
		  (and (equal z '(a b c d e f))
		       (eq (nthcdr 3 z) y)
		       (not (eq x z)))))
	(test-t (equal (revappend '(a b c) '(d e f)) '(c b a d e f)))
	(test-t (let* ((x '(a b c))
		       (y '(d e f))
		       (z (revappend x y)))
		  (and (equal z '(c b a d e f))
		       (not (eq x z))
		       (eq (nthcdr 3 z) y))))
	(test-t (let ((x '(a b c))) (eq (revappend '() x) x)))
	(test-t (null (revappend '() '())))
	(test-t (eq (revappend '() 'a) 'a))
	(test-t (equal (revappend '(a) 'b) '(a . b)))
	(test-t (equal (revappend '(a) '()) '(a)))
	(test-t (equal (revappend '(1 2 3) '()) '(3 2 1)))
	(test-t (equal (nreconc (list 'a 'b 'c) '(d e f)) '(c b a d e f)))
	(test-t (let* ((x (list 'a 'b 'c))
		       (y '(d e f))
		       (z (nreconc x y)))
		  (and (equal z '(c b a d e f))
		       (eq (nthcdr 3 z) y))))
	(test-t (equal (nreconc (list 'a) 'b) '(a . b)))
	(test-t (equal (nreconc (list 'a) '()) '(a)))
	(test-t (equal (nreconc (list 1 2 3) '()) '(3 2 1)))
	(test-t (null (butlast nil)))
	(test-t (null (butlast nil 1)))
	(test-t (null (butlast nil 2)))
	(test-t (null (butlast nil 3)))
	(test-t (equal (butlast '(1 2 3 4 5)) '(1 2 3 4)))
	(test-t (equal (butlast '(1 2 3 4 5) 1) '(1 2 3 4)))
	(test-t (equal (butlast '(1 2 3 4 5) 2) '(1 2 3)))
	(test-t (equal (butlast '(1 2 3 4 5) 3) '(1 2)))
	(test-t (equal (butlast '(1 2 3 4 5) 4) '(1)))
	(test-t (equal (butlast '(1 2 3 4 5) 5) '()))
	(test-t (equal (butlast '(1 2 3 4 5) 6) '()))
	(test-t (equal (butlast '(1 2 3 4 5) 7) '()))
	(test-t (let ((a '(1 2 3 4 5))) (equal (butlast a 3) '(1 2)) (equal a '(1 2 3 4 5))))
	(test-t (null (nbutlast nil)))
	(test-t (null (nbutlast nil 1)))
	(test-t (null (nbutlast nil 2)))
	(test-t (null (nbutlast nil 3)))
	(test-t (equal (nbutlast (list 1 2 3 4 5)) '(1 2 3 4)))
	(test-t (equal (nbutlast (list 1 2 3 4 5) 1) '(1 2 3 4)))
	(test-t (equal (nbutlast (list 1 2 3 4 5) 2) '(1 2 3)))
	(test-t (equal (nbutlast (list 1 2 3 4 5) 3) '(1 2)))
	(test-t (equal (nbutlast (list 1 2 3 4 5) 4) '(1)))
	(test-t (equal (nbutlast (list 1 2 3 4 5) 5) '()))
	(test-t (equal (nbutlast (list 1 2 3 4 5) 6) '()))
	(test-t (equal (nbutlast (list 1 2 3 4 5) 7) '()))
	(test-t (equal (nbutlast (list* 1 2 3 4 5 6)) '(1 2 3 4)))
	(test-t (equal (nbutlast (list* 1 2 3 4 5 6) 1) '(1 2 3 4)))
	(test-t (equal (nbutlast (list* 1 2 3 4 5 6) 2) '(1 2 3)))
	(test-t (equal (nbutlast (list* 1 2 3 4 5 6) 3) '(1 2)))
	(test-t (equal (nbutlast (list* 1 2 3 4 5 6) 4) '(1)))
	(test-t (equal (nbutlast (list* 1 2 3 4 5 6) 5) '()))
	(test-t (equal (nbutlast (list* 1 2 3 4 5 6) 6) '()))
	(test-t (equal (nbutlast (list* 1 2 3 4 5 6) 7) '()))
	(test-t (let* ((a '(1 2 3 4 5)) (b (nbutlast a 3))) (and (eq a b) (equal a '(1 2)))))
	(test-t (let ((x '(0 1 2 3 4 5 6 7 8 9))) (eq (last x) (nthcdr 9 x))))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x 0) nil)))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x) (nthcdr 4 x))))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x 1) (nthcdr 4 x))))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x 2) (cdddr x))))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x 3) (cddr x))))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x 4) (cdr x))))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x 5) x)))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x 6) x)))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x 7) x)))
	(test-t (let ((x '(0 1 2 3 4))) (eq (last x 8) x)))
	(test-t (tailp '() '()))
	(test-t (tailp '() '(1)))
	(test-t (tailp '() '(1 2 3 4 5 6 7 8 9)))
	(test-t (let ((x '(1 2 3))) (and (tailp x x) (tailp (cdr x) x) (tailp (cddr x) x) (tailp (cdddr x) x))))
	(test-t (let ((x '(1 . 2))) (and (tailp x x) (tailp (cdr x) x))))
	(test-t (not (tailp 'x '(1 2 3 4 5 6))))
	(test-t (not (tailp (list 1 2 3) '(1 2 3))))
	(test-t (define (ldiff . args) #f))
	(test-t (null (ldiff '() '())))
	(test-t (equal (ldiff '(1 . 2) 2) '(1)))
	(test-t (equal (ldiff '(1 2 3 4 5 6 7 8 9) '()) '(1 2 3 4 5 6 7 8 9)))
	(test-t (let ((x '(1 2 3)))
		  (and (null (ldiff x x))
		       (equal (ldiff x (cdr x)) '(1))
		       (equal (ldiff x (cddr x)) '(1 2))
		       (equal (ldiff x (cdddr x)) '(1 2 3)))))
	(test-t (let* ((x '(1 2 3))
		       (y '(a b c))
		       (z (ldiff x y)))
		  (and (not (eq x z))
		       (equal z '(1 2 3)))))
	(test-t (equal (cl-member 'a '(a b c d)) '(a b c d)))
	(test-t (equal (cl-member 'b '(a b c d)) '(b c d)))
	(test-t (equal (cl-member 'c '(a b c d)) '(c d)))
	(test-t (equal (cl-member 'd '(a b c d)) '(d)))
	(test-t (equal (cl-member 'e '(a b c d)) '()))
	(test-t (equal (cl-member 'f '(a b c d)) '()))
	(test-t (let ((x '(a b c d)))
		  (eq (cl-member 'a x) x)
		  (eq (cl-member 'b x) (cdr x))
		  (eq (cl-member 'c x) (cddr x))
		  (eq (cl-member 'd x) (cdddr x))
		  (eq (cl-member 'e x) nil)))
	(test-t (equal (cl-member 'a '(a b c d) :test eq) '(a b c d)))
	(test-t (equal (cl-member 'b '(a b c d) :test eq) '(b c d)))
	(test-t (equal (cl-member 'c '(a b c d) :test eq) '(c d)))
	(test-t (equal (cl-member 'd '(a b c d) :test eq) '(d)))
	(test-t (equal (cl-member 'e '(a b c d) :test eq) '()))
	(test-t (equal (cl-member 'f '(a b c d) :test eq) '()))
	(test-t (null (cl-member 'a '())))
	(test-t (let* ((x '((1 . a) (2 . b) (3 . c) (4 . d) (5 . e)))
		       (y (cl-member 'd x :key cdr :test eq)))
		  (and (equal y '((4 . d) (5 . e)))
		       (eq y (nthcdr 3 x)))))
	(test-t (let* ((x '((1 . a) (2 . b) (3 . c) (4 . d) (5 . e)))
		       (y (cl-member 'd x :key cdr)))
		  (and (equal y '((4 . d) (5 . e)))
		       (eq y (nthcdr 3 x)))))
	(test-t (equal (member-if (lambda (x) (eql x 'a)) '(a b c d)) '(a b c d)))
	(test-t (equal (member-if (lambda (x) (eql x 'b)) '(a b c d)) '(b c d)))
	(test-t (equal (member-if (lambda (x) (eql x 'c)) '(a b c d)) '(c d)))
	(test-t (equal (member-if (lambda (x) (eql x 'd)) '(a b c d)) '(d)))
	(test-t (equal (member-if (lambda (x) (eql x 'e)) '(a b c d)) '()))
	(test-t (equal (member-if (lambda (x) (eql x 'f)) '(a b c d)) '()))
	(test-t (null (member-if (lambda (x) (eql x 'a)) '())))
	(test-t (let* ((x '((1 . a) (2 . b) (3 . c) (4 . d) (5 . e)))
		       (y (member-if (lambda (p) (eq p 'd)) x :key cdr)))
		  (and (equal y '((4 . d) (5 . e)))
		       (eq y (nthcdr 3 x)))))
	(test-t (null (member-if zerop '(7 8 9))))
	(test-t (equal (member-if-not (lambda (x) (not (eql x 'a))) '(a b c d)) '(a b c d)))
	(test-t (equal (member-if-not (lambda (x) (not (eql x 'b))) '(a b c d)) '(b c d)))
	(test-t (equal (member-if-not (lambda (x) (not (eql x 'c))) '(a b c d)) '(c d)))
	(test-t (equal (member-if-not (lambda (x) (not (eql x 'd))) '(a b c d)) '(d)))
	(test-t (equal (member-if-not (lambda (x) (not (eql x 'e))) '(a b c d)) '()))
	(test-t (equal (member-if-not (lambda (x) (not (eql x 'f))) '(a b c d)) '()))
	(test-t (null (member-if-not (lambda (x) (not (eql x 'a))) '())))
	
	(test-t (let* ((x '((1 . a) (2 . b) (3 . c) (4 . d) (5 . e)))
		       (y (member-if-not (lambda (p) (not (eq p 'd))) x :key cdr)))
		  (and (equal y '((4 . d) (5 . e)))
		       (eq y (nthcdr 3 x)))))
	
	(test-t (let ((dummy nil)
		      (list-1 '(1 2 3 4)))
		  (and (eq (mapc (lambda x (setq dummy (append dummy x)))
				 list-1
				 '(a b c d e)
				 '(x y z))
			   list-1)
		       (equal dummy '(1 a x 2 b y 3 c z)))))
	(test-t (let* ((x '(0 1 2 3))
		       (y nil)
		       (z (mapc (lambda (a b c) (push (list a b c) y))
				x '(1 2 3 4) '(2 3 4 5))))
		  (and (eq z x)
		       (equal y '((3 4 5) (2 3 4) (1 2 3) (0 1 2))))))
	(test-t (let* ((x '(0 1 2 3))
		       (y nil)
		       (z (mapc (lambda (a b c) (push (list a b c) y))
				nil x '(1 2 3 4) '(2 3 4 5))))
		  (and (null z)
		       (null y))))
	(test-t (let ((sum 0))
		  (mapc (lambda rest (setq sum (+ sum (apply + rest))))
			'(0 1 2)
			'(1 2 0)
			'(2 0 1))
		  (eql sum 9)))
	(test-t (let ((result 'initial-value)
		      (list-1 nil))
		  (and (eq (mapc (lambda (a b) (setq result (cons (cons a b) result))) list-1) list-1)
		       (eq result 'initial-value))))
	(test-t (let ((result 'initial-value)
		      (list-1 nil))
		  (and (eq (mapc (lambda (a b) (setq result (cons (cons a b) result)))
				 list-1
				 '(1 2 3))
			   list-1)
		       (eq result 'initial-value))))
	(test-t (let ((result 'initial-value)
		      (list-1 '(1 2 3)))
		  (and (eq (mapc (lambda (a b) (setq result (cons (cons a b) result)))
				 list-1
				 '())
			   list-1)
		       (eq result 'initial-value))))
	(test-t (equal (mapcar car '((1 2) (2 3) (3 4) (4 5))) '(1 2 3 4)))
	(test-t (null (mapcar identity '())))
	(test-t (equal (mapcar list '(0 1 2 3) '(a b c d) '(w x y z)) '((0 a w) (1 b x) (2 c y) (3 d z))))
	(test-t (null (mapcar list '() '(0 1 2 3) '(1 2 3 4) '(2 3 4 5))))
	(test-t (null (mapcar list '(0 1 2 3) '() '(1 2 3 4) '(2 3 4 5))))
	(test-t (null (mapcar list '(0 1 2 3) '(1 2 3 4) '() '(2 3 4 5))))
	(test-t (null (mapcar list '(0 1 2 3) '(1 2 3 4) '(2 3 4 5) '())))
	(test-t (equal (mapcar list '(0) '(a b) '(x y z)) '((0 a x))))
	(test-t (equal (mapcar list '(a b) '(0) '(x y z)) '((a 0 x))))
	(test-t (equal (mapcar list '(a b) '(x y z) '(0)) '((a x 0))))
	(test-t (equal (mapcar cons '(a b c) '(1 2 3)) '((a . 1) (b . 2) (c . 3))))
	(test-t (equal (mapcan cdr (copy-tree '((1 2) (2 3) (3 4) (4 5)))) '(2 3 4 5)))
	(test-t (equal (mapcan append
			       '((1 2 3) (4 5 6) (7 8 9))
			       '((a) (b c) (d e f))
			       (list (list 'x 'y 'z) (list 'y 'z) (list 'z)))
		       '(1 2 3 a x y z 4 5 6 b c y z 7 8 9 d e f z)))
	(test-t (null (mapcan append '((1 2 3) (4 5 6) (7 8 9)) '((a) (b c)) '())))
	(test-t (null (mapcan append '((1 2 3) (4 5 6) (7 8 9)) '() '((a) (b c)))))
	(test-t (null (mapcan append '() '((1 2 3) (4 5 6) (7 8 9)) '((a) (b c)))))
	(test-t (equal (mapcan list
			       (list 1 2 3 4 5)
			       (list 2 3 4 5 6)
			       (list 3 4 5 6 7)
			       (list 4 5 6 7 8))
		       '(1 2 3 4 2 3 4 5 3 4 5 6 4 5 6 7 5 6 7 8)))
	(test-t (equal (mapcan (lambda (x y) (if (null x) '() (list x y)))
			       '(() () () d e)
			       '(1 2 3 4 5 6))
		       '(d 4 e 5)))
	(test-t (equal (mapcan (lambda (x) (if (numberp x) (list x) '()))
			       '(a 1 b c 3 4 d 5))
		       '(1 3 4 5)))
	(test-t (equal (maplist identity '(a b c d)) '((a b c d) (b c d) (c d) (d))))
	(test-t (equal (maplist car '((1 2) (2 3) (3 4) (4 5))) '((1 2) (2 3) (3 4) (4 5))))
	(test-t (equal (maplist list '(a b c) '(b c d) '(c d e))
		       '(((a b c) (b c d) (c d e))
			 ((b c) (c d) (d e))
			 ((c) (d) (e)))))
	(test-t (equal (maplist append '(a b c) '(b c d) '(c d e)) '((a b c b c d c d e) (b c c d d e) (c d e))))
	(test-t (equal (maplist append '(a b c) '(b c) '(c)) '((a b c b c c))))
	(test-t (null (maplist append '() '(a b c) '(b c) '(c))))
	(test-t (null (maplist append '(a b c) '() '(b c) '(c))))
	(test-t (null (maplist append '(a b c) '(b c) '(c) '())))
	(test-t (let ((x '((1 2) (2 3) (3 4) (4 5)))
		      (y nil))
		  (and (eq (mapl (lambda (a) (push (car a) y)) x) x)
		       (equal y '((4 5) (3 4) (2 3) (1 2))))))
	(test-t (let ((x nil))
		  (and (null (mapl (lambda rest (push rest x)) '() '(0) '(0 1)))
		       (null x))))
	(test-t (let ((x nil))
		  (and (equal (mapl (lambda rest (push rest x)) '(0) '() '(0 1))
			      '(0))
		       (null x))))
	(test-t (let ((x nil))
		  (and (equal (mapl (lambda rest (push rest x)) '(0) '(0 1) '())
			      '(0))
		       (null x))))
	(test-t (equal (mapcon car (copy-tree '((1 2) (2 3) (3 4) (4 5)))) '(1 2 2 3 3 4 4 5)))
	(test-t (equal (mapcon list '(0 1 2 3) '(1 2 3 4) '(2 3 4 5) '(3 4 5 6))
		       '((0 1 2 3) (1 2 3 4) (2 3 4 5) (3 4 5 6) (1 2 3) (2 3 4) (3 4 5)
			 (4 5 6) (2 3) (3 4) (4 5) (5 6) (3) (4) (5) (6))))
	(test-t (null (mapcon list '() '(0 1 2 3) '(1 2 3 4) '(2 3 4 5) '(3 4 5 6))))
	(test-t (null (mapcon list '(0 1 2 3) '() '(1 2 3 4) '(2 3 4 5) '(3 4 5 6))))
	(test-t (null (mapcon list '(0 1 2 3) '(1 2 3 4) '() '(2 3 4 5) '(3 4 5 6))))
	(test-t (null (mapcon list '(0 1 2 3) '(1 2 3 4) '(2 3 4 5) '() '(3 4 5 6))))
	(test-t (null (mapcon list '(0 1 2 3) '(1 2 3 4) '(2 3 4 5) '(3 4 5 6) '())))
	(test-t (let* ((x '((apple . 1) (orange . 2) (grapes . 3)))
		       (y (acons 'plum 9 x)))
		  (and (equal y '((plum . 9) (apple . 1) (orange . 2) (grapes . 3)))
		       (eq x (cdr y)))))
	(test-t (equal (acons 'a '0 nil) '((a . 0))))
	(test-t (equal (acons 'apple 1 (acons 'orange 2 (acons 'grapes '3 nil))) '((apple . 1) (orange . 2) (grapes . 3))))
	(test-t (equal (acons () () ()) '((()))))
	(test-t (let ((alist '((x . 100) (y . 200) (z . 50)))) (eq (cl-assoc 'y alist) (cadr alist))))
	(test-t (null (cl-assoc 'no-such-key '((x . 100) (y . 200) (z . 50)))))
	(test-t (let ((alist '((x . 100) (y . 200) (z . 50)))) (eq (cl-assoc 'y alist :test eq) (cadr alist))))
	(test-t (null (cl-assoc 'key '())))
	(test-t (null (cl-assoc '() '(()))))
	(test-t (null (cl-assoc '() '(() ()))))
	(test-t (let ((alist '(() () () (x . 100) (y . 200) (z . 50)))) (eq (cl-assoc 'y alist) (car (cddddr alist)))))
	(test-t (let ((alist '((1 . a) () (2 . b) (())))) (eq (cl-assoc '() alist) (cadddr alist))))
	(test-t (let ((alist '((x . 100) (y . 200) (x . 100) (z . 50)))) (eq (cl-assoc 'y alist) (cadr alist))))
	(test-t (let ((alist '((x . 100) (y . 200) (z . 50)))) (eq (assoc-if (lambda (arg) (eq arg 'y)) alist) (cadr alist))))
	(test-t (null (assoc-if consp '((x . 100) (y . 200) (z . 50)))))
	(test-t (null (assoc-if (lambda (x) (eq x 'key)) '())))
	(test-t (null (assoc-if identity '(()))))
	(test-t (null (assoc-if identity '(() ()))))
	(test-t (let ((alist '(() () () (x . 100) (y . 200) (z . 50)))) (eq (assoc-if (lambda (arg) (eq arg 'y)) alist) (car (cddddr alist)))))
	(test-t (let ((alist '((1 . a) () (2 . b) (())))) (eq (assoc-if (lambda (arg) (null arg)) alist) (cadddr alist))))
	(test-t (let ((alist '((x . 100) (y . 200) (z . 50)))) (eq (assoc-if-not (lambda (arg) (not (eq arg 'y))) alist) (cadr alist))))
	(test-t (null (assoc-if-not (complement consp) '((x . 100) (y . 200) (z . 50)))))
	(test-t (null (assoc-if-not (lambda (x) (not (eq x 'key))) '())))
	(test-t (null (assoc-if-not identity '(()))))
	(test-t (null (assoc-if-not identity '(() ()))))
	(test-t (let ((alist '(() () () (x . 100) (y . 200) (z . 50))))
		  (eq (assoc-if-not (lambda (arg) (not (eq arg 'y))) alist)
		      (car (cddddr alist)))))
	(test-t (equal (copy-alist '((a . 10) (b . 100) (c . 1000)))
		       '((a . 10) (b . 100) (c . 1000))))
	(test-t (let* ((alist '((a . 10) (b . 100) (c . 1000)))
		       (copy (copy-alist alist)))
		  (and (not (eq alist copy))
		       (not (eq (cdr alist) (cdr copy)))
		       (not (eq (cddr alist) (cddr copy)))
		       (not (eq (car alist) (car copy)))
		       (not (eq (cadr alist) (cadr copy)))
		       (not (eq (caddr alist) (caddr copy))))))
	(test-t (let* ((alist '((a 10 x) (b 100 y) (c 1000 z)))
		       (copy (copy-alist alist)))
		  (and (not (eq alist copy))
		       (not (eq (cdr alist) (cdr copy)))
		       (not (eq (cddr alist) (cddr copy)))
		       (not (eq (car alist) (car copy)))
		       (not (eq (cadr alist) (cadr copy)))
		       (not (eq (caddr alist) (caddr copy)))
		       (eq (cdar alist) (cdar copy))
		       (eq (cdadr alist) (cdadr copy))
		       (eq (cdaddr alist) (cdaddr copy)))))
	(test-t (let* ((alist (pairlis '(x y z) '(xx yy zz) '((a . aa) (b . bb)))))
		  (and (equal (cl-assoc 'x alist) '(x . xx))
		       (equal (cl-assoc 'y alist) '(y . yy))
		       (equal (cl-assoc 'z alist) '(z . zz))
		       (equal (cl-assoc 'a alist) '(a . aa))
		       (equal (cl-assoc 'b alist) '(b . bb))
		       (null (cl-assoc 'key alist)))))
	(test-t (let* ((alist (pairlis '(x y z) '(xx yy zz))))
		  (and (equal (cl-assoc 'x alist) '(x . xx))
		       (equal (cl-assoc 'y alist) '(y . yy))
		       (equal (cl-assoc 'z alist) '(z . zz))
		       (null (cl-assoc 'key alist)))))
	(test-t (let ((alist '((x . 100) (y . 200) (z . 50)))) (eq (rassoc '200 alist) (cadr alist))))
	(test-t (null (rassoc 'no-such-datum '((x . 100) (y . 200) (z . 50)))))
	(test-t (let ((alist '((x . 100) (y . 200) (z . 50)))) (eq (rassoc '200 alist :test =) (cadr alist))))
	(test-t (null (rassoc 'key '())))
	(test-t (null (rassoc '() '(()))))
	(test-t (null (rassoc '() '(() ()))))
	(test-t (let ((alist '(() () () (x . 100) (y . 200) (z . 50)))) (eq (rassoc '200 alist) (car (cddddr alist)))))
	(test-t (let ((alist '((1 . a) () (2 . b) (())))) (eq (rassoc '() alist) (cadddr alist))))
	(test-t (let ((alist '((x . 100) (y . 200) (x . 100) (z . 50)))) (eq (rassoc '200 alist) (cadr alist))))
	(test-t (let ((alist '((x . 100) (y . 200) (z . 50)))) (eq (rassoc-if (lambda (arg) (= arg 200)) alist) (cadr alist))))
	(test-t (null (rassoc-if consp '((x . 100) (y . 200) (z . 50)))))
	(test-t (null (rassoc-if (lambda (x) (eq x 'key)) '())))
	(test-t (null (rassoc-if identity '(()))))
	(test-t (null (rassoc-if identity '(() ()))))
	(test-t (let ((alist '(() () () (x . 100) (y . 200) (z . 50)))) (eq (rassoc-if (lambda (arg) (= arg 200)) alist) (car (cddddr alist)))))
	(test-t (let ((alist '((1 . a) () (2 . b) (())))) (eq (rassoc-if (lambda (arg) (null arg)) alist) (cadddr alist))))
	(test-t (let ((alist '((x . 100) (y . 200) (z . 50)))) (eq (rassoc-if-not (lambda (arg) (not (= arg 200))) alist) (cadr alist))))
	(test-t (null (rassoc-if-not (complement consp) '((x . 100) (y . 200) (z . 50)))))
	(test-t (null (rassoc-if-not (lambda (x) (not (eq x 'key))) '())))
	(test-t (null (rassoc-if-not identity '(()))))
	(test-t (null (rassoc-if-not identity '(() ()))))
	(test-t (let ((alist '(() () () (x . 100) (y . 200) (z . 50))))
		  (eq (rassoc-if-not (lambda (arg) (not (= arg 200))) alist)
		      (car (cddddr alist)))))
	(let ((list1 (list 1 1 2 3 4 'a 'b 'c "A" "B" "C" "d"))
	      (list2 (list 1 4 5 'b 'c 'd "a" "B" "c" "D")))
	  (test-t (null (set-exclusive-or (intersection list1 list2) '(c b 4 1 1))))
	  (test-t (null (set-exclusive-or (intersection list1 list2 :test equal)
					  '("B" c b 4 1 1)
					  :test equal)))
	  (test-t (null (set-exclusive-or (intersection list1 list2 :test equalp)
					  '("d" "C" "B" "A" c b 4 1 1)
					  :test equalp))))
	(test-t (null (intersection '(0 1 2) '())))
	(test-t (null (intersection '() '())))
	(test-t (null (intersection '() '(0 1 2))))
	(test-t (equal (intersection '(0) '(0)) '(0)))
	(test-t (equal (intersection '(0 1 2 3) '(2)) '(2)))
	(test-t (cl-member 0 (intersection '(0 0 0 0 0) '(0 1 2 3 4 5))))
	(test-t (null (set-exclusive-or (intersection '(0 1 2 3 4) '(4 3 2 1 0)) '(4 3 2 1 0))))
	(test-t (null (set-exclusive-or (intersection '(0 1 2 3 4) '(0 1 2 3 4)) '(0 1 2 3 4))))
	(test-t (null (set-exclusive-or (intersection '(0 1 2 3 4) '(4 3 2 1 0)) '(0 1 2 3 4))))
	(test-t (let ((list1 (list "A" "B" "C" "d" "e" "F" "G" "h"))
		      (list2 (list "a" "B" "c" "D" "E" "F" "g" "h")))
		  (null (set-exclusive-or (intersection list1 list2
							:test char=
							:key (lambda (x) (char x 0)))
					  '("B" "F" "h")
					  :test char=
					  :key (lambda (x) (char x 0))))))
	(test-t (let ((list1 (list "A" "B" "C" "d" "e" "F" "G" "h"))
		      (list2 (list "a" "B" "c" "D" "E" "F" "g" "h")))
		  (null (set-exclusive-or (intersection list1 list2
							:test char-equal
							:key (lambda (x) (char x 0)))
					  '("A" "B" "C" "d" "e" "F" "G" "h")
					  :test char-equal
					  :key (lambda (x) (char x 0))))))
	(test-t (let ((list1 (list "A" "B" "C" "d"))
		      (list2 (list "D" "E" "F" "g" "h")))
		  (null (set-exclusive-or (intersection list1 list2
							:test char-equal
							:key (lambda (x) (char x 0)))
					  '("d")
					  :test char-equal
					  :key (lambda (x) (char x 0))))))
	(let ((list1 (list 1 1 2 3 4 'a 'b 'c "A" "B" "C" "d"))
	      (list2 (list 1 4 5 'b 'c 'd "a" "B" "c" "D")))
	  (test-t (null (set-exclusive-or (nintersection (copy-list list1) list2) '(c b 4 1 1))))
	  (test-t (null (set-exclusive-or (nintersection (copy-list list1) list2 :test equal)
					  '("B" c b 4 1 1)
					  :test equal)))
	  (test-t (null (set-exclusive-or (nintersection (copy-list list1) list2 :test equalp)
					  '("d" "C" "B" "A" c b 4 1 1)
					  :test equalp))))
	(test-t (null (nintersection (list 0 1 2) '())))
	(test-t (null (nintersection '() '())))
	(test-t (null (nintersection '() '(0 1 2))))
	(test-t (equal (nintersection (list 0) '(0)) '(0)))
	(test-t (equal (nintersection (list 0 1 2 3) '(2)) '(2)))
	(test-t (cl-member 0 (nintersection (list 0 0 0 0 0) '(0 1 2 3 4 5))))
	(test-t (null (set-exclusive-or (nintersection (list 0 1 2 3 4) '(4 3 2 1 0)) '(4 3 2 1 0))))
	(test-t (null (set-exclusive-or (nintersection (list 0 1 2 3 4) '(0 1 2 3 4)) '(0 1 2 3 4))))
	(test-t (null (set-exclusive-or (nintersection (list 0 1 2 3 4) '(4 3 2 1 0)) '(0 1 2 3 4))))
	(test-t (let ((list1 (list "A" "B" "C" "d" "e" "F" "G" "h"))
		      (list2 (list "a" "B" "c" "D" "E" "F" "g" "h")))
		  (null (set-exclusive-or (nintersection list1 list2
							 :test char=
							 :key (lambda (x) (char x 0)))
					  '("B" "F" "h")
					  :test char=
					  :key (lambda (x) (char x 0))))))
	(test-t (let ((list1 (list "A" "B" "C" "d" "e" "F" "G" "h"))
		      (list2 (list "a" "B" "c" "D" "E" "F" "g" "h")))
		  (null (set-exclusive-or (nintersection list1 list2
							 :test char-equal
							 :key (lambda (x) (char x 0)))
					  '("A" "B" "C" "d" "e" "F" "G" "h")
					  :test char-equal
					  :key (lambda (x) (char x 0))))))
	(test-t (let ((list1 (list "A" "B" "C" "d"))
		      (list2 (list "D" "E" "F" "g" "h")))
		  (null (set-exclusive-or (nintersection list1 list2
							 :test char-equal
							 :key (lambda (x) (char x 0)))
					  '("d")
					  :test char-equal
					  :key (lambda (x) (char x 0))))))
	(test-t (let ((set '(a b c))) (eq (adjoin 'a set) set)))
	(test-t (let* ((set '(a b c)) (new-set (adjoin 'x set))) (and (equal new-set '(x a b c)) (eq set (cdr new-set)))))
	(test-t (equal (adjoin 1 nil) '(1)))
	(test-t (let ((set '((test-item 1)))) (equal (adjoin '(test-item 1) set) '((test-item 1) (test-item 1)))))
	(test-t (let ((set '((test-item 1)))) (equal (adjoin '(test-item 1) set) '((test-item 1) (test-item 1)))))
	(test-t (let ((set '((test-item 1)))) (eq (adjoin '(test-item 1) set :test equal) set)))
	(test-t (let ((set '((test-item 1)))) (eq (adjoin '(test-item) set :key car) set)))
	(test-t (let ((set '((test-item 1)))) (eq (adjoin '(test-item) set :key car :test eq) set)))
	(test-t (let ((set '(("test-item" 1)))) (eq (adjoin '("test-item") set :key car :test equal) set)))
	(test-t (let ((place nil)) (and (equal (pushnew 'a place) '(a)) (equal place '(a)))))
	(test-t (let ((place nil)) (and (equal (pushnew 'a place) '(a)) (equal place '(a)))))
	(test-t (let ((place '("love" "peace")))
		  (equal (pushnew "war" place :test equal) '("war" "love" "peace"))))
	(test-t (let ((place '("love" "peace")))
		  (and (eq (pushnew "peace" place :test equal) place)
		       (equal place '("love" "peace")))))
	(test-t (let ((place '(("love" . l) ("peace" . p))))
		  (equal (pushnew '("war" . w) place :test equal :key car)
			 '(("war" . w) ("love" . l) ("peace" . p)))))
	(test-t (let ((place '(("love" . l) ("peace" . p))))
		  (and (eq (pushnew '("love" . l) place :test equal :key car) place)
		       (equal place '(("love" . l) ("peace" . p))))))
	(test-t (let* ((list '((1) (1 2) (1 2 3)))
		       (original list))
		  (and (equal (pushnew '(1) list :test equal) '((1) (1 2) (1 2 3)))
		       (eq list original))))
	(test-t (let* ((list '((1) (1 2) (1 2 3)))
		       (original list))
		  (and (equal (pushnew '(1) list :test equal :key nil) '((1) (1 2) (1 2 3)))
		       (eq list original))))
	(test-t (null (set-difference (set-difference '(1 2 3 4 5 6 7 8 9)
						      '(2 4 6 8))
				      '(1 3 5 7 9))))
	(test-t (null (nset-difference (set-difference (list 1 2 3 4 5 6 7 8 9)
						       '(2 4 6 8))
				       '(1 3 5 7 9))))
	(test-t (null (set-difference '() '())))
	(test-t (null (set-difference '() '() :test equal :key 'identity)))
	(test-t (null (nset-difference '() '())))
	(test-t (null (set-difference '() '(1 2 3))))
	(test-t (null (set-difference '() '(1 2 3) :test equal :key 'identity)))
	(test-t (null (nset-difference '() '(1 2 3))))
	(test-t (null (set-difference '(1 2 3 4) '(4 3 2 1))))
	(test-t (null (nset-difference (list 1 2 3 4) '(4 3 2 1))))
	(test-t (null (set-difference '(1 2 3 4) '(2 4 3 1))))
	(test-t (null (nset-difference (list 1 2 3 4) '(2 4 3 1))))
	(test-t (null (set-difference '(1 2 3 4) '(1 3 4 2))))
	(test-t (null (nset-difference (list 1 2 3 4) '(1 3 4 2))))
	(test-t (null (set-difference '(1 2 3 4) '(1 3 2 4))))
	(test-t (null (nset-difference (list 1 2 3 4) '(1 3 2 4))))
	(test-t (eq (set-difference (set-difference '(1 2 3) '()) '(1 2 3)) '()))
	(test-t (eq (nset-difference (nset-difference (list 1 2 3) '()) '(1 2 3)) '()))
	(test-t (eq (set-difference (set-difference '(1 2 3) '(1)) '(2 3)) '()))
	(test-t (eq (nset-difference (nset-difference (list 1 2 3) '(1)) '(2 3)) '()))
	(test-t (eq (set-difference (set-difference '(1 2 3) '(1 2)) '(3)) '()))
	(test-t (eq (nset-difference (nset-difference (list 1 2 3) '(1 2)) '(3)) '()))
	(test-t (null (set-exclusive-or (set-exclusive-or '(1 2 3) '(2 3 4)) '(1 4))))
	(test-t (null (nset-exclusive-or (nset-exclusive-or (list 1 2 3) '(2 3 4)) '(1 4))))
	(test-t (null (set-exclusive-or (set-exclusive-or '(1 2 3) '(1 3)) '(2))))
	(test-t (null (nset-exclusive-or (nset-exclusive-or (list 1 2 3) '(1 3)) '(2))))
	(test-t (null (set-exclusive-or '() '())))
	(test-t (null (nset-exclusive-or '() '())))
	(test-t (null (set-exclusive-or '(1 2 3) '(3 2 1))))
	(test-t (null (nset-exclusive-or (list 1 2 3) '(3 2 1))))
	(test-t (null (set-exclusive-or '(1 2 3) '(2 3 1))))
	(test-t (null (nset-exclusive-or (list 1 2 3) '(2 3 1))))
	(test-t (null (set-exclusive-or '(1 2 3) '(1 3 2))))
	(test-t (null (nset-exclusive-or (list 1 2 3) '(1 3 2))))
	(test-t (null (set-exclusive-or (set-exclusive-or '(1 2 3) '()) '(3 2 1))))
	(test-t (null (nset-exclusive-or (nset-exclusive-or (list 1 2 3) '()) '(3 2 1))))
	(test-t (null (set-exclusive-or (set-exclusive-or '() '(1 2 3)) '(2 1 3))))
	(test-t (null (nset-exclusive-or (nset-exclusive-or '() '(1 2 3)) '(2 1 3))))
	(test-t (null (set-exclusive-or '("car" "ship" "airplane" "submarine")
					'("car" "ship" "airplane" "submarine")
					:test equal)))
	(test-t (null (nset-exclusive-or (copy-list '("car" "ship" "airplane" "submarine"))
					 '("car" "ship" "airplane" "submarine")
					 :test equal)))
	(test-t (null (set-exclusive-or '("car" "ship" "airplane" "submarine")
					'("CAR" "SHIP" "AIRPLANE" "SUBMARINE")
					:test equalp)))
	(test-t (null (nset-exclusive-or (copy-list '("car" "ship" "airplane" "submarine"))
					 '("CAR" "SHIP" "AIRPLANE" "SUBMARINE")
					 :test equalp)))
	(test-t (null (set-exclusive-or '(("car") ("ship") ("airplane") ("submarine"))
					'(("car") ("ship") ("airplane") ("submarine"))
					:test string=
					:key car)))
	(test-t (null (nset-exclusive-or (copy-tree
					  '(("car") ("ship") ("airplane") ("submarine")))
					 '(("car") ("ship") ("airplane") ("submarine"))
					 :test string=
					 :key car)))
	(test-t (subsetp '(1 2 3) '(1 2 3)))
	(test-t (subsetp '(1 2 3) '(3 2 1)))
	(test-t (subsetp '(1 2 3) '(2 1 3)))
	(test-t (null (subsetp '(1 2 3 4) '(2 1 3))))
	(test-t (subsetp '(1) '(2 1 3)))
	(test-t (subsetp '(1 2) '(1 2 3 4 5 6 7 8)))
	(test-t (subsetp '(1 2 3 4 5) '(8 7 6 5 4 3 2 1)))
	(test-t (null (subsetp '("car" "ship" "airplane" "submarine") '("car" "ship" "horse" "airplane" "submarine" "camel"))))
	(test-t (subsetp '("car" "ship" "airplane" "submarine")
			 '("car" "ship" "horse" "airplane" "submarine" "camel")
			 :test equal))
	(test-t (subsetp '("CAR" "SHIP" "AIRPLANE" "SUBMARINE")
			 '("car" "ship" "horse" "airplane" "submarine" "camel")
			 :test equalp))
	(test-t (subsetp '(("car") ("ship") ("airplane") ("submarine"))
			 '(("car") ("ship") ("horse") ("airplane") ("submarine") ("camel"))
			 :test string=
			 :key car))
	(test-t (null (union '() '())))
	(test-t (null (nunion '() '())))
	(test-t (null (set-difference (union '(1 2 3) '(2 3 4)) '(1 2 3 4))))
	(test-t (null (set-difference (nunion (list 1 2 3) (list 2 3 4)) '(1 2 3 4))))
	(test-t (null (set-difference (union '(1 2 3) '(1 2 3)) '(1 2 3))))
	(test-t (null (set-difference (nunion (list 1 2 3) (list 1 2 3)) '(1 2 3))))
	(test-t (null (set-difference (union '(1) '(3 2 1)) '(1 2 3))))
	(test-t (null (set-difference (nunion (list 1) (list 3 2 1)) '(1 2 3))))
	(test-t (null (set-difference (union '(1 2 3) '()) '(1 2 3))))
	(test-t (null (set-difference (nunion (list 1 2 3) '()) '(1 2 3))))
	(test-t (null (set-difference (union '() '(1 2 3)) '(1 2 3))))
	(test-t (null (set-difference (nunion '() (list 1 2 3)) '(1 2 3))))
	(test-t (null (set-difference (union '(1 2 3) '(2)) '(1 2 3))))
	(test-t (null (set-difference (nunion (list 1 2 3) (list 2)) '(1 2 3))))
	
	(test-t (eql (length "abc") 3))
	(test-t (zerop (length "")))
	(test-t (zerop (length #())))
	(test-t (zerop (length ())))
	(test-t (eql (length '(0)) 1))
	(test-t (eql (length '(0 1)) 2))
	(test-t (eql (length '(0 1 2)) 3))
	(test-t (eql (length '(0 1 2 3)) 4))
	(test-t (eql (length '(0 1 2 3 4)) 5))
	(test-t (eql (length '(0 1 2 3 4 5)) 6))
	(test-t (eql (length '(0 1 2 3 4 5 6)) 7))
	(test-t (eql (length #(0)) 1))
	(test-t (eql (length #(0 1)) 2))
	(test-t (eql (length #(0 1 2)) 3))
	(test-t (eql (length #(0 1 2 3)) 4))
	(test-t (eql (length #(0 1 2 3 4)) 5))
	(test-t (eql (length #(0 1 2 3 4 5)) 6))
	(test-t (eql (length #(0 1 2 3 4 5 6)) 7))
	(test-t (eql (length (make-array 100)) 100))
	(test-t (eql (length (make-sequence 'list 20)) 20))
	(test-t (eql (length (make-sequence 'string 10)) 10))
	(test-t (eql (length (make-sequence 'bit-vector 3)) 3))
	(test-t (eql (length (make-sequence 'bit-vector 64)) 64))
	(test-t (eql (length (make-sequence 'simple-vector 64)) 64))
	(test-t (string= (copy-seq "love") "love"))
	(test-t (equalp (copy-seq '#(a b c d)) '#(a b c d)))
	(test-t (equal (copy-seq '(love)) '(love)))
	(test-t (equal (copy-seq '(love hate war peace)) '(love hate war peace)))
	(test-t (null (copy-seq nil)))
	(test-t (string= (copy-seq "") ""))
	(test-t (let* ((seq0 "love&peace") (seq (copy-seq seq0))) (and (not (eq seq0 seq)) (string= seq0 seq))))
	(test-t (let* ((seq0 (list 'love 'and 'peace)) (seq (copy-seq seq0))) (and (not (eq seq0 seq)) (equal seq0 seq))))
	(test-t (let* ((c0 (list 'love))
		       (c1 (list 'peace))
		       (seq (copy-seq (list c0 c1))))
		  (and (equal seq '((love) (peace)))
		       (eq (car seq) c0)
		       (eq (cadr seq) c1))))
	(test-t (let* ((seq0 '#(t nil t nil))
		       (seq (copy-seq seq0)))
		  (and (not (eq seq0 seq))
		       (equalp seq seq0))))
	(test-t (vectorp (copy-seq (vector))))
	(test-t (simple-vector-p (copy-seq (vector))))
	(test-t (simple-vector-p (copy-seq (vector 0 1))))
	(test-t (simple-string-p (copy-seq "xyz")))
	(test-t (char= (elt "0123456789" 6) #\6))
	(test-t (eq (elt #(a b c d e f g) 0) 'a))
	(test-t (eq (elt '(a b c d e f g) 4) 'e))
	(test-t (let ((str (copy-seq "0123456789"))) (and (char= (elt str 6) #\6) (setf (elt str 0) #\#) (string= str "#123456789"))))
	(test-t (let ((list (list 0 1 2 3)))
		  (and (= (elt list 2) 2)
		       (setf (elt list 1) 9)
		       (= (elt list 1) 9)
		       (equal list '(0 9 2 3)))))
	(test-t (let ((vec (vector 'a 'b 'c)))
		  (and (eq (elt vec 0) 'a)
		       (eq (elt vec 1) 'b)
		       (eq (elt vec 2) 'c))))
	(test-t (let ((list (list 0 1 2 3))) (and (eq (cl-fill list nil) list) (every null list))))
	(test-t (let ((vector (vector 'x 'y 'z))) (and (eq (cl-fill vector 'a) vector) (every (lambda (arg) (eq arg 'a)) vector))))
	(test-t (let ((list (list 0 1 2 3))) (and (eq (cl-fill list '9 :start 2) list) (equal list '(0 1 9 9)))))
	(test-t (let ((list (list 0 1 2 3))) (and (eq (cl-fill list '9 :start 1 :end 3) list) (equal list '(0 9 9 3)))))
	(test-t (let ((list (list 0 1 2 3))) (and (eq (cl-fill list '9 :start 1 :end nil) list) (equal list '(0 9 9 9)))))
	(test-t (let ((list (list 0 1 2 3))) (and (eq (cl-fill list '9 :end 1) list) (equal list '(9 1 2 3)))))
	(test-t (let ((vector (vector 0 1 2 3))) (and (eq (cl-fill vector 't :start 3) vector) (equalp vector '#(0 1 2 t)))))
	(test-t (let ((vector (vector 0 1 2 3))) (and (eq (cl-fill vector 't :start 2 :end 4) vector) (equalp vector '#(0 1 t t)))))
	(test-t (let ((vector (vector 0 1 2 3))) (and (eq (cl-fill vector 't :start 2 :end nil) vector) (equalp vector '#(0 1 t t)))))
	(test-t (let ((vector (vector 0 1 2 3))) (and (eq (cl-fill vector 't :end 3) vector) (equalp vector '#(t t t 3)))))
	(test-t (null (make-sequence 'list 0)))
	(test-t (string= (make-sequence 'string 26 :initial-element #\.) ".........................."))
	(test-t (equal (make-sequence 'list 3 :initial-element 'a) '(a a a)))
	(test-t (null (make-sequence 'null 0 :initial-element 'a)))
	(test-t (equalp (make-sequence 'vector 3 :initial-element 'z) '#(z z z)))
	(test-t (string= (make-sequence 'string 4 :initial-element '#\z) "zzzz"))
	(test-t (vectorp (make-sequence 'vector 10)))
	(test-t (string= (subseq "012345" 2) "2345"))
	(test-t (string= (subseq "012345" 3 5) "34"))
	(test-t (equal (subseq '(0 1 2 3) 0) '(0 1 2 3)))
	(test-t (equal (subseq '(0 1 2 3) 1) '(1 2 3)))
	(test-t (equal (subseq '(0 1 2 3) 2) '(2 3)))
	(test-t (equal (subseq '(0 1 2 3) 3) '(3)))
	(test-t (equal (subseq '(0 1 2 3) 4) '()))
	(test-t (equalp (subseq #(a b c d) 0) #(a b c d)))
	(test-t (equalp (subseq #(a b c d) 1) #(b c d)))
	(test-t (equalp (subseq #(a b c d) 2) #(c d)))
	(test-t (equalp (subseq #(a b c d) 3) #(d)))
	(test-t (equalp (subseq #(a b c d) 4) #()))
	(test-t (string= (subseq "0123" 0) "0123"))
	(test-t (string= (subseq "0123" 1) "123"))
	(test-t (string= (subseq "0123" 2) "23"))
	(test-t (string= (subseq "0123" 3) "3"))
	(test-t (string= (subseq "0123" 4) ""))
	(test-t (equal (subseq '(0 1 2 3) 0 4) '(0 1 2 3)))
	(test-t (equal (subseq '(0 1 2 3) 0 nil) '(0 1 2 3)))
	(test-t (let* ((list0 '(0 1 2 3)) (list (subseq list0 0 4))) (and (not (eq list0 list)) (equal list0 list))))
	(test-t (let* ((list0 '(0 1 2 3)) (list (subseq list0 0 nil))) (and (not (eq list0 list)) (equal list0 list))))
	(test-t (equal (subseq '(0 1 2 3) 1 3) '(1 2)))
	(test-t (equal (subseq '(0 1 2 3) 2 2) '()))
	(test-t (equal (subseq '(0 1 2 3) 0 0) '()))
	(test-t (equal (subseq '(0 1 2 3) 1 1) '()))
	(test-t (equal (subseq '(0 1 2 3) 2 2) '()))
	(test-t (equal (subseq '(0 1 2 3) 3 3) '()))
	(test-t (equal (subseq '(0 1 2 3) 4 4) '()))
	(test-t (equalp (subseq #(0 1 2 3) 0 4) #(0 1 2 3)))
	(test-t (equalp (subseq #(0 1 2 3) 0 nil) #(0 1 2 3)))
	(test-t (let* ((vec0 #(0 1 2 3)) (vec (subseq vec0 0 4))) (and (not (eq vec0 vec)) (equalp vec0 vec))))
	(test-t (let* ((vec0 #(0 1 2 3)) (vec (subseq vec0 0 nil))) (and (not (eq vec0 vec)) (equalp vec0 vec))))
	(test-t (equalp (subseq #(0 1 2 3) 1 3) #(1 2)))
	(test-t (equalp (subseq #(0 1 2 3) 2 2) #()))
	(test-t (equalp (subseq #(0 1 2 3) 0 0) #()))
	(test-t (equalp (subseq #(0 1 2 3) 1 1) #()))
	(test-t (equalp (subseq #(0 1 2 3) 2 2) #()))
	(test-t (equalp (subseq #(0 1 2 3) 3 3) #()))
	(test-t (equalp (subseq #(0 1 2 3) 4 4) #()))
	(test-t (string= (cl-map 'string (lambda (x y) (char "01234567890ABCDEF" (mod (+ x y) 16))) '(1 2 3 4) '(10 9 8 7)) "AAAA"))
	(test-t (equal (cl-map 'list - '(1 2 3 4)) '(-1 -2 -3 -4)))
	(test-t (string= (cl-map 'string (lambda (x) (if (oddp x) #\1 #\0)) '(1 2 3 4)) "1010"))
	(test-t (equal (cl-map 'list + '(0 1) '(1 0)) '(1 1)))
	(test-t (equal (cl-map 'list - '(0 1) '(1 0)) '(-1 1)))
	(test-t (every null (list (cl-map 'list + '())
				  (cl-map 'list + '() '())
				  (cl-map 'list + '() '() '())
				  (cl-map 'list + '() '() '() '())
				  (cl-map 'list + '() '() '() '() '()))))
	(test-t (equal (cl-map 'list + '(0 1 2)) '(0 1 2)))
	(test-t (equal (cl-map 'list + '(0 1 2) '(1 2 3)) '(1 3 5)))
	(test-t (equal (cl-map 'list + '(0 1 2) '(1 2 3) '(2 3 4)) '(3 6 9)))
	(test-t (equal (cl-map 'list + '(0 1 2) '(1 2 3) '(2 3 4) '(3 4 5)) '(6 10 14)))
	(test-t (equal (cl-map 'list + '(1 2) '(1 2 3)) '(2 4)))
	(test-t (equal (cl-map 'list + '(0 1 2) '(2 3) '(2 3 4)) '(4 7)))
	(test-t (equal (cl-map 'list + '(0 1 2) '(1 2 3) '(2) '(3 4 5)) '(6)))
	(test-t (equal (cl-map 'list + '(0 1 2) '(1 2 3) '(2 3 4) '(3 4 5) '()) '()))
	(test-t (null (cl-map 'null + '())))
	(test-t (equalp (cl-map 'vector + #()) #()))
	(test-t (equalp (cl-map 'vector + #() #()) #()))
	(test-t (equalp (cl-map 'vector + #() #() #()) #()))
	(test-t (equalp (cl-map 'vector + #() #() #() #()) #()))
	(test-t (equalp (cl-map 'vector + #() #() #() #() #()) #()))
	(test-t (equalp (cl-map 'vector + '() #()) #()))
	(test-t (equalp (cl-map 'vector + '() #() "") #()))
	(test-t (equalp (cl-map 'vector + '(0 1 2)) #(0 1 2)))
	(test-t (equalp (cl-map 'vector + '(0 1 2) #(1 2 3)) #(1 3 5)))
	(test-t (equalp (cl-map 'vector + #(0 1 2) '(1 2 3) #(2 3 4)) #(3 6 9)))
	(test-t (equalp (cl-map 'vector + '(0 1 2) #(1 2 3) '(2 3 4) #(3 4 5)) #(6 10 14)))
	(test-t (equalp (cl-map 'vector + '(1 2) '(1 2 3)) #(2 4)))
	(test-t (equalp (cl-map 'vector + '(0 1 2) '(2 3) '(2 3 4)) #(4 7)))
	(test-t (equalp (cl-map 'vector + '(0 1 2) '(1 2 3) '(2) '(3 4 5)) #(6)))
	(test-t (equalp (cl-map 'vector + '(0 1 2) '(1 2 3) '(2 3 4) '(3 4 5) '()) #()))
	(test-t (equalp (cl-map 'vector + #(1 2) #(1 2 3)) #(2 4)))
	(test-t (equalp (cl-map 'vector + #(0 1 2) #(2 3) #(2 3 4)) #(4 7)))
	(test-t (equalp (cl-map 'vector + #(0 1 2) '(1 2 3) #(2) '(3 4 5)) #(6)))
	(test-t (equalp (cl-map 'vector + '(0 1 2) #(1 2 3) '(2 3 4) '(3 4 5) '()) #()))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) "") ""))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) "" "") ""))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) "" "" "") ""))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) "" "" "" "") ""))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) "" "" "" "" "") ""))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) "") ""))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) "" '()) ""))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) "" #() '()) ""))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) '() '() "" "") ""))
	(test-t (string= (cl-map 'string (lambda rest (char-upcase (car rest))) #() #() #() #() #()) ""))
	(test-t (string= (cl-map 'string (lambda (a b) (if (char< a b) b a)) "axbycz" "xaybzc") "xxyyzz"))
	(test-t (string= (cl-map 'string (lambda (a b) (if (char< a b) b a)) "axbycz" "xayb") "xxyy"))
	(test-t (let ((list ()))
		  (and (null (cl-map nil
				     (lambda rest
				       (setq list (cons (apply + rest) list)))
				     '(0 1 2 3)
				     '(1 2 3 4)))
		       (equal list '(7 5 3 1)))))
	(test-t (let ((list ()))
		  (and (null (cl-map nil
				     (lambda rest
				       (setq list (cons (apply + rest) list)))
				     '(0 1 2 3)
				     '(1 2 3 4)
				     '(2 3 4 5)))
		       (equal list (cl-reverse '(3 6 9 12))))))
	(test-t (let ((list ()))
		  (and (null (cl-map nil
				     (lambda rest
				       (setq list (cons (apply + rest) list)))
				     '(0 1 2 3)
				     '(1)
				     '(2 3 4 5)))
		       (equal list '(3)))))
	(test-t (string= (cl-map 'string char-upcase "abc") "ABC"))
	(test-t (let ((a (list 1 2 3 4))
		      (b (list 10 10 10 10)))
		  (and (equal (map-into a + a b) '(11 12 13 14))
		       (equal a '(11 12 13 14))
		       (equal b '(10 10 10 10)))))
	(test-t (let ((a '(11 12 13 14)) (k '(one two three))) (equal (map-into a cons k a) '((one . 11) (two . 12) (three . 13) 14))))
	(test-t (null (map-into nil identity)))
	(test-t (null (map-into nil identity)))
	(test-t (null (map-into nil identity '())))
	(test-t (null (map-into nil identity '(0 1 2) '(9 8 7))))
	(test-t (let ((list (list 0 1 2))) (and (eq (map-into list identity) list) (equal list '(0 1 2)))))
	(test-t (let ((list (list 0 1 2))) (and (eq (map-into list identity '()) list) (equal list '(0 1 2)))))
	(test-t (let ((vec (vector 0 1 2))) (and (eq (map-into vec identity) vec) (equalp vec #(0 1 2)))))
	(test-t (let ((vec (vector 0 1 2))) (and (eq (map-into vec identity #()) vec) (equalp vec #(0 1 2)))))
	(test-t (let ((vec (vector 0 1 2))) (and (eq (map-into vec + #() '() #()) vec) (equalp vec #(0 1 2)))))
	(test-t (equal (map-into (list nil nil) + '(0 1) '(1 0)) '(1 1)))
	(test-t (equal (map-into (list nil nil) - '(0 1) '(1 0)) '(-1 1)))
	(test-t (let ((list (cl-make-list 3 :initial-element nil))) (and (eq (map-into list + '(0 1 2)) list) (equal list '(0 1 2)))))
	(test-t (let ((list (cl-make-list 3 :initial-element nil))) (and (eq (map-into list + '(0 1 2) '(1 2 3)) list) (equal list '(1 3 5)))))
	(test-t (let ((list (cl-make-list 3 :initial-element nil))) (and (eq (map-into list + '(0 1 2) '(1 2 3) '(2 3 4)) list) (equal list '(3 6 9)))))
	(test-t (let ((list (cl-make-list 3 :initial-element nil))) (and (eq (map-into list + '(1 2) '(1 2 3)) list) (equal list '(2 4 ())))))
	(test-t (let ((list (cl-make-list 1 :initial-element nil))) (and (eq (map-into list + '(1 2 3) '(1 2 3)) list) (equal list '(2)))))
	(test-t (let ((list (cl-make-list 3 :initial-element nil))) (and (eq (map-into list + '(1 2 3 4) '(1 2 3) '(0)) list) (equal list '(2 () ())))))
	(test-t (let ((vec (make-sequence 'vector 3 :initial-element nil))) (and (eq (map-into vec + '(0 1 2)) vec) (equalp vec #(0 1 2)))))
	(test-t (let ((vec (make-sequence 'vector 3 :initial-element nil))) (and (eq (map-into vec + '(0 1 2) #(1 2 3)) vec) (equalp vec #(1 3 5)))))
	(test-t (let ((vec (make-sequence 'vector 3 :initial-element nil))) (and (eq (map-into vec + '(0 1 2) '(1 2 3) #(2 3 4)) vec) (equalp vec #(3 6 9)))))
	(test-t (let ((vec (make-sequence 'vector 3 :initial-element nil))) (and (eq (map-into vec + '(1 2) #(1 2 3)) vec) (equalp vec #(2 4 ())))))
	(test-t (let ((vec (make-sequence 'vector 1 :initial-element nil))) (and (eq (map-into vec + '(1 2) #(1 2 3)) vec) (equalp vec #(2)))))
	(test-t (let ((vec (make-sequence 'vector 3 :initial-element nil))) (and (eq (map-into vec + '(1 2 3 4) #(1 2 3) '(0)) vec) (equalp vec #(2 () ())))))
	(test-t (eql (reduce * '(1 2 3 4 5)) 120))
	(test-t (equal (reduce append '((1) (2)) :initial-value '(i n i t)) '(i n i t 1 2)))
	(test-t (equal (reduce append '((1) (2)) :from-end t :initial-value '(i n i t)) '(1 2 i n i t)))
	(test-t (eql (reduce - '(1 2 3 4)) -8))
	(test-t (eql (reduce - '(1 2 3 4) :from-end t) -2))
	(test-t (eql (reduce + '()) 0))
	(test-t (eql (reduce + '(3)) 3))
	(test-t (eq (reduce + '(foo)) 'foo))
	(test-t (equal (reduce list '(1 2 3 4)) '(((1 2) 3) 4)))
	(test-t (equal (reduce list '(1 2 3 4) :from-end t) '(1 (2 (3 4)))))
	(test-t (equal (reduce list '(1 2 3 4) :initial-value 'foo) '((((foo 1) 2) 3) 4)))
	(test-t (equal (reduce list '(1 2 3 4) :from-end t :initial-value 'foo) '(1 (2 (3 (4 foo))))))
	(test-t (equal (reduce list '(0 1 2 3)) '(((0 1) 2) 3)))
	(test-t (equal (reduce list '(0 1 2 3) :start 1) '((1 2) 3)))
	(test-t (equal (reduce list '(0 1 2 3) :start 1 :end nil) '((1 2) 3)))
	(test-t (equal (reduce list '(0 1 2 3) :start 2) '(2 3)))
	(test-t (eq (reduce list '(0 1 2 3) :start 0 :end 0) '()))
	(test-t (eq (reduce list '(0 1 2 3) :start 0 :end 0 :initial-value 'initial-value) 'initial-value))
	(test-t (eq (reduce list '(0 1 2 3) :start 2 :end 2) '()))
	(test-t (eq (reduce list '(0 1 2 3) :start 2 :end 2 :initial-value 'initial-value) 'initial-value))
	(test-t (eq (reduce list '(0 1 2 3) :start 4 :end 4) '()))
	(test-t (eq (reduce list '(0 1 2 3) :start 4 :end 4 :initial-value 'initial-value) 'initial-value))
	(test-t (eql (reduce list '(0 1 2 3) :start 2 :end 3) 2))
	(test-t (equal (reduce list '(0 1 2 3) :start 2 :end 3 :initial-value 'initial-value) '(initial-value 2)))
	(test-t (eql (reduce + '(0 1 2 3 4 5 6 7 8 9)) 45))
	(test-t (eql (reduce - '(0 1 2 3 4 5 6 7 8 9)) -45))
	(test-t (eql (reduce - '(0 1 2 3 4 5 6 7 8 9) :from-end t) -5))
	(test-t (equal (reduce list '(0 1 2 3) :initial-value 'initial-value) '((((initial-value 0) 1) 2) 3)))
	(test-t (equal (reduce list '(0 1 2 3) :from-end t) '(0 (1 (2 3)))))
	(test-t (equal (reduce list '((1) (2) (3) (4)) :key car) '(((1 2) 3) 4)))
					;(test-t (equal (reduce list '((1) (2) (3) (4)) :key car :from-end nil) '(((1 2) 3) 4)))
	(test-t (equal (reduce list '((1) (2) (3) (4)) :key car :initial-value 0) '((((0 1) 2) 3) 4)))
	(test-t (equal (reduce list '((1) (2) (3) (4)) :key car :from-end t) '(1 (2 (3 4)))))
	(test-t (equal (reduce list '((1) (2) (3) (4)) :key car :from-end t :initial-value 5) '(1 (2 (3 (4 5))))))
	(test-t (equal (reduce list #(0 1 2 3)) '(((0 1) 2) 3)))
	(test-t (equal (reduce list #(0 1 2 3) :start 1) '((1 2) 3)))
	(test-t (equal (reduce list #(0 1 2 3) :start 1 :end nil) '((1 2) 3)))
	(test-t (equal (reduce list #(0 1 2 3) :start 2) '(2 3)))
	(test-t (eq (reduce list #(0 1 2 3) :start 0 :end 0) '()))
	(test-t (eq (reduce list #(0 1 2 3) :start 0 :end 0 :initial-value 'initial-value) 'initial-value))
	(test-t (eq (reduce list #(0 1 2 3) :start 2 :end 2) '()))
	(test-t (eq (reduce list #(0 1 2 3) :start 2 :end 2 :initial-value 'initial-value) 'initial-value))
	(test-t (eq (reduce list #(0 1 2 3) :start 4 :end 4) '()))
	(test-t (eq (reduce list #(0 1 2 3) :start 4 :end 4 :initial-value 'initial-value) 'initial-value))
	(test-t (eql (reduce list #(0 1 2 3) :start 2 :end 3) 2))
	(test-t (equal (reduce list #(0 1 2 3) :start 2 :end 3 :initial-value 'initial-value) '(initial-value 2)))
	(test-t (eql (reduce + #(0 1 2 3 4 5 6 7 8 9)) 45))
	(test-t (eql (reduce - #(0 1 2 3 4 5 6 7 8 9)) -45))
	(test-t (eql (reduce - #(0 1 2 3 4 5 6 7 8 9) :from-end t) -5))
	(test-t (equal (reduce list #(0 1 2 3) :initial-value 'initial-value) '((((initial-value 0) 1) 2) 3)))
	(test-t (equal (reduce list #(0 1 2 3) :from-end t) '(0 (1 (2 3)))))
	(test-t (equal (reduce list #((1) (2) (3) (4)) :key car) '(((1 2) 3) 4)))
					;(test-t (equal (reduce list #((1) (2) (3) (4)) :key car :from-end nil) '(((1 2) 3) 4)))
	(test-t (equal (reduce list #((1) (2) (3) (4)) :key car :initial-value 0) '((((0 1) 2) 3) 4)))
	(test-t (equal (reduce list #((1) (2) (3) (4)) :key car :from-end t) '(1 (2 (3 4)))))
	(test-t (equal (reduce list #((1) (2) (3) (4)) :key car :from-end t :initial-value 5) '(1 (2 (3 (4 5))))))
	(test-t (eql (count #\a "how many A's are there in here?") 2))
	(test-t (eql (count-if-not oddp '((1) (2) (3) (4)) :key car) 2))
	(test-t (eql (count-if upper-case-p "The Crying of Lot 49" :start 4) 2))
	(test-t (eql (count #\a (concatenate 'list "how many A's are there in here?")) 2))
	(test-t (eql (count-if alpha-char-p "-a-b-c-0-1-2-3-4-") 3))
	(test-t (eql (count-if alphanumericp "-a-b-c-0-1-2-3-4-") 8))
	(test-t (eql (count nil (list t nil t nil t nil)) 3))
	(test-t (eql (count nil (vector t nil t nil t nil)) 3))
	(test-t (zerop (count 9 '(0 1 2 3 4))))
	(test-t (zerop (count 'a '(0 1 2 3 4))))
	(test-t (eql (count 0 '(0 0 0 0 0) :start 1) 4))
	(test-t (eql (count 0 '(0 0 0 0 0) :start 1 :end nil) 4))
	(test-t (eql (count 0 '(0 0 0 0 0) :start 2) 3))
	(test-t (zerop (count 0 '(0 0 0 0) :start 0 :end 0)))
	(test-t (zerop (count 0 '(0 0 0 0) :start 2 :end 2)))
	(test-t (zerop (count 0 '(0 0 0 0) :start 4 :end 4)))
	(test-t (eql (count 0 '(0 0 0 0) :start 2 :end 3) 1))
	(test-t (eql (count #\a "abcABC" :test equalp) 2))
	(test-t (eql (count #\a "abcABC" :test char-equal) 2))
	(test-t (eql (count '(a) '((x) (y) (z) (a) (b) (c)) :test equalp) 1))
	(test-t (eql (count 'a '((x) (y) (z) (a) (b) (c)) :key car :test eq) 1))
	(test-t (eql (count nil '((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr :test eq) 3))
	(test-t (let ((list nil))
		  (and (eql (count 'a '(a b c d)
				   :test (lambda (a b) (setq list (cons b list)) (eq a b)))
			    1)
		       (equal list '(d c b a)))))
	(test-t (let ((list nil))
		  (and (eql (count 'a '(a b c d)
				   :test (lambda (a b) (setq list (cons b list)) (eq a b))
				   :from-end t)
			    1)
		       (equal list '(a b c d)))))
	(test-t (zerop (count 9 #(0 1 2 3 4))))
	(test-t (zerop (count 'a #(0 1 2 3 4))))
	(test-t (eql (count 0 #(0 0 0 0 0) :start 1) 4))
	(test-t (eql (count 0 #(0 0 0 0 0) :start 1 :end nil) 4))
	(test-t (eql (count 0 #(0 0 0 0 0) :start 2) 3))
	(test-t (zerop (count 0 #(0 0 0 0) :start 0 :end 0)))
	(test-t (zerop (count 0 #(0 0 0 0) :start 2 :end 2)))
	(test-t (zerop (count 0 #(0 0 0 0) :start 4 :end 4)))
	(test-t (eql (count 0 #(0 0 0 0) :start 2 :end 3) 1))
	(test-t (eql (count '(a) #((x) (y) (z) (a) (b) (c)) :test equalp) 1))
	(test-t (eql (count 'a #((x) (y) (z) (a) (b) (c)) :key car :test eq) 1))
	(test-t (eql (count nil #((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr :test eq) 3))
	(test-t (let ((list nil))
		  (and (eql (count 'a #(a b c d)
				   :test (lambda (a b) (setq list (cons b list)) (eq a b)))
			    1)
		       (equal list '(d c b a)))))
	(test-t (let ((list nil))
		  (and (eql (count 'a #(a b c d)
				   :test (lambda (a b) (setq list (cons b list)) (eq a b))
				   :from-end t)
			    1)
		       (equal list '(a b c d)))))
	(test-t (eql (count-if null (list t nil t nil t nil)) 3))
	(test-t (zerop (count-if (lambda (x) (eql x 9)) #(0 1 2 3 4))))
	(test-t (zerop (count-if (lambda (a) (eq 'x a)) #(0 1 2 3 4))))
	(test-t (eql (count-if zerop '(0 0 0 0 0) :start 1) 4))
	(test-t (eql (count-if zerop '(0 0 0 0 0) :start 1 :end nil) 4))
	(test-t (eql (count-if zerop '(0 0 0 0 0) :start 2) 3))
	(test-t (zerop (count-if zerop '(0 0 0 0) :start 0 :end 0)))
	(test-t (zerop (count-if zerop '(0 0 0 0) :start 2 :end 2)))
	(test-t (zerop (count-if zerop '(0 0 0 0) :start 4 :end 4)))
	(test-t (eql (count-if zerop '(0 0 0 0) :start 2 :end 3) 1))
	(test-t (eql (count-if (lambda (x) (equalp #\a x)) "abcABC") 2))
	(test-t (eql (count-if (lambda (x) (char-equal #\a x)) "abcABC") 2))
	(test-t (eql (count-if (lambda (x) (equal x '(a))) '((x) (y) (z) (a) (b) (c))) 1))
	(test-t (eql (count-if (lambda (x) (eq x 'a)) '((x) (y) (z) (a) (b) (c)) :key car) 1))
	(test-t (eql (count-if null '((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr) 3))
	(test-t (eql (count-if (lambda (x) (equal x '(a))) '((x) (y) (z) (a) (b) (c))) 1))
	(test-t (eql (count-if (lambda (x) (eq x 'a)) '((x) (y) (z) (a) (b) (c)) :key car) 1))
	(test-t (eql (count-if null '((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr) 3))
	(test-t (let ((list nil))
		  (and (eql (count-if (lambda (x) (setq list (cons x list)) (eq x 'a))
				      '(a b c d))
			    1)
		       (equal list '(d c b a)))))
	(test-t (let ((list nil))
		  (and (eql (count-if (lambda (x) (setq list (cons x list)) (eq x 'a))
				      '(a b c d)
				      :from-end t)
			    1)
		       (equal list '(a b c d)))))
	(test-t (eql (count-if null (vector t nil t nil t nil)) 3))
	(test-t (eql (count-if zerop #(0 0 0 0 0) :start 1) 4))
	(test-t (eql (count-if zerop #(0 0 0 0 0) :start 1 :end nil) 4))
	(test-t (eql (count-if zerop #(0 0 0 0 0) :start 2) 3))
	(test-t (zerop (count-if zerop #(0 0 0 0) :start 0 :end 0)))
	(test-t (zerop (count-if zerop #(0 0 0 0) :start 2 :end 2)))
	(test-t (zerop (count-if zerop #(0 0 0 0) :start 4 :end 4)))
	(test-t (eql (count-if zerop #(0 0 0 0) :start 2 :end 3) 1))
	(test-t (eql (count-if (lambda (x) (equal x '(a))) #((x) (y) (z) (a) (b) (c))) 1))
	(test-t (eql (count-if (lambda (x) (eq x 'a)) #((x) (y) (z) (a) (b) (c)) :key car) 1))
	(test-t (eql (count-if null #((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr) 3))
	(test-t (eql (count-if (lambda (x) (equal x '(a))) #((x) (y) (z) (a) (b) (c))) 1))
	(test-t (eql (count-if (lambda (x) (eq x 'a)) #((x) (y) (z) (a) (b) (c)) :key car) 1))
	(test-t (eql (count-if null #((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr) 3))
	(test-t (let ((list nil))
		  (and (eql (count-if (lambda (x) (setq list (cons x list)) (eq x 'a))
				      #(a b c d))
			    1)
		       (equal list '(d c b a)))))
	(test-t (let ((list nil))
		  (and (eql (count-if (lambda (x) (setq list (cons x list)) (eq x 'a))
				      #(a b c d)
				      :from-end t)
			    1)
		       (equal list '(a b c d)))))
	(test-t (eql (count-if-not (complement null) (list t nil t nil t nil)) 3))
	(test-t (zerop (count-if-not (lambda (x) (not (eql x 9))) #(0 1 2 3 4))))
	(test-t (zerop (count-if-not (lambda (a) (not (eq 'x a))) #(0 1 2 3 4))))
	(test-t (eql (count-if-not (complement zerop) '(0 0 0 0 0) :start 1) 4))
	(test-t (eql (count-if-not (complement zerop) '(0 0 0 0 0) :start 1 :end nil) 4))
	(test-t (eql (count-if-not (complement zerop) '(0 0 0 0 0) :start 2) 3))
	(test-t (zerop (count-if-not (complement zerop) '(0 0 0 0) :start 0 :end 0)))
	(test-t (zerop (count-if-not (complement zerop) '(0 0 0 0) :start 2 :end 2)))
	(test-t (zerop (count-if-not (complement zerop) '(0 0 0 0) :start 4 :end 4)))
	(test-t (eql (count-if-not (complement zerop) '(0 0 0 0) :start 2 :end 3) 1))
	(test-t (eql (count-if-not (lambda (x) (not (equalp #\a x))) "abcABC") 2))
	(test-t (eql (count-if-not (lambda (x) (not (char-equal #\a x))) "abcABC") 2))
	(test-t (eql (count-if-not (lambda (x) (not (equal x '(a)))) '((x) (y) (z) (a) (b) (c))) 1))
	(test-t (eql (count-if-not (lambda (x) (not (eq x 'a))) '((x) (y) (z) (a) (b) (c)) :key car) 1))
	(test-t (eql (count-if-not (complement null) '((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr) 3))
	(test-t (eql (count-if-not (lambda (x) (not (equal x '(a)))) '((x) (y) (z) (a) (b) (c))) 1))
	(test-t (eql (count-if-not (lambda (x) (not (eq x 'a))) '((x) (y) (z) (a) (b) (c)) :key car) 1))
	(test-t (eql (count-if-not (complement null) '((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr) 3))
	(test-t (let ((list nil))
		  (and (eql (count-if-not (lambda (x)
					    (setq list (cons x list))
					    (not (eq x 'a)))
					  '(a b c d))
			    1)
		       (equal list '(d c b a)))))
	(test-t (let ((list nil))
		  (and (eql (count-if-not (lambda (x)
					    (setq list (cons x list))
					    (not (eq x 'a)))
					  '(a b c d)
					  :from-end t)
			    1)
		       (equal list '(a b c d)))))
	(test-t (eql (count-if-not (complement null) (vector t nil t nil t nil)) 3))
	(test-t (eql (count-if-not (complement zerop) #(0 0 0 0 0) :start 1) 4))
	(test-t (eql (count-if-not (complement zerop) #(0 0 0 0 0) :start 1 :end nil) 4))
	(test-t (eql (count-if-not (complement zerop) #(0 0 0 0 0) :start 2) 3))
	(test-t (zerop (count-if-not (complement zerop) #(0 0 0 0) :start 0 :end 0)))
	(test-t (zerop (count-if-not (complement zerop) #(0 0 0 0) :start 2 :end 2)))
	(test-t (zerop (count-if-not (complement zerop) #(0 0 0 0) :start 4 :end 4)))
	(test-t (eql (count-if-not (complement zerop) #(0 0 0 0) :start 2 :end 3) 1))
	(test-t (eql (count-if-not (lambda (x) (not (equal x '(a)))) #((x) (y) (z) (a) (b) (c))) 1))
	(test-t (eql (count-if-not (lambda (x) (not (eq x 'a))) #((x) (y) (z) (a) (b) (c)) :key car) 1))
	(test-t (eql (count-if-not (complement null) #((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr) 3))
	(test-t (eql (count-if-not (lambda (x) (not (equal x '(a)))) #((x) (y) (z) (a) (b) (c))) 1))
	(test-t (eql (count-if-not (lambda (x) (not (eq x 'a))) #((x) (y) (z) (a) (b) (c)) :key car) 1))
	(test-t (eql (count-if-not (complement null) #((x . x) (y) (z . z) (a) (b . b) (c)) :key cdr) 3))
	(test-t (let ((list nil))
		  (and (eql (count-if-not (lambda (x)
					    (setq list (cons x list))
					    (not (eq x 'a)))
					  #(a b c d))
			    1)
		       (equal list '(d c b a)))))
	(test-t (let ((list nil))
		  (and (eql (count-if-not (lambda (x)
					    (setq list (cons x list))
					    (not (eq x 'a)))
					  #(a b c d)
					  :from-end t)
			    1)
		       (equal list '(a b c d)))))
	(test-t (null (cl-reverse nil)))
	(test-t (string= (cl-reverse "") ""))
	(test-t (equalp (cl-reverse #()) #()))
	(test-t (equal (cl-reverse '(0 1 2 3)) '(3 2 1 0)))
	(test-t (string= (cl-reverse "0123") "3210"))
	(test-t (equalp (cl-reverse #(a b c d)) #(d c b a)))
	(test-t (null (nreverse nil)))
	(test-t (string= (nreverse (copy-seq "")) ""))
	(test-t (equalp (nreverse (copy-seq #())) #()))
	(test-t (equal (nreverse (list 0 1 2 3)) '(3 2 1 0)))
	(test-t (string= (nreverse (copy-seq "0123")) "3210"))
	(test-t (equalp (cl-reverse (copy-seq #(a b c d))) #(d c b a)))
	(test-t (char= (find #\d "edcba" :test char>) #\c))
	(test-t (eql (find-if oddp '(1 2 3 4 5) :end 3 :from-end t) 3))
	(test-t (eq (find 'a '(a b c)) 'a))
	(test-t (eq (find 'b '(a b c)) 'b))
	(test-t (eq (find 'c '(a b c)) 'c))
	(test-t (null (find 'x '(a b c))))
	(test-t (null (find 'a '(a b c) :start 1)))
	(test-t (null (find 'b '(a b c) :start 2)))
	(test-t (null (find 'c '(a b c) :start 3)))
	(test-t (null (find 'a '(a b c) :start 0 :end 0)))
	(test-t (null (find 'a '(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (find 'a '(a b c) :start 1 :end 1)))
	(test-t (null (find 'a '(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (find 'a '(a b c) :start 2 :end 2)))
	(test-t (null (find 'a '(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (find 'a '(a b c) :start 3 :end 3)))
	(test-t (null (find 'a '(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eq (find 'a '(a b c) :end nil) 'a))
	(test-t (eq (find 'b '(a b c) :end nil) 'b))
	(test-t (eq (find 'c '(a b c) :end nil) 'c))
	(test-t (eq (find 'a '(a b c) :end 1) 'a))
	(test-t (eq (find 'b '(a b c) :end 2) 'b))
	(test-t (eq (find 'c '(a b c) :end 3) 'c))
	(test-t (null (find 'a '(a b c) :end 0)))
	(test-t (null (find 'b '(a b c) :end 1)))
	(test-t (null (find 'c '(a b c) :end 2)))
	(test-t (null (find 'a '((a) (b) (c)))))
	(test-t (equal (find 'a '((a) (b) (c)) :key car) '(a)))
	(test-t (equal (find 'b '((a) (b) (c)) :key car) '(b)))
	(test-t (equal (find 'c '((a) (b) (c)) :key car) '(c)))
	(test-t (null (find 'z '((a) (b) (c)) :key car)))
	(test-t (let ((list '((a) (b) (c))))
		  (and (eq (find 'a list :key car) (car list))
		       (eq (find 'b list :key car) (cadr list))
		       (eq (find 'c list :key car) (caddr list))
		       (null (find 'z list :key car)))))
	(test-t (null (find '(a) '((a) (b) (c)))))
	(test-t (equal (find '(a) '((a) (b) (c)) :test equal) '(a)))
	(test-t (null (find '("a") '(("a") ("b") ("c")))))
	(test-t (null (find '("a") '(("A") ("B") ("c")) :test equal)))
	(test-t (eql (find 3 '(0 1 2 3 4 5)) 3))
	(test-t (eql (find 3 '(0 1 2 3 4 5) :test <) 4))
	(test-t (eql (find 3 '(0 1 2 3 4 5) :test >) 0))
	(test-t (equal (find 'a '((a) (b) (c) (a a) (b b) (c c)) :key car) '(a)))
	(test-t (equal (find 'a '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(a a)))
	(test-t (equal (find 'b '((a) (b) (c) (a a) (b b) (c c)) :key car) '(b)))
	(test-t (equal (find 'b '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(b b)))
	(test-t (equal (find 'c '((a) (b) (c) (a a) (b b) (c c)) :key car) '(c)))
	(test-t (equal (find 'c '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(c c)))
	(test-t (null (find 'z '((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (find 'z '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (equal (find 'a '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) '(a a a)))
	(test-t (equal (find 'a '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) '(a a a)))
	(test-t (equal (find 'a '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) '(a a)))
	(test-t (null (find 'a '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (null (find #\c '("abc" "bcd" "cde"))))
	(test-t (string= (find #\c '("abc" "bcd" "cde") :key (lambda (arg) (char arg 0)) :test char=) "cde"))
	(test-t (eq (find 'a #(a b c)) 'a))
	(test-t (eq (find 'b #(a b c)) 'b))
	(test-t (eq (find 'c #(a b c)) 'c))
	(test-t (null (find 'x #(a b c))))
	(test-t (null (find 'a #(a b c) :start 1)))
	(test-t (null (find 'b #(a b c) :start 2)))
	(test-t (null (find 'c #(a b c) :start 3)))
	(test-t (null (find 'a #(a b c) :start 0 :end 0)))
	(test-t (null (find 'a #(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (find 'a #(a b c) :start 1 :end 1)))
	(test-t (null (find 'a #(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (find 'a #(a b c) :start 2 :end 2)))
	(test-t (null (find 'a #(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (find 'a #(a b c) :start 3 :end 3)))
	(test-t (null (find 'a #(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eq (find 'a #(a b c) :end nil) 'a))
	(test-t (eq (find 'b #(a b c) :end nil) 'b))
	(test-t (eq (find 'c #(a b c) :end nil) 'c))
	(test-t (eq (find 'a #(a b c) :end 1) 'a))
	(test-t (eq (find 'b #(a b c) :end 2) 'b))
	(test-t (eq (find 'c #(a b c) :end 3) 'c))
	(test-t (null (find 'a #(a b c) :end 0)))
	(test-t (null (find 'b #(a b c) :end 1)))
	(test-t (null (find 'c #(a b c) :end 2)))
	(test-t (null (find 'a #((a) (b) (c)))))
	(test-t (equal (find 'a #((a) (b) (c)) :key car) '(a)))
	(test-t (equal (find 'b #((a) (b) (c)) :key car) '(b)))
	(test-t (equal (find 'c #((a) (b) (c)) :key car) '(c)))
	(test-t (null (find 'z #((a) (b) (c)) :key car)))
	(test-t (let ((vector #((a) (b) (c))))
		  (and (eq (find 'a vector :key car) (aref vector 0))
		       (eq (find 'b vector :key car) (aref vector 1))
		       (eq (find 'c vector :key car) (aref vector 2))
		       (null (find 'z vector :key car)))))
	(test-t (null (find '(a) #((a) (b) (c)))))
	(test-t (equal (find '(a) #((a) (b) (c)) :test equal) '(a)))
	(test-t (null (find '("a") #(("a") ("b") ("c")))))
	(test-t (null (find '("a") #(("A") ("B") ("c")) :test equal)))
	(test-t (eql (find 3 #(0 1 2 3 4 5)) 3))
	(test-t (eql (find 3 #(0 1 2 3 4 5) :test <) 4))
	(test-t (eql (find 3 #(0 1 2 3 4 5) :test >) 0))
	(test-t (equal (find 'a #((a) (b) (c) (a a) (b b) (c c)) :key car) '(a)))
	(test-t (equal (find 'a #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(a a)))
	(test-t (equal (find 'b #((a) (b) (c) (a a) (b b) (c c)) :key car) '(b)))
	(test-t (equal (find 'b #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(b b)))
	(test-t (equal (find 'c #((a) (b) (c) (a a) (b b) (c c)) :key car) '(c)))
	(test-t (equal (find 'c #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(c c)))
	(test-t (null (find 'z #((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (find 'z #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (equal (find 'a #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) '(a a a)))
	(test-t (equal (find 'a #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) '(a a a)))
	(test-t (equal (find 'a #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) '(a a)))
	(test-t (null (find 'a #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (null (find #\c #("abc" "bcd" "cde"))))
	(test-t (null (find #\z "abcABC")))
	(test-t (eql (find #\a "abcABC") #\a))
	(test-t (eql (find #\A "abcABC") #\A))
	(test-t (eql (find #\A "abcABC" :test char-equal) #\a))
	(test-t (eql (find #\A "abcABC" :test char-equal :from-end t) #\A))
	(test-t (eql (find #\a "abcABC" :test char-equal :from-end t) #\A))
	(test-t (eql (find #\a "abcABC" :test char-equal :from-end t :end 4) #\A))
	(test-t (eql (find #\a "abcABC" :test char-equal :from-end t :end 3) #\a))
	(test-t (eq (find-if (lambda (x) (eq x 'a)) '(a b c)) 'a))
	(test-t (eq (find-if (lambda (x) (eq x 'b)) '(a b c)) 'b))
	(test-t (eq (find-if (lambda (x) (eq x 'c)) '(a b c)) 'c))
	(test-t (null (find-if (lambda (arg) (eq arg 'x)) '(a b c))))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :start 1)))
	(test-t (null (find-if (lambda (x) (eq x 'b)) '(a b c) :start 2)))
	(test-t (null (find-if (lambda (x) (eq x 'c)) '(a b c) :start 3)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :start 0 :end 0)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :start 1 :end 1)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :start 2 :end 2)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :start 3 :end 3)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eq (find-if (lambda (x) (eq x 'a)) '(a b c) :end nil) 'a))
	(test-t (eq (find-if (lambda (x) (eq x 'b)) '(a b c) :end nil) 'b))
	(test-t (eq (find-if (lambda (x) (eq x 'c)) '(a b c) :end nil) 'c))
	(test-t (eq (find-if (lambda (x) (eq x 'a)) '(a b c) :end 1) 'a))
	(test-t (eq (find-if (lambda (x) (eq x 'b)) '(a b c) :end 2) 'b))
	(test-t (eq (find-if (lambda (x) (eq x 'c)) '(a b c) :end 3) 'c))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '(a b c) :end 0)))
	(test-t (null (find-if (lambda (x) (eq x 'b)) '(a b c) :end 1)))
	(test-t (null (find-if (lambda (x) (eq x 'c)) '(a b c) :end 2)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '((a) (b) (c)))))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) '((a) (b) (c)) :key car) '(a)))
	(test-t (equal (find-if (lambda (x) (eq x 'b)) '((a) (b) (c)) :key car) '(b)))
	(test-t (equal (find-if (lambda (x) (eq x 'c)) '((a) (b) (c)) :key car) '(c)))
	(test-t (null (find-if (lambda (x) (eq x 'z)) '((a) (b) (c)) :key car)))
	(test-t (let ((list '((a) (b) (c))))
		  (and (eq (find-if (lambda (x) (eq x 'a)) list :key car) (car list))
		       (eq (find-if (lambda (x) (eq x 'b)) list :key car) (cadr list))
		       (eq (find-if (lambda (x) (eq x 'c)) list :key car) (caddr list))
		       (null (find-if (lambda (x) (eq x 'z)) list :key car)))))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c)) :key car) '(a)))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(a a)))
	(test-t (equal (find-if (lambda (x) (eq x 'b)) '((a) (b) (c) (a a) (b b) (c c)) :key car) '(b)))
	(test-t (equal (find-if (lambda (x) (eq x 'b)) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(b b)))
	(test-t (equal (find-if (lambda (x) (eq x 'c)) '((a) (b) (c) (a a) (b b) (c c)) :key car) '(c)))
	(test-t (equal (find-if (lambda (x) (eq x 'c)) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(c c)))
	(test-t (null (find-if (lambda (x) (eq x 'z)) '((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (find-if (lambda (x) (eq x 'z)) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) '(a a a)))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) '(a a a)))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) '(a a)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (eq (find-if (lambda (x) (eq x 'a)) #(a b c)) 'a))
	(test-t (eq (find-if (lambda (x) (eq x 'b)) #(a b c)) 'b))
	(test-t (eq (find-if (lambda (x) (eq x 'c)) #(a b c)) 'c))
	(test-t (null (find-if (lambda (arg) (eq arg 'x)) #(a b c))))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :start 1)))
	(test-t (null (find-if (lambda (x) (eq x 'b)) #(a b c) :start 2)))
	(test-t (null (find-if (lambda (x) (eq x 'c)) #(a b c) :start 3)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :start 0 :end 0)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :start 1 :end 1)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :start 2 :end 2)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :start 3 :end 3)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eq (find-if (lambda (x) (eq x 'a)) #(a b c) :end nil) 'a))
	(test-t (eq (find-if (lambda (x) (eq x 'b)) #(a b c) :end nil) 'b))
	(test-t (eq (find-if (lambda (x) (eq x 'c)) #(a b c) :end nil) 'c))
	(test-t (eq (find-if (lambda (x) (eq x 'a)) #(a b c) :end 1) 'a))
	(test-t (eq (find-if (lambda (x) (eq x 'b)) #(a b c) :end 2) 'b))
	(test-t (eq (find-if (lambda (x) (eq x 'c)) #(a b c) :end 3) 'c))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #(a b c) :end 0)))
	(test-t (null (find-if (lambda (x) (eq x 'b)) #(a b c) :end 1)))
	(test-t (null (find-if (lambda (x) (eq x 'c)) #(a b c) :end 2)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #((a) (b) (c)))))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) #((a) (b) (c)) :key car) '(a)))
	(test-t (equal (find-if (lambda (x) (eq x 'b)) #((a) (b) (c)) :key car) '(b)))
	(test-t (equal (find-if (lambda (x) (eq x 'c)) #((a) (b) (c)) :key car) '(c)))
	(test-t (null (find-if (lambda (x) (eq x 'z)) #((a) (b) (c)) :key car)))
	(test-t (let ((vector #((a) (b) (c))))
		  (and (eq (find-if (lambda (x) (eq x 'a)) vector :key car) (aref vector 0))
		       (eq (find-if (lambda (x) (eq x 'b)) vector :key car) (aref vector 1))
		       (eq (find-if (lambda (x) (eq x 'c)) vector :key car) (aref vector 2))
		       (null (find-if (lambda (x) (eq x 'z)) vector :key car)))))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c)) :key car) '(a)))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(a a)))
	(test-t (equal (find-if (lambda (x) (eq x 'b)) #((a) (b) (c) (a a) (b b) (c c)) :key car) '(b)))
	(test-t (equal (find-if (lambda (x) (eq x 'b)) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(b b)))
	(test-t (equal (find-if (lambda (x) (eq x 'c)) #((a) (b) (c) (a a) (b b) (c c)) :key car) '(c)))
	(test-t (equal (find-if (lambda (x) (eq x 'c)) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(c c)))
	(test-t (null (find-if (lambda (x) (eq x 'z)) #((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (find-if (lambda (x) (eq x 'z)) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) '(a a a)))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) '(a a a)))
	(test-t (equal (find-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) '(a a)))
	(test-t (null (find-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'a))) '(a b c)) 'a))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'b))) '(a b c)) 'b))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'c))) '(a b c)) 'c))
	(test-t (null (find-if-not (lambda (arg) (not (eq arg 'x))) '(a b c))))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 1)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'b))) '(a b c) :start 2)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'c))) '(a b c) :start 3)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 0 :end 0)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 1 :end 1)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 2 :end 2)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 3 :end 3)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :end nil) 'a))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'b))) '(a b c) :end nil) 'b))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'c))) '(a b c) :end nil) 'c))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :end 1) 'a))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'b))) '(a b c) :end 2) 'b))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'c))) '(a b c) :end 3) 'c))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '(a b c) :end 0)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'b))) '(a b c) :end 1)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'c))) '(a b c) :end 2)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c)))))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c)) :key car) '(a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'b))) '((a) (b) (c)) :key car) '(b)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'c))) '((a) (b) (c)) :key car) '(c)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'z))) '((a) (b) (c)) :key car)))
	(test-t (let ((list '((a) (b) (c))))
		  (and (eq (find-if-not (lambda (x) (not (eq x 'a))) list :key car)
			   (car list))
		       (eq (find-if-not (lambda (x) (not (eq x 'b))) list :key car)
			   (cadr list))
		       (eq (find-if-not (lambda (x) (not (eq x 'c))) list :key car)
			   (caddr list))
		       (null (find-if-not (lambda (x) (not (eq x 'z))) list :key car)))))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c)) :key car) '(a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(a a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'b))) '((a) (b) (c) (a a) (b b) (c c)) :key car) '(b)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'b))) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(b b)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'c))) '((a) (b) (c) (a a) (b b) (c c)) :key car) '(c)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'c))) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(c c)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'z))) '((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'z))) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) '(a a a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) '(a a a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) '(a a)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'a))) #(a b c)) 'a))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'b))) #(a b c)) 'b))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'c))) #(a b c)) 'c))
	(test-t (null (find-if-not (lambda (arg) (not (eq arg 'x))) #(a b c))))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 1)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'b))) #(a b c) :start 2)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'c))) #(a b c) :start 3)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 0 :end 0)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 1 :end 1)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 2 :end 2)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 3 :end 3)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :end nil) 'a))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'b))) #(a b c) :end nil) 'b))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'c))) #(a b c) :end nil) 'c))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :end 1) 'a))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'b))) #(a b c) :end 2) 'b))
	(test-t (eq (find-if-not (lambda (x) (not (eq x 'c))) #(a b c) :end 3) 'c))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #(a b c) :end 0)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'b))) #(a b c) :end 1)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'c))) #(a b c) :end 2)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c)))))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c)) :key car) '(a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'b))) #((a) (b) (c)) :key car) '(b)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'c))) #((a) (b) (c)) :key car) '(c)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'z))) #((a) (b) (c)) :key car)))
	(test-t (let ((vector #((a) (b) (c))))
		  (and (eq (find-if-not (lambda (x) (not (eq x 'a))) vector :key car)
			   (aref vector 0))
		       (eq (find-if-not (lambda (x) (not (eq x 'b))) vector :key car)
			   (aref vector 1))
		       (eq (find-if-not (lambda (x) (not (eq x 'c))) vector :key car)
			   (aref vector 2))
		       (null (find-if-not (lambda (x) (not (eq x 'z))) vector :key car)))))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c)) :key car) '(a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(a a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'b))) #((a) (b) (c) (a a) (b b) (c c)) :key car) '(b)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'b))) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(b b)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'c))) #((a) (b) (c) (a a) (b b) (c c)) :key car) '(c)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'c))) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) '(c c)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'z))) #((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'z))) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) '(a a a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) '(a a a)))
	(test-t (equal (find-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) '(a a)))
	(test-t (null (find-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (eql (position #\a "baobab" :from-end t) 4))
	(test-t (eql (position-if oddp '((1) (2) (3) (4)) :start 1 :key car) 2))
	(test-t (null (position 595 '())))
	(test-t (eql (position-if-not integerp '(1 2 3 4 5.0)) 4))
	(test-t (eql (position 'a '(a b c)) 0))
	(test-t (eql (position 'b '(a b c)) 1))
	(test-t (eql (position 'c '(a b c)) 2))
	(test-t (null (position 'x '(a b c))))
	(test-t (null (position 'a '(a b c) :start 1)))
	(test-t (null (position 'b '(a b c) :start 2)))
	(test-t (null (position 'c '(a b c) :start 3)))
	(test-t (null (position 'a '(a b c) :start 0 :end 0)))
	(test-t (null (position 'a '(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (position 'a '(a b c) :start 1 :end 1)))
	(test-t (null (position 'a '(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (position 'a '(a b c) :start 2 :end 2)))
	(test-t (null (position 'a '(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (position 'a '(a b c) :start 3 :end 3)))
	(test-t (null (position 'a '(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eql (position 'a '(a b c) :end nil) '0))
	(test-t (eql (position 'b '(a b c) :end nil) '1))
	(test-t (eql (position 'c '(a b c) :end nil) '2))
	(test-t (eql (position 'a '(a b c) :end 1) '0))
	(test-t (eql (position 'b '(a b c) :end 2) '1))
	(test-t (eql (position 'c '(a b c) :end 3) '2))
	(test-t (null (position 'a '(a b c) :end 0)))
	(test-t (null (position 'b '(a b c) :end 1)))
	(test-t (null (position 'c '(a b c) :end 2)))
	(test-t (null (position 'a '((a) (b) (c)))))
	(test-t (eql (position 'a '((a) (b) (c)) :key car) 0))
	(test-t (eql (position 'b '((a) (b) (c)) :key car) 1))
	(test-t (eql (position 'c '((a) (b) (c)) :key car) 2))
	(test-t (null (position 'z '((a) (b) (c)) :key car)))
	(test-t (null (position '(a) '((a) (b) (c)))))
	(test-t (eql (position '(a) '((a) (b) (c)) :test equal) 0))
	(test-t (null (position '("a") '(("a") ("b") ("c")))))
	(test-t (eql (position 3 '(0 1 2 3 4 5)) 3))
	(test-t (eql (position 3 '(0 1 2 3 4 5) :test <) 4))
	(test-t (eql (position 3 '(0 1 2 3 4 5) :test >) 0))
	(test-t (eql (position 'a '((a) (b) (c) (a a) (b b) (c c)) :key car) 0))
	(test-t (eql (position 'a '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 3))
	(test-t (eql (position 'b '((a) (b) (c) (a a) (b b) (c c)) :key car) 1))
	(test-t (eql (position 'b '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 4))
	(test-t (eql (position 'c '((a) (b) (c) (a a) (b b) (c c)) :key car) 2))
	(test-t (eql (position 'c '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 5))
	(test-t (null (position 'z '((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (position 'z '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (eql (position 'a '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) 6))
	(test-t (eql (position 'a '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) 6))
	(test-t (eql (position 'a '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) 3))
	(test-t (null (position 'a '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (eql (position 'a #(a b c)) 0))
	(test-t (eql (position 'b #(a b c)) 1))
	(test-t (eql (position 'c #(a b c)) 2))
	(test-t (null (position 'x #(a b c))))
	(test-t (null (position 'a #(a b c) :start 1)))
	(test-t (null (position 'b #(a b c) :start 2)))
	(test-t (null (position 'c #(a b c) :start 3)))
	(test-t (null (position 'a #(a b c) :start 0 :end 0)))
	(test-t (null (position 'a #(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (position 'a #(a b c) :start 1 :end 1)))
	(test-t (null (position 'a #(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (position 'a #(a b c) :start 2 :end 2)))
	(test-t (null (position 'a #(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (position 'a #(a b c) :start 3 :end 3)))
	(test-t (null (position 'a #(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eql (position 'a #(a b c) :end nil) 0))
	(test-t (eql (position 'b #(a b c) :end nil) 1))
	(test-t (eql (position 'c #(a b c) :end nil) 2))
	(test-t (eql (position 'a #(a b c) :end 1) 0))
	(test-t (eql (position 'b #(a b c) :end 2) 1))
	(test-t (eql (position 'c #(a b c) :end 3) 2))
	(test-t (null (position 'a #(a b c) :end 0)))
	(test-t (null (position 'b #(a b c) :end 1)))
	(test-t (null (position 'c #(a b c) :end 2)))
	(test-t (null (position 'a #((a) (b) (c)))))
	(test-t (eql (position 'a #((a) (b) (c)) :key car) 0))
	(test-t (eql (position 'b #((a) (b) (c)) :key car) 1))
	(test-t (eql (position 'c #((a) (b) (c)) :key car) 2))
	(test-t (null (position 'z #((a) (b) (c)) :key car)))
	(test-t (null (position '(a) #((a) (b) (c)))))
	(test-t (eql (position '(a) #((a) (b) (c)) :test equal) 0))
	(test-t (null (position '("a") #(("a") ("b") ("c")))))
	(test-t (eql (position 3 #(0 1 2 3 4 5)) 3))
	(test-t (eql (position 3 #(0 1 2 3 4 5) :test <) 4))
	(test-t (eql (position 3 #(0 1 2 3 4 5) :test >) 0))
	(test-t (eql (position 'a #((a) (b) (c) (a a) (b b) (c c)) :key car) 0))
	(test-t (eql (position 'a #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 3))
	(test-t (eql (position 'b #((a) (b) (c) (a a) (b b) (c c)) :key car) 1))
	(test-t (eql (position 'b #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 4))
	(test-t (eql (position 'c #((a) (b) (c) (a a) (b b) (c c)) :key car) 2))
	(test-t (eql (position 'c #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 5))
	(test-t (null (position 'z #((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (position 'z #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (eql (position 'a #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) 6))
	(test-t (eql (position 'a #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) 6))
	(test-t (eql (position 'a #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) 3))
	(test-t (null (position 'a #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (null (position #\z "abcABC")))
	(test-t (eql (position #\a "abcABC") 0))
	(test-t (eql (position #\A "abcABC") 3))
	(test-t (eql (position #\A "abcABC" :test char-equal) 0))
	(test-t (eql (position #\A "abcABC" :test char-equal :from-end t) 3))
	(test-t (eql (position #\a "abcABC" :test char-equal :from-end t) 3))
	(test-t (eql (position #\a "abcABC" :test char-equal :from-end t :end 4) 3))
	(test-t (eql (position #\a "abcABC" :test char-equal :from-end t :end 3) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) '(a b c)) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) '(a b c)) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) '(a b c)) 2))
	(test-t (null (position-if (lambda (arg) (eq arg 'x)) '(a b c))))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :start 1)))
	(test-t (null (position-if (lambda (x) (eq x 'b)) '(a b c) :start 2)))
	(test-t (null (position-if (lambda (x) (eq x 'c)) '(a b c) :start 3)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :start 0 :end 0)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :start 1 :end 1)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :start 2 :end 2)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :start 3 :end 3)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) '(a b c) :end nil) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) '(a b c) :end nil) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) '(a b c) :end nil) 2))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) '(a b c) :end 1) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) '(a b c) :end 2) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) '(a b c) :end 3) 2))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '(a b c) :end 0)))
	(test-t (null (position-if (lambda (x) (eq x 'b)) '(a b c) :end 1)))
	(test-t (null (position-if (lambda (x) (eq x 'c)) '(a b c) :end 2)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '((a) (b) (c)))))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) '((a) (b) (c)) :key car) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) '((a) (b) (c)) :key car) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) '((a) (b) (c)) :key car) 2))
	(test-t (null (position-if (lambda (x) (eq x 'z)) '((a) (b) (c)) :key car)))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c)) :key car) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 3))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) '((a) (b) (c) (a a) (b b) (c c)) :key car) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 4))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) '((a) (b) (c) (a a) (b b) (c c)) :key car) 2))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 5))
	(test-t (null (position-if (lambda (x) (eq x 'z)) '((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (position-if (lambda (x) (eq x 'z)) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) 6))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) 6))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) 3))
	(test-t (null (position-if (lambda (x) (eq x 'a)) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) #(a b c)) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) #(a b c)) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) #(a b c)) 2))
	(test-t (null (position-if (lambda (arg) (eq arg 'x)) #(a b c))))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :start 1)))
	(test-t (null (position-if (lambda (x) (eq x 'b)) #(a b c) :start 2)))
	(test-t (null (position-if (lambda (x) (eq x 'c)) #(a b c) :start 3)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :start 0 :end 0)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :start 1 :end 1)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :start 2 :end 2)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :start 3 :end 3)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) #(a b c) :end nil) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) #(a b c) :end nil) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) #(a b c) :end nil) 2))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) #(a b c) :end 1) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) #(a b c) :end 2) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) #(a b c) :end 3) 2))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #(a b c) :end 0)))
	(test-t (null (position-if (lambda (x) (eq x 'b)) #(a b c) :end 1)))
	(test-t (null (position-if (lambda (x) (eq x 'c)) #(a b c) :end 2)))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #((a) (b) (c)))))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) #((a) (b) (c)) :key car) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) #((a) (b) (c)) :key car) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) #((a) (b) (c)) :key car) 2))
	(test-t (null (position-if (lambda (x) (eq x 'z)) #((a) (b) (c)) :key car)))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c)) :key car) 0))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 3))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) #((a) (b) (c) (a a) (b b) (c c)) :key car) 1))
	(test-t (eql (position-if (lambda (x) (eq x 'b)) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 4))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) #((a) (b) (c) (a a) (b b) (c c)) :key car) 2))
	(test-t (eql (position-if (lambda (x) (eq x 'c)) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 5))
	(test-t (null (position-if (lambda (x) (eq x 'z)) #((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (position-if (lambda (x) (eq x 'z)) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) 6))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) 6))
	(test-t (eql (position-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) 3))
	(test-t (null (position-if (lambda (x) (eq x 'a)) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) '(a b c)) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) '(a b c)) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) '(a b c)) 2))
	(test-t (null (position-if-not (lambda (arg) (not (eq arg 'x))) '(a b c))))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 1)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'b))) '(a b c) :start 2)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'c))) '(a b c) :start 3)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 0 :end 0)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 1 :end 1)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 2 :end 2)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 3 :end 3)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :end nil) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) '(a b c) :end nil) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) '(a b c) :end nil) 2))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :end 1) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) '(a b c) :end 2) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) '(a b c) :end 3) 2))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '(a b c) :end 0)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'b))) '(a b c) :end 1)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'c))) '(a b c) :end 2)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c)))))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c)) :key car) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) '((a) (b) (c)) :key car) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) '((a) (b) (c)) :key car) 2))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'z))) '((a) (b) (c)) :key car)))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c)) :key car) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 3))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) '((a) (b) (c) (a a) (b b) (c c)) :key car) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 4))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) '((a) (b) (c) (a a) (b b) (c c)) :key car) 2))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 5))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'z))) '((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'z))) '((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) 6))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) 6))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) 3))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) '((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) #(a b c)) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) #(a b c)) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) #(a b c)) 2))
	(test-t (null (position-if-not (lambda (arg) (not (eq arg 'x))) #(a b c))))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 1)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'b))) #(a b c) :start 2)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'c))) #(a b c) :start 3)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 0 :end 0)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 0 :end 0 :from-end t)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 1 :end 1)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 1 :end 1 :from-end t)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 2 :end 2)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 2 :end 2 :from-end t)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 3 :end 3)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :start 3 :end 3 :from-end t)))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :end nil) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) #(a b c) :end nil) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) #(a b c) :end nil) 2))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :end 1) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) #(a b c) :end 2) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) #(a b c) :end 3) 2))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #(a b c) :end 0)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'b))) #(a b c) :end 1)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'c))) #(a b c) :end 2)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c)))))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c)) :key car) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) #((a) (b) (c)) :key car) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) #((a) (b) (c)) :key car) 2))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'z))) #((a) (b) (c)) :key car)))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c)) :key car) 0))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 3))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) #((a) (b) (c) (a a) (b b) (c c)) :key car) 1))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'b))) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 4))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) #((a) (b) (c) (a a) (b b) (c c)) :key car) 2))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'c))) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t) 5))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'z))) #((a) (b) (c) (a a) (b b) (c c)) :key car)))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'z))) #((a) (b) (c) (a a) (b b) (c c)) :key car :from-end t)))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t) 6))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end nil) 6))
	(test-t (eql (position-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :end 6) 3))
	(test-t (null (position-if-not (lambda (x) (not (eq x 'a))) #((a) (b) (c) (a a) (b b) (c c) (a a a)) :key car :from-end t :start 1 :end 3)))
	
	(test-t (eql (search "dog" "it's a dog's life") 7))
	(test-t (eql (search '(0 1) '(2 4 6 1 3 5) :key oddp) 2))
	(test-t (null (search '(a b c) '(x y z))))
	(test-t (eql (search '() '(x y z)) 0))
	(test-t (eql (search '(a) '(a)) 0))
	(test-t (eql (search '(a b c) '(a b c x y z)) 0))
	(test-t (eql (search '(a b c) '(x a b c y z)) 1))
	(test-t (eql (search '(a b c) '(x y a b c z)) 2))
	(test-t (eql (search '(a b c) '(x y z a b c)) 3))
	(test-t (eql (search '(a b c) '(a b c a b c) :start2 1) 3))
	(test-t (eql (search '(a b c) '(a b c a b c) :start2 1 :end2 nil) 3))
	(test-t (eql (search '(a b c) '(a b c a b c) :start1 1 :start2 1 :end2 nil) 1))
	(test-t (eql (search '(a b c) '(a b c a b c) :start1 1 :end1 nil :start2 1 :end2 nil) 1))
	(test-t (null (search '(a b c) '(a b c a b c) :start2 0 :end2 0)))
	(test-t (null (search '(a b c) '(a b c a b c) :start2 1 :end2 1)))
	(test-t (null (search '(a b c) '(a b c a b c) :start2 2 :end2 2)))
	(test-t (null (search '(a b c) '(a b c a b c) :start2 3 :end2 3)))
	(test-t (null (search '(a b c) '(a b c a b c) :start2 4 :end2 4)))
	(test-t (null (search '(a b c) '(a b c a b c) :start2 5 :end2 5)))
	(test-t (null (search '(a b c) '(a b c a b c) :start2 6 :end2 6)))
	(test-t (eql (search '(a b c) '(a b c a b c)) 0))
	(test-t (eql (search '(a b c) '(a b c a b c) :from-end t) 3))
	(test-t (eql (search '(a b c) '(a b c a b c) :start2 3 :end2 6) 3))
	(test-t (eql (search '(a b c) '(a b c a b c) :start2 3 :end2 6 :from-end t) 3))
	(test-t (eql (search '(a b c) '(a b c a b c) :start1 0 :end1 2 :start2 0 :end2 6) 0))
	(test-t (eql (search '(a b c) '(a b c a b c) :start1 0 :end1 2 :start2 0 :end2 6 :from-end t) 3))
	(test-t (null (search '(#\a #\b #\c) '(#\A #\B #\C))))
	(test-t (eql (search '(#\a #\b #\c) '(#\A #\B #\C) :test char-equal) 0))
	(test-t (eql (search '(#\a #\b) '(#\a #\b #\x #\y #\z)) 0))
	(test-t (eql (search '(#\a #\b) '(#\a #\b #\x #\y #\z) :test char<) 1))
	(test-t (null (search '((a) (b)) '((x) (y) (z) (a) (b) (c)))))
	(test-t (eql (search '((a) (b)) '((x) (y) (z) (a) (b) (c)) :key car) 3))
	(test-t (eql (search '((a) (b)) '((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car) 0))
	(test-t (eql (search '((a) (b)) '((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car :from-end t) 6))
	(test-t (eql (search '((a a) (b b)) '((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car) 0))
	(test-t (eql (search '((a a) (b b)) '((a nil) (b t) (c nil) (x) (y) (z) (a 0) (b 1) (c 2)) :key car :from-end t) 6))
	(test-t (eql (search '(("a" a) ("b" b))
			     '(("a" nil) ("b" t) ("c" nil) ("x") ("y") ("z")
			       ("A" 0) ("B" 1) ("C" 2))
			     :start1 1
			     :end1 2
			     :start2 3
			     :end2 nil
			     :key car
			     :test string-equal
			     :from-end t)
		     7))
	(test-t (null (search #(a b c) '(x y z))))
	(test-t (eql (search #() '(x y z)) 0))
	(test-t (eql (search #(a) '(a)) 0))
	(test-t (eql (search #(a b c) '(a b c x y z)) 0))
	(test-t (eql (search #(a b c) '(x a b c y z)) 1))
	(test-t (eql (search #(a b c) '(x y a b c z)) 2))
	(test-t (eql (search #(a b c) '(x y z a b c)) 3))
	(test-t (eql (search #(a b c) '(a b c a b c) :start2 1) 3))
	(test-t (eql (search #(a b c) '(a b c a b c) :start2 1 :end2 nil) 3))
	(test-t (eql (search #(a b c) '(a b c a b c) :start1 1 :start2 1 :end2 nil) 1))
	(test-t (eql (search #(a b c) '(a b c a b c) :start1 1 :end1 nil :start2 1 :end2 nil) 1))
	(test-t (null (search #(a b c) '(a b c a b c) :start2 0 :end2 0)))
	(test-t (null (search #(a b c) '(a b c a b c) :start2 1 :end2 1)))
	(test-t (null (search #(a b c) '(a b c a b c) :start2 2 :end2 2)))
	(test-t (null (search #(a b c) '(a b c a b c) :start2 3 :end2 3)))
	(test-t (null (search #(a b c) '(a b c a b c) :start2 4 :end2 4)))
	(test-t (null (search #(a b c) '(a b c a b c) :start2 5 :end2 5)))
	(test-t (null (search #(a b c) '(a b c a b c) :start2 6 :end2 6)))
	(test-t (eql (search #(a b c) '(a b c a b c)) 0))
	(test-t (eql (search #(a b c) '(a b c a b c) :from-end t) 3))
	(test-t (eql (search #(a b c) '(a b c a b c) :start2 3 :end2 6) 3))
	(test-t (eql (search #(a b c) '(a b c a b c) :start2 3 :end2 6 :from-end t) 3))
	(test-t (eql (search #(a b c) '(a b c a b c) :start1 0 :end1 2 :start2 0 :end2 6) 0))
	(test-t (eql (search #(a b c) '(a b c a b c) :start1 0 :end1 2 :start2 0 :end2 6 :from-end t) 3))
	(test-t (null (search #(#\a #\b #\c) '(#\A #\B #\C))))
	(test-t (eql (search #(#\a #\b #\c) '(#\A #\B #\C) :test char-equal) 0))
	(test-t (eql (search #(#\a #\b) '(#\a #\b #\x #\y #\z)) 0))
	(test-t (eql (search #(#\a #\b) '(#\a #\b #\x #\y #\z) :test char<) 1))
	(test-t (null (search #((a) (b)) '((x) (y) (z) (a) (b) (c)))))
	(test-t (eql (search #((a) (b)) '((x) (y) (z) (a) (b) (c)) :key car) 3))
	(test-t (eql (search #((a) (b)) '((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car) 0))
	(test-t (eql (search #((a) (b)) '((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car :from-end t) 6))
	(test-t (eql (search #((a a) (b b)) '((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car) 0))
	(test-t (eql (search #((a a) (b b)) '((a nil) (b t) (c nil) (x) (y) (z) (a 0) (b 1) (c 2)) :key car :from-end t) 6))
	(test-t (eql (search #(("a" a) ("b" b))
			     '(("a" nil) ("b" t) ("c" nil) ("x") ("y") ("z")
			       ("A" 0) ("B" 1) ("C" 2))
			     :start1 1
			     :end1 2
			     :start2 3
			     :end2 nil
			     :key car
			     :test string-equal
			     :from-end t)
		     7))
	(test-t (null (search '(a b c) #(x y z))))
	(test-t (eql (search '() #(x y z)) 0))
	(test-t (eql (search '(a) #(a)) 0))
	(test-t (eql (search '(a b c) #(a b c x y z)) 0))
	(test-t (eql (search '(a b c) #(x a b c y z)) 1))
	(test-t (eql (search '(a b c) #(x y a b c z)) 2))
	(test-t (eql (search '(a b c) #(x y z a b c)) 3))
	(test-t (eql (search '(a b c) #(a b c a b c) :start2 1) 3))
	(test-t (eql (search '(a b c) #(a b c a b c) :start2 1 :end2 nil) 3))
	(test-t (eql (search '(a b c) #(a b c a b c) :start1 1 :start2 1 :end2 nil) 1))
	(test-t (eql (search '(a b c) #(a b c a b c) :start1 1 :end1 nil :start2 1 :end2 nil) 1))
	(test-t (null (search '(a b c) #(a b c a b c) :start2 0 :end2 0)))
	(test-t (null (search '(a b c) #(a b c a b c) :start2 1 :end2 1)))
	(test-t (null (search '(a b c) #(a b c a b c) :start2 2 :end2 2)))
	(test-t (null (search '(a b c) #(a b c a b c) :start2 3 :end2 3)))
	(test-t (null (search '(a b c) #(a b c a b c) :start2 4 :end2 4)))
	(test-t (null (search '(a b c) #(a b c a b c) :start2 5 :end2 5)))
	(test-t (null (search '(a b c) #(a b c a b c) :start2 6 :end2 6)))
	(test-t (eql (search '(a b c) #(a b c a b c)) 0))
	(test-t (eql (search '(a b c) #(a b c a b c) :from-end t) 3))
	(test-t (eql (search '(a b c) #(a b c a b c) :start2 3 :end2 6) 3))
	(test-t (eql (search '(a b c) #(a b c a b c) :start2 3 :end2 6 :from-end t) 3))
	(test-t (eql (search '(a b c) #(a b c a b c) :start1 0 :end1 2 :start2 0 :end2 6) 0))
	(test-t (eql (search '(a b c) #(a b c a b c) :start1 0 :end1 2 :start2 0 :end2 6 :from-end t) 3))
	(test-t (null (search '(#\a #\b #\c) #(#\A #\B #\C))))
	(test-t (eql (search '(#\a #\b #\c) #(#\A #\B #\C) :test char-equal) 0))
	(test-t (eql (search '(#\a #\b) #(#\a #\b #\x #\y #\z)) 0))
	(test-t (eql (search '(#\a #\b) #(#\a #\b #\x #\y #\z) :test char<) 1))
	(test-t (null (search '((a) (b)) #((x) (y) (z) (a) (b) (c)))))
	(test-t (eql (search '((a) (b)) #((x) (y) (z) (a) (b) (c)) :key car) 3))
	(test-t (eql (search '((a) (b)) #((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car) 0))
	(test-t (eql (search '((a) (b)) #((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car :from-end t) 6))
	(test-t (eql (search '((a a) (b b)) #((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car) 0))
	(test-t (eql (search '((a a) (b b)) #((a nil) (b t) (c nil) (x) (y) (z) (a 0) (b 1) (c 2)) :key car :from-end t) 6))
	(test-t (eql (search '(("a" a) ("b" b))
			     #(("a" nil) ("b" t) ("c" nil) ("x") ("y") ("z")
			       ("A" 0) ("B" 1) ("C" 2))
			     :start1 1
			     :end1 2
			     :start2 3
			     :end2 nil
			     :key car
			     :test string-equal
			     :from-end t)
		     7))
	(test-t (null (search #(a b c) #(x y z))))
	(test-t (eql (search #() #(x y z)) 0))
	(test-t (eql (search #(a) #(a)) 0))
	(test-t (eql (search #(a b c) #(a b c x y z)) 0))
	(test-t (eql (search #(a b c) #(x a b c y z)) 1))
	(test-t (eql (search #(a b c) #(x y a b c z)) 2))
	(test-t (eql (search #(a b c) #(x y z a b c)) 3))
	(test-t (eql (search #(a b c) #(a b c a b c) :start2 1) 3))
	(test-t (eql (search #(a b c) #(a b c a b c) :start2 1 :end2 nil) 3))
	(test-t (eql (search #(a b c) #(a b c a b c) :start1 1 :start2 1 :end2 nil) 1))
	(test-t (eql (search #(a b c) #(a b c a b c) :start1 1 :end1 nil :start2 1 :end2 nil) 1))
	(test-t (null (search #(a b c) #(a b c a b c) :start2 0 :end2 0)))
	(test-t (null (search #(a b c) #(a b c a b c) :start2 1 :end2 1)))
	(test-t (null (search #(a b c) #(a b c a b c) :start2 2 :end2 2)))
	(test-t (null (search #(a b c) #(a b c a b c) :start2 3 :end2 3)))
	(test-t (null (search #(a b c) #(a b c a b c) :start2 4 :end2 4)))
	(test-t (null (search #(a b c) #(a b c a b c) :start2 5 :end2 5)))
	(test-t (null (search #(a b c) #(a b c a b c) :start2 6 :end2 6)))
	(test-t (eql (search #(a b c) #(a b c a b c)) 0))
	(test-t (eql (search #(a b c) #(a b c a b c) :from-end t) 3))
	(test-t (eql (search #(a b c) #(a b c a b c) :start2 3 :end2 6) 3))
	(test-t (eql (search #(a b c) #(a b c a b c) :start2 3 :end2 6 :from-end t) 3))
	(test-t (eql (search #(a b c) #(a b c a b c) :start1 0 :end1 2 :start2 0 :end2 6) 0))
	(test-t (eql (search #(a b c) #(a b c a b c) :start1 0 :end1 2 :start2 0 :end2 6 :from-end t) 3))
	(test-t (null (search #(#\a #\b #\c) #(#\A #\B #\C))))
	(test-t (eql (search #(#\a #\b #\c) #(#\A #\B #\C) :test char-equal) 0))
	(test-t (eql (search #(#\a #\b) #(#\a #\b #\x #\y #\z)) 0))
	(test-t (eql (search #(#\a #\b) #(#\a #\b #\x #\y #\z) :test char<) 1))
	(test-t (null (search #((a) (b)) #((x) (y) (z) (a) (b) (c)))))
	(test-t (eql (search #((a) (b)) #((x) (y) (z) (a) (b) (c)) :key car) 3))
	(test-t (eql (search #((a) (b)) #((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car) 0))
	(test-t (eql (search #((a) (b)) #((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car :from-end t) 6))
	(test-t (eql (search #((a a) (b b)) #((a) (b) (c) (x) (y) (z) (a) (b) (c)) :key car) 0))
	(test-t (eql (search #((a a) (b b)) #((a nil) (b t) (c nil) (x) (y) (z) (a 0) (b 1) (c 2)) :key car :from-end t) 6))
	(test-t (eql (search #(("a" a) ("b" b))
			     #(("a" nil) ("b" t) ("c" nil) ("x") ("y") ("z")
			       ("A" 0) ("B" 1) ("C" 2))
			     :start1 1
			     :end1 2
			     :start2 3
			     :end2 nil
			     :key car
			     :test string-equal
			     :from-end t)
		     7))
	(test-t (null (search "peace" "LOVE&PEACE")))
	(test-t (eql (search "peace" "LOVE&PEACE" :test char-equal) 5))
	(test-t (null (search "PeAcE" "LoVe&pEaCe")))
	(test-t (eql (search "PeAcE" "LoVe&pEaCe" :key char-upcase) 5))
	(test-t (eql (search "abc" "abc xyz abc" :from-end t) 8))
	(test-t (eql (search "abc" "abc xyz abc xyz abc xyz abc" :start2 8 :end2 19) 8))
	(test-t (eql (search "abc" "abc xyz abc xyz abc xyz abc" :from-end t :start2 8 :end2 19) 16))
	(test-t (eql (mismatch "abcd" "ABCDE" :test char-equal) 4))
	(test-t (eql (mismatch '(3 2 1 1 2 3) '(1 2 3) :from-end t) 3))
	(test-t (null (mismatch '(1 2 3 4 5 6) '(3 4 5 6 7) :start1 2 :end2 4)))
	(test-t (null (mismatch '() '())))
	(test-t (eql (mismatch '(a b c) '(x y z)) 0))
	(test-t (eql (mismatch '() '(x y z)) 0))
	(test-t (eql (mismatch '(x y z) '()) 0))
	(test-t (null (mismatch '(a) '(a))))
	(test-t (eql (mismatch '(a b c x y z) '(a b c)) 3))
	(test-t (null (mismatch '(a b c) '(a b c))))
	(test-t (eql (mismatch '(a b c d e f) '(a b c)) 3))
	(test-t (eql (mismatch '(a b c) '(a b c d e f)) 3))
	(test-t (eql (mismatch '(a b c) '(a b x)) 2))
	(test-t (eql (mismatch '(a b c) '(a x c)) 1))
	(test-t (eql (mismatch '(a b c) '(x b c)) 0))
	(test-t (eql (mismatch '(x y z a b c x y z) '(a b c) :start1 3) 6))
	(test-t (eql (mismatch '(x y z a b c x y z) '(a b c) :start1 3 :end1 nil) 6))
	(test-t (eql (mismatch '(x y z a b c x y z) '(a b c) :start1 3 :end1 4) 4))
	(test-t (eql (mismatch '(x y z a b c x y z) '(a b c) :start1 3 :end1 3) 3))
	(test-t (null (mismatch '(x y z) '() :start1 0 :end1 0)))
	(test-t (null (mismatch '(x y z) '() :start1 1 :end1 1)))
	(test-t (null (mismatch '(x y z) '() :start1 2 :end1 2)))
	(test-t (null (mismatch '(x y z) '() :start1 3 :end1 3)))
	(test-t (null (mismatch '(x y z) '() :start1 0 :end1 0 :start2 0 :end2 0)))
	(test-t (null (mismatch '(x y z) '() :start1 1 :end1 1 :start2 1 :end2 1)))
	(test-t (null (mismatch '(x y z) '() :start1 2 :end1 2 :start2 2 :end2 2)))
	(test-t (null (mismatch '(x y z) '() :start1 3 :end1 3 :start2 3 :end2 3)))
	(test-t (null (mismatch '(x y z) '() :start1 0 :end1 0 :start2 3 :end2 3)))
	(test-t (null (mismatch '(x y z) '() :start1 1 :end1 1 :start2 2 :end2 2)))
	(test-t (null (mismatch '(x y z) '() :start1 2 :end1 2 :start2 1 :end2 1)))
	(test-t (null (mismatch '(x y z) '() :start1 3 :end1 3 :start2 0 :end2 0)))
	(test-t (eql (mismatch '(x y z) '(a b c) :start1 0 :end1 0) 0))
	(test-t (eql (mismatch '(x y z) '(a b c) :start1 1 :end1 1) 1))
	(test-t (eql (mismatch '(x y z) '(a b c) :start1 2 :end1 2) 2))
	(test-t (eql (mismatch '(x y z) '(a b c) :start1 3 :end1 3) 3))
	(test-t (eql (mismatch '(x y z) '(x y z) :start1 0 :end1 1) 1))
	(test-t (eql (mismatch '(x y z) '(x y z) :start1 0 :end1 2) 2))
	(test-t (eql (mismatch '(x y z) '(x y z Z) :start1 0 :end1 3) 3))
	(test-t (null (mismatch '(x y z) '(x y z) :start1 0 :end1 3)))
	(test-t (eql (mismatch '(a b c x y z) '(x y z a b c)) 0))
	(test-t (eql (mismatch '(a b c x y z) '(x y z a b c) :start1 3) 6))
	(test-t (eql (mismatch '(a b c x y z a b c) '(x y z a b c x y z) :start1 3) 9))
	(test-t (eql (mismatch '(a b c x y z a b c) '(x y z a b c x y z) :start1 6) 6))
	(test-t (eql (mismatch '(a b c x y z a b c) '(x y z a b c x y z) :start1 6 :start2 3) 9))
	(test-t (eql (mismatch '(a b c x y z a b c) '(x y z a b c x y z) :start1 0 :start2 3) 6))
	(test-t (eql (mismatch '(a b c) '(a b c x y z)) 3))
	(test-t (eql (mismatch '(a b c) '(x a b c y z)) 0))
	(test-t (eql (mismatch '(a b c) '(x a b c y z) :start2 1) 3))
	(test-t (eql (mismatch '(a b c) '(x a b c y z) :start2 1 :end2 nil) 3))
	(test-t (null (mismatch '(a b c) '(x a b c y z) :start2 1 :end2 4)))
	(test-t (eql (mismatch '(a b c d e) '(c d)) 0))
	(test-t (eql (mismatch '(a b c d e) '(c d) :start1 2) 4))
	(test-t (eql (mismatch '(a b c d e) '(c d) :start1 2 :end1 3) 3))
	(test-t (eql (mismatch '(a b c d e) '(c d) :start1 2 :start2 1) 2))
	(test-t (eql (mismatch '(a b c d e) '(c d) :start1 3 :start2 1) 4))
	(test-t (eql (mismatch '(a b c d e) '(c d) :start1 2 :end2 1) 3))
	(test-t (null (mismatch '(a b c d) '(a b c d) :start1 1 :end1 2 :start2 1 :end2 2)))
	(test-t (null (mismatch '(a b c d) '(a b c d) :start1 1 :end1 3 :start2 1 :end2 3)))
	(test-t (null (mismatch '(a b c d) '(a b c d) :start1 1 :end1 4 :start2 1 :end2 4)))
	(test-t (eql (mismatch '(a b c d) '(a b c d) :start1 1 :end1 nil :start2 1 :end2 1) 1))
	(test-t (eql (mismatch '(a b c d) '(a b c d) :start1 1 :end1 nil :start2 1 :end2 2) 2))
	(test-t (eql (mismatch '(a b c d) '(a b c d) :start1 1 :end1 nil :start2 1 :end2 3) 3))
	(test-t (null (mismatch '(a b c d) '(a b c d) :start1 1 :end1 nil :start2 1 :end2 4)))
	(test-t (eql (mismatch '(a b c d) '(a b c d) :start1 1 :end1 1 :start2 1) 1))
	(test-t (eql (mismatch '(a b c d) '(a b c d) :start1 1 :end1 2 :start2 1) 2))
	(test-t (eql (mismatch '(a b c d) '(a b c d) :start1 1 :end1 3 :start2 1) 3))
	(test-t (null (mismatch '(a b c d) '(a b c d) :start1 1 :end1 4 :start2 1)))
	(test-t (null (mismatch '(a b c) '(a b c) :from-end t)))
	(test-t (eql (mismatch '(a b c d) '(a b c) :from-end t) 4))
	(test-t (eql (mismatch '(a b c) '(c) :from-end t) 2))
	(test-t (eql (mismatch '(a b c) '(z a b c) :from-end t) 0))
	(test-t (eql (mismatch '(a b c) '(x y z a b c) :from-end t) 0))
	(test-t (eql (mismatch '(x y z a b c) '(a b c) :from-end t) 3))
	(test-t (eql (mismatch '(x y z a b c) '(a b c) :end1 3 :from-end t) 3))
	(test-t (eql (mismatch '(x y z a b c) '(a b c) :end1 5 :from-end t) 5))
	(test-t (eql (mismatch '(x y z a b c x y z) '(a b c) :end1 6 :from-end t) 3))
	(test-t (eql (mismatch '(x y z a b c x y z) '(a b c) :start1 2 :end1 6 :from-end t) 3))
	(test-t (eql (mismatch '(x y z a b c x y z) '(a b c) :from-end t :start1 2 :end1 5 :start2 1 :end2 2 ) 4))
	(test-t (eql (mismatch '(x y z a b c x y z) '(a b c) :start1 2 :end1 5 :start2 1 :end2 2 ) 2))
	(test-t (eql (mismatch '((a) (b) (c)) '((a) (b) (c))) 0))
	(test-t (null (mismatch '((a) (b) (c)) '((a) (b) (c)) :key car)))
	(test-t (null (mismatch '((a) (b) (c)) '((a) (b) (c)) :test equal)))
	(test-t (eql (mismatch '(#(a) #(b) #(c)) '(#(a) #(b) #(c))) 0))
	(test-t (null (mismatch '(#(a) #(b) #(c)) '(#(a) #(b) #(c)) :test equalp)))
	(test-t (eql (mismatch '((a) (b) (c) (d)) '((a) (b) (c)) :key car) 3))
	(test-t (eql (mismatch '((a) (b) (c)) '((a) (b) (c) (d)) :key car) 3))
	(test-t (eql (mismatch '(#\a #\b #\c) '(#\A #\B #\C)) 0))
	(test-t (null (mismatch '(#\a #\b #\c) '(#\A #\B #\C) :key char-upcase)))
	(test-t (null (mismatch '(#\a #\b #\c) '(#\A #\B #\C) :key char-downcase)))
	(test-t (null (mismatch '(#\a #\b #\c) '(#\A #\B #\C) :key char-upcase :start1 1 :end1 2 :start2 1 :end2 2)))
	(test-t (null (mismatch '(#\a #\b #\c) '(#\A #\B #\C) :key char-upcase :start1 2 :start2 2)))
	(test-t (eql (mismatch '((a b c) (b c d) (d e f)) '((b b c) (c c d) (e e f))) 0))
	(test-t (eql (mismatch '((a b c) (b c d) (d e f)) '((b b c) (c c d) (e e f)) :key cdr) 0))
	(test-t (null (mismatch '((a b c) (b c d) (d e f)) '((b b c) (c c d) (e e f)) :key cdr :test equal)))
	(test-t (eql (mismatch '((a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal) 3))
	(test-t (eql (mismatch '((a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t) 4))
	(test-t (eql (mismatch '((a a a) (a b c) (b c d) (d e f)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t) 1))
	(test-t (null (mismatch '((a a a) (a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :start1 1 :end1 4)))
	(test-t (eql (mismatch '((a a a) (a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :start1 1) 5))
	(test-t (eql (mismatch '((a a a) (a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :end1 3 :start2 1 :end2 2) 2))
	(test-t (null (mismatch #() '())))
	(test-t (eql (mismatch #(a b c) '(x y z)) 0))
	(test-t (eql (mismatch #() '(x y z)) 0))
	(test-t (eql (mismatch #(x y z) '()) 0))
	(test-t (null (mismatch #(a) '(a))))
	(test-t (eql (mismatch #(a b c x y z) '(a b c)) 3))
	(test-t (null (mismatch #(a b c) '(a b c))))
	(test-t (eql (mismatch #(a b c d e f) '(a b c)) 3))
	(test-t (eql (mismatch #(a b c) '(a b c d e f)) 3))
	(test-t (eql (mismatch #(a b c) '(a b x)) 2))
	(test-t (eql (mismatch #(a b c) '(a x c)) 1))
	(test-t (eql (mismatch #(a b c) '(x b c)) 0))
	(test-t (eql (mismatch #(x y z a b c x y z) '(a b c) :start1 3) 6))
	(test-t (eql (mismatch #(x y z a b c x y z) '(a b c) :start1 3 :end1 nil) 6))
	(test-t (eql (mismatch #(x y z a b c x y z) '(a b c) :start1 3 :end1 4) 4))
	(test-t (eql (mismatch #(x y z a b c x y z) '(a b c) :start1 3 :end1 3) 3))
	(test-t (null (mismatch #(x y z) '() :start1 0 :end1 0)))
	(test-t (null (mismatch #(x y z) '() :start1 1 :end1 1)))
	(test-t (null (mismatch #(x y z) '() :start1 2 :end1 2)))
	(test-t (null (mismatch #(x y z) '() :start1 3 :end1 3)))
	(test-t (eql (mismatch #(x y z) '(a b c) :start1 0 :end1 0) 0))
	(test-t (eql (mismatch #(x y z) '(a b c) :start1 1 :end1 1) 1))
	(test-t (eql (mismatch #(x y z) '(a b c) :start1 2 :end1 2) 2))
	(test-t (eql (mismatch #(x y z) '(a b c) :start1 3 :end1 3) 3))
	(test-t (eql (mismatch #(x y z) '(x y z) :start1 0 :end1 1) 1))
	(test-t (eql (mismatch #(x y z) '(x y z) :start1 0 :end1 2) 2))
	(test-t (eql (mismatch #(x y z) '(x y z Z) :start1 0 :end1 3) 3))
	(test-t (null (mismatch #(x y z) '(x y z) :start1 0 :end1 3)))
	(test-t (eql (mismatch #(a b c x y z) '(x y z a b c)) 0))
	(test-t (eql (mismatch #(a b c x y z) '(x y z a b c) :start1 3) 6))
	(test-t (eql (mismatch #(a b c x y z a b c) '(x y z a b c x y z) :start1 3) 9))
	(test-t (eql (mismatch #(a b c x y z a b c) '(x y z a b c x y z) :start1 6) 6))
	(test-t (eql (mismatch #(a b c x y z a b c) '(x y z a b c x y z) :start1 6 :start2 3) 9))
	(test-t (eql (mismatch #(a b c x y z a b c) '(x y z a b c x y z) :start1 0 :start2 3) 6))
	(test-t (eql (mismatch #(a b c) '(a b c x y z)) 3))
	(test-t (eql (mismatch #(a b c) '(x a b c y z)) 0))
	(test-t (eql (mismatch #(a b c) '(x a b c y z) :start2 1) 3))
	(test-t (eql (mismatch #(a b c) '(x a b c y z) :start2 1 :end2 nil) 3))
	(test-t (null (mismatch #(a b c) '(x a b c y z) :start2 1 :end2 4)))
	(test-t (eql (mismatch #(a b c d e) '(c d)) 0))
	(test-t (eql (mismatch #(a b c d e) '(c d) :start1 2) 4))
	(test-t (eql (mismatch #(a b c d e) '(c d) :start1 2 :end1 3) 3))
	(test-t (eql (mismatch #(a b c d e) '(c d) :start1 2 :start2 1) 2))
	(test-t (eql (mismatch #(a b c d e) '(c d) :start1 3 :start2 1) 4))
	(test-t (eql (mismatch #(a b c d e) '(c d) :start1 2 :end2 1) 3))
	(test-t (null (mismatch #(a b c d) '(a b c d) :start1 1 :end1 2 :start2 1 :end2 2)))
	(test-t (null (mismatch #(a b c d) '(a b c d) :start1 1 :end1 3 :start2 1 :end2 3)))
	(test-t (null (mismatch #(a b c d) '(a b c d) :start1 1 :end1 4 :start2 1 :end2 4)))
	(test-t (eql (mismatch #(a b c d) '(a b c d) :start1 1 :end1 nil :start2 1 :end2 1) 1))
	(test-t (eql (mismatch #(a b c d) '(a b c d) :start1 1 :end1 nil :start2 1 :end2 2) 2))
	(test-t (eql (mismatch #(a b c d) '(a b c d) :start1 1 :end1 nil :start2 1 :end2 3) 3))
	(test-t (null (mismatch #(a b c d) '(a b c d) :start1 1 :end1 nil :start2 1 :end2 4)))
	(test-t (eql (mismatch #(a b c d) '(a b c d) :start1 1 :end1 1 :start2 1) 1))
	(test-t (eql (mismatch #(a b c d) '(a b c d) :start1 1 :end1 2 :start2 1) 2))
	(test-t (eql (mismatch #(a b c d) '(a b c d) :start1 1 :end1 3 :start2 1) 3))
	(test-t (null (mismatch #(a b c d) '(a b c d) :start1 1 :end1 4 :start2 1)))
	(test-t (null (mismatch #(a b c) '(a b c) :from-end t)))
	(test-t (eql (mismatch #(a b c d) '(a b c) :from-end t) 4))
	(test-t (eql (mismatch #(a b c) '(c) :from-end t) 2))
	(test-t (eql (mismatch #(a b c) '(z a b c) :from-end t) 0))
	(test-t (eql (mismatch #(a b c) '(x y z a b c) :from-end t) 0))
	(test-t (eql (mismatch #(x y z a b c) '(a b c) :from-end t) 3))
	(test-t (eql (mismatch #(x y z a b c) '(a b c) :end1 3 :from-end t) 3))
	(test-t (eql (mismatch #(x y z a b c) '(a b c) :end1 5 :from-end t) 5))
	(test-t (eql (mismatch #(x y z a b c x y z) '(a b c) :end1 6 :from-end t) 3))
	(test-t (eql (mismatch #(x y z a b c x y z) '(a b c) :start1 2 :end1 6 :from-end t) 3))
	(test-t (eql (mismatch #(x y z a b c x y z) '(a b c) :from-end t :start1 2 :end1 5 :start2 1 :end2 2 ) 4))
	(test-t (eql (mismatch #(x y z a b c x y z) '(a b c) :start1 2 :end1 5 :start2 1 :end2 2 ) 2))
	(test-t (eql (mismatch #((a) (b) (c)) '((a) (b) (c))) 0))
	(test-t (null (mismatch #((a) (b) (c)) '((a) (b) (c)) :key car)))
	(test-t (null (mismatch #((a) (b) (c)) '((a) (b) (c)) :test equal)))
	(test-t (eql (mismatch #(#(a) #(b) #(c)) '(#(a) #(b) #(c))) 0))
	(test-t (null (mismatch #(#(a) #(b) #(c)) '(#(a) #(b) #(c)) :test equalp)))
	(test-t (eql (mismatch #((a) (b) (c) (d)) '((a) (b) (c)) :key car) 3))
	(test-t (eql (mismatch #((a) (b) (c)) '((a) (b) (c) (d)) :key car) 3))
	(test-t (eql (mismatch #(#\a #\b #\c) '(#\A #\B #\C)) 0))
	(test-t (null (mismatch #(#\a #\b #\c) '(#\A #\B #\C) :key char-upcase)))
	(test-t (null (mismatch #(#\a #\b #\c) '(#\A #\B #\C) :key char-downcase)))
	(test-t (null (mismatch #(#\a #\b #\c) '(#\A #\B #\C) :key char-upcase :start1 1 :end1 2 :start2 1 :end2 2)))
	(test-t (null (mismatch #(#\a #\b #\c) '(#\A #\B #\C) :key char-upcase :start1 2 :start2 2)))
	(test-t (eql (mismatch #((a b c) (b c d) (d e f)) '((b b c) (c c d) (e e f))) 0))
	(test-t (eql (mismatch #((a b c) (b c d) (d e f)) '((b b c) (c c d) (e e f)) :key cdr) 0))
	(test-t (null (mismatch #((a b c) (b c d) (d e f)) '((b b c) (c c d) (e e f)) :key cdr :test equal)))
	(test-t (eql (mismatch #((a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal) 3))
	(test-t (eql (mismatch #((a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t) 4))
	(test-t (eql (mismatch #((a a a) (a b c) (b c d) (d e f)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t) 1))
	(test-t (null (mismatch #((a a a) (a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :start1 1 :end1 4)))
	(test-t (eql (mismatch #((a a a) (a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :start1 1) 5))
	(test-t (eql (mismatch #((a a a) (a b c) (b c d) (d e f) (e f g)) '((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :end1 3 :start2 1 :end2 2) 2))
	(test-t (null (mismatch '() #())))
	(test-t (eql (mismatch '(a b c) #(x y z)) 0))
	(test-t (eql (mismatch '() #(x y z)) 0))
	(test-t (eql (mismatch '(x y z) #()) 0))
	(test-t (null (mismatch '(a) #(a))))
	(test-t (eql (mismatch '(a b c x y z) #(a b c)) 3))
	(test-t (null (mismatch '(a b c) #(a b c))))
	(test-t (eql (mismatch '(a b c d e f) #(a b c)) 3))
	(test-t (eql (mismatch '(a b c) #(a b c d e f)) 3))
	(test-t (eql (mismatch '(a b c) #(a b x)) 2))
	(test-t (eql (mismatch '(a b c) #(a x c)) 1))
	(test-t (eql (mismatch '(a b c) #(x b c)) 0))
	(test-t (eql (mismatch '(x y z a b c x y z) #(a b c) :start1 3) 6))
	(test-t (eql (mismatch '(x y z a b c x y z) #(a b c) :start1 3 :end1 nil) 6))
	(test-t (eql (mismatch '(x y z a b c x y z) #(a b c) :start1 3 :end1 4) 4))
	(test-t (eql (mismatch '(x y z a b c x y z) #(a b c) :start1 3 :end1 3) 3))
	(test-t (null (mismatch '(x y z) #() :start1 0 :end1 0)))
	(test-t (null (mismatch '(x y z) #() :start1 1 :end1 1)))
	(test-t (null (mismatch '(x y z) #() :start1 2 :end1 2)))
	(test-t (null (mismatch '(x y z) #() :start1 3 :end1 3)))
	(test-t (eql (mismatch '(x y z) #(a b c) :start1 0 :end1 0) 0))
	(test-t (eql (mismatch '(x y z) #(a b c) :start1 1 :end1 1) 1))
	(test-t (eql (mismatch '(x y z) #(a b c) :start1 2 :end1 2) 2))
	(test-t (eql (mismatch '(x y z) #(a b c) :start1 3 :end1 3) 3))
	(test-t (eql (mismatch '(x y z) #(x y z) :start1 0 :end1 1) 1))
	(test-t (eql (mismatch '(x y z) #(x y z) :start1 0 :end1 2) 2))
	(test-t (eql (mismatch '(x y z) #(x y z Z) :start1 0 :end1 3) 3))
	(test-t (null (mismatch '(x y z) #(x y z) :start1 0 :end1 3)))
	(test-t (eql (mismatch '(a b c x y z) #(x y z a b c)) 0))
	(test-t (eql (mismatch '(a b c x y z) #(x y z a b c) :start1 3) 6))
	(test-t (eql (mismatch '(a b c x y z a b c) #(x y z a b c x y z) :start1 3) 9))
	(test-t (eql (mismatch '(a b c x y z a b c) #(x y z a b c x y z) :start1 6) 6))
	(test-t (eql (mismatch '(a b c x y z a b c) #(x y z a b c x y z) :start1 6 :start2 3) 9))
	(test-t (eql (mismatch '(a b c x y z a b c) #(x y z a b c x y z) :start1 0 :start2 3) 6))
	(test-t (eql (mismatch '(a b c) #(a b c x y z)) 3))
	(test-t (eql (mismatch '(a b c) #(x a b c y z)) 0))
	(test-t (eql (mismatch '(a b c) #(x a b c y z) :start2 1) 3))
	(test-t (eql (mismatch '(a b c) #(x a b c y z) :start2 1 :end2 nil) 3))
	(test-t (null (mismatch '(a b c) #(x a b c y z) :start2 1 :end2 4)))
	(test-t (eql (mismatch '(a b c d e) #(c d)) 0))
	(test-t (eql (mismatch '(a b c d e) #(c d) :start1 2) 4))
	(test-t (eql (mismatch '(a b c d e) #(c d) :start1 2 :end1 3) 3))
	(test-t (eql (mismatch '(a b c d e) #(c d) :start1 2 :start2 1) 2))
	(test-t (eql (mismatch '(a b c d e) #(c d) :start1 3 :start2 1) 4))
	(test-t (eql (mismatch '(a b c d e) #(c d) :start1 2 :end2 1) 3))
	(test-t (null (mismatch '(a b c d) #(a b c d) :start1 1 :end1 2 :start2 1 :end2 2)))
	(test-t (null (mismatch '(a b c d) #(a b c d) :start1 1 :end1 3 :start2 1 :end2 3)))
	(test-t (null (mismatch '(a b c d) #(a b c d) :start1 1 :end1 4 :start2 1 :end2 4)))
	(test-t (eql (mismatch '(a b c d) #(a b c d) :start1 1 :end1 nil :start2 1 :end2 1) 1))
	(test-t (eql (mismatch '(a b c d) #(a b c d) :start1 1 :end1 nil :start2 1 :end2 2) 2))
	(test-t (eql (mismatch '(a b c d) #(a b c d) :start1 1 :end1 nil :start2 1 :end2 3) 3))
	(test-t (null (mismatch '(a b c d) #(a b c d) :start1 1 :end1 nil :start2 1 :end2 4)))
	(test-t (eql (mismatch '(a b c d) #(a b c d) :start1 1 :end1 1 :start2 1) 1))
	(test-t (eql (mismatch '(a b c d) #(a b c d) :start1 1 :end1 2 :start2 1) 2))
	(test-t (eql (mismatch '(a b c d) #(a b c d) :start1 1 :end1 3 :start2 1) 3))
	(test-t (null (mismatch '(a b c d) #(a b c d) :start1 1 :end1 4 :start2 1)))
	(test-t (null (mismatch '(a b c) #(a b c) :from-end t)))
	(test-t (eql (mismatch '(a b c d) #(a b c) :from-end t) 4))
	(test-t (eql (mismatch '(a b c) #(c) :from-end t) 2))
	(test-t (eql (mismatch '(a b c) #(z a b c) :from-end t) 0))
	(test-t (eql (mismatch '(a b c) #(x y z a b c) :from-end t) 0))
	(test-t (eql (mismatch '(x y z a b c) #(a b c) :from-end t) 3))
	(test-t (eql (mismatch '(x y z a b c) #(a b c) :end1 3 :from-end t) 3))
	(test-t (eql (mismatch '(x y z a b c) #(a b c) :end1 5 :from-end t) 5))
	(test-t (eql (mismatch '(x y z a b c x y z) #(a b c) :end1 6 :from-end t) 3))
	(test-t (eql (mismatch '(x y z a b c x y z) #(a b c) :start1 2 :end1 6 :from-end t) 3))
	(test-t (eql (mismatch '(x y z a b c x y z) #(a b c) :from-end t :start1 2 :end1 5 :start2 1 :end2 2 ) 4))
	(test-t (eql (mismatch '(x y z a b c x y z) #(a b c) :start1 2 :end1 5 :start2 1 :end2 2 ) 2))
	(test-t (eql (mismatch '((a) (b) (c)) #((a) (b) (c))) 0))
	(test-t (null (mismatch '((a) (b) (c)) #((a) (b) (c)) :key car)))
	(test-t (null (mismatch '((a) (b) (c)) #((a) (b) (c)) :test equal)))
	(test-t (eql (mismatch '(#(a) #(b) #(c)) #(#(a) #(b) #(c))) 0))
	(test-t (null (mismatch '(#(a) #(b) #(c)) #(#(a) #(b) #(c)) :test equalp)))
	(test-t (eql (mismatch '((a) (b) (c) (d)) #((a) (b) (c)) :key car) 3))
	(test-t (eql (mismatch '((a) (b) (c)) #((a) (b) (c) (d)) :key car) 3))
	(test-t (eql (mismatch '(#\a #\b #\c) #(#\A #\B #\C)) 0))
	(test-t (null (mismatch '(#\a #\b #\c) #(#\A #\B #\C) :key char-upcase)))
	(test-t (null (mismatch '(#\a #\b #\c) #(#\A #\B #\C) :key char-downcase)))
	(test-t (null (mismatch '(#\a #\b #\c) #(#\A #\B #\C) :key char-upcase :start1 1 :end1 2 :start2 1 :end2 2)))
	(test-t (null (mismatch '(#\a #\b #\c) #(#\A #\B #\C) :key char-upcase :start1 2 :start2 2)))
	(test-t (eql (mismatch '((a b c) (b c d) (d e f)) #((b b c) (c c d) (e e f))) 0))
	(test-t (eql (mismatch '((a b c) (b c d) (d e f)) #((b b c) (c c d) (e e f)) :key cdr) 0))
	(test-t (null (mismatch '((a b c) (b c d) (d e f)) #((b b c) (c c d) (e e f)) :key cdr :test equal)))
	(test-t (eql (mismatch '((a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal) 3))
	(test-t (eql (mismatch '((a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t) 4))
	(test-t (eql (mismatch '((a a a) (a b c) (b c d) (d e f)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t) 1))
	(test-t (null (mismatch '((a a a) (a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :start1 1 :end1 4)))
	(test-t (eql (mismatch '((a a a) (a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :start1 1) 5))
	(test-t (eql (mismatch '((a a a) (a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :end1 3 :start2 1 :end2 2) 2))
	(test-t (null (mismatch #() #())))
	(test-t (eql (mismatch #(a b c) #(x y z)) 0))
	(test-t (eql (mismatch #() #(x y z)) 0))
	(test-t (eql (mismatch #(x y z) #()) 0))
	(test-t (null (mismatch #(a) #(a))))
	(test-t (eql (mismatch #(a b c x y z) #(a b c)) 3))
	(test-t (null (mismatch #(a b c) #(a b c))))
	(test-t (eql (mismatch #(a b c d e f) #(a b c)) 3))
	(test-t (eql (mismatch #(a b c) #(a b c d e f)) 3))
	(test-t (eql (mismatch #(a b c) #(a b x)) 2))
	(test-t (eql (mismatch #(a b c) #(a x c)) 1))
	(test-t (eql (mismatch #(a b c) #(x b c)) 0))
	(test-t (eql (mismatch #(x y z a b c x y z) #(a b c) :start1 3) 6))
	(test-t (eql (mismatch #(x y z a b c x y z) #(a b c) :start1 3 :end1 nil) 6))
	(test-t (eql (mismatch #(x y z a b c x y z) #(a b c) :start1 3 :end1 4) 4))
	(test-t (eql (mismatch #(x y z a b c x y z) #(a b c) :start1 3 :end1 3) 3))
	(test-t (null (mismatch #(x y z) #() :start1 0 :end1 0)))
	(test-t (null (mismatch #(x y z) #() :start1 1 :end1 1)))
	(test-t (null (mismatch #(x y z) #() :start1 2 :end1 2)))
	(test-t (null (mismatch #(x y z) #() :start1 3 :end1 3)))
	(test-t (eql (mismatch #(x y z) #(a b c) :start1 0 :end1 0) 0))
	(test-t (eql (mismatch #(x y z) #(a b c) :start1 1 :end1 1) 1))
	(test-t (eql (mismatch #(x y z) #(a b c) :start1 2 :end1 2) 2))
	(test-t (eql (mismatch #(x y z) #(a b c) :start1 3 :end1 3) 3))
	(test-t (eql (mismatch #(x y z) #(x y z) :start1 0 :end1 1) 1))
	(test-t (eql (mismatch #(x y z) #(x y z) :start1 0 :end1 2) 2))
	(test-t (eql (mismatch #(x y z) #(x y z Z) :start1 0 :end1 3) 3))
	(test-t (null (mismatch #(x y z) #(x y z) :start1 0 :end1 3)))
	(test-t (eql (mismatch #(a b c x y z) #(x y z a b c)) 0))
	(test-t (eql (mismatch #(a b c x y z) #(x y z a b c) :start1 3) 6))
	(test-t (eql (mismatch #(a b c x y z a b c) #(x y z a b c x y z) :start1 3) 9))
	(test-t (eql (mismatch #(a b c x y z a b c) #(x y z a b c x y z) :start1 6) 6))
	(test-t (eql (mismatch #(a b c x y z a b c) #(x y z a b c x y z) :start1 6 :start2 3) 9))
	(test-t (eql (mismatch #(a b c x y z a b c) #(x y z a b c x y z) :start1 0 :start2 3) 6))
	(test-t (eql (mismatch #(a b c) #(a b c x y z)) 3))
	(test-t (eql (mismatch #(a b c) #(x a b c y z)) 0))
	(test-t (eql (mismatch #(a b c) #(x a b c y z) :start2 1) 3))
	(test-t (eql (mismatch #(a b c) #(x a b c y z) :start2 1 :end2 nil) 3))
	(test-t (null (mismatch #(a b c) #(x a b c y z) :start2 1 :end2 4)))
	(test-t (eql (mismatch #(a b c d e) #(c d)) 0))
	(test-t (eql (mismatch #(a b c d e) #(c d) :start1 2) 4))
	(test-t (eql (mismatch #(a b c d e) #(c d) :start1 2 :end1 3) 3))
	(test-t (eql (mismatch #(a b c d e) #(c d) :start1 2 :start2 1) 2))
	(test-t (eql (mismatch #(a b c d e) #(c d) :start1 3 :start2 1) 4))
	(test-t (eql (mismatch #(a b c d e) #(c d) :start1 2 :end2 1) 3))
	(test-t (null (mismatch #(a b c d) #(a b c d) :start1 1 :end1 2 :start2 1 :end2 2)))
	(test-t (null (mismatch #(a b c d) #(a b c d) :start1 1 :end1 3 :start2 1 :end2 3)))
	(test-t (null (mismatch #(a b c d) #(a b c d) :start1 1 :end1 4 :start2 1 :end2 4)))
	(test-t (eql (mismatch #(a b c d) #(a b c d) :start1 1 :end1 nil :start2 1 :end2 1) 1))
	(test-t (eql (mismatch #(a b c d) #(a b c d) :start1 1 :end1 nil :start2 1 :end2 2) 2))
	(test-t (eql (mismatch #(a b c d) #(a b c d) :start1 1 :end1 nil :start2 1 :end2 3) 3))
	(test-t (null (mismatch #(a b c d) #(a b c d) :start1 1 :end1 nil :start2 1 :end2 4)))
	(test-t (eql (mismatch #(a b c d) #(a b c d) :start1 1 :end1 1 :start2 1) 1))
	(test-t (eql (mismatch #(a b c d) #(a b c d) :start1 1 :end1 2 :start2 1) 2))
	(test-t (eql (mismatch #(a b c d) #(a b c d) :start1 1 :end1 3 :start2 1) 3))
	(test-t (null (mismatch #(a b c d) #(a b c d) :start1 1 :end1 4 :start2 1)))
	(test-t (null (mismatch #(a b c) #(a b c) :from-end t)))
	(test-t (eql (mismatch #(a b c d) #(a b c) :from-end t) 4))
	(test-t (eql (mismatch #(a b c) #(c) :from-end t) 2))
	(test-t (eql (mismatch #(a b c) #(z a b c) :from-end t) 0))
	(test-t (eql (mismatch #(a b c) #(x y z a b c) :from-end t) 0))
	(test-t (eql (mismatch #(x y z a b c) #(a b c) :from-end t) 3))
	(test-t (eql (mismatch #(x y z a b c) #(a b c) :end1 3 :from-end t) 3))
	(test-t (eql (mismatch #(x y z a b c) #(a b c) :end1 5 :from-end t) 5))
	(test-t (eql (mismatch #(x y z a b c x y z) #(a b c) :end1 6 :from-end t) 3))
	(test-t (eql (mismatch #(x y z a b c x y z) #(a b c) :start1 2 :end1 6 :from-end t) 3))
	(test-t (eql (mismatch #(x y z a b c x y z) #(a b c) :from-end t :start1 2 :end1 5 :start2 1 :end2 2 ) 4))
	(test-t (eql (mismatch #(x y z a b c x y z) #(a b c) :start1 2 :end1 5 :start2 1 :end2 2 ) 2))
	(test-t (eql (mismatch #((a) (b) (c)) #((a) (b) (c))) 0))
	(test-t (null (mismatch #((a) (b) (c)) #((a) (b) (c)) :key car)))
	(test-t (null (mismatch #((a) (b) (c)) #((a) (b) (c)) :test equal)))
	(test-t (eql (mismatch #(#(a) #(b) #(c)) #(#(a) #(b) #(c))) 0))
	(test-t (null (mismatch #(#(a) #(b) #(c)) #(#(a) #(b) #(c)) :test equalp)))
	(test-t (eql (mismatch #((a) (b) (c) (d)) #((a) (b) (c)) :key car) 3))
	(test-t (eql (mismatch #((a) (b) (c)) #((a) (b) (c) (d)) :key car) 3))
	(test-t (eql (mismatch #(#\a #\b #\c) #(#\A #\B #\C)) 0))
	(test-t (null (mismatch #(#\a #\b #\c) #(#\A #\B #\C) :key char-upcase)))
	(test-t (null (mismatch #(#\a #\b #\c) #(#\A #\B #\C) :key char-downcase)))
	(test-t (null (mismatch #(#\a #\b #\c) #(#\A #\B #\C) :key char-upcase :start1 1 :end1 2 :start2 1 :end2 2)))
	(test-t (null (mismatch #(#\a #\b #\c) #(#\A #\B #\C) :key char-upcase :start1 2 :start2 2)))
	(test-t (eql (mismatch #((a b c) (b c d) (d e f)) #((b b c) (c c d) (e e f))) 0))
	(test-t (eql (mismatch #((a b c) (b c d) (d e f)) #((b b c) (c c d) (e e f)) :key cdr) 0))
	(test-t (null (mismatch #((a b c) (b c d) (d e f)) #((b b c) (c c d) (e e f)) :key cdr :test equal)))
	(test-t (eql (mismatch #((a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal) 3))
	(test-t (eql (mismatch #((a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t) 4))
	(test-t (eql (mismatch #((a a a) (a b c) (b c d) (d e f)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t) 1))
	(test-t (null (mismatch #((a a a) (a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :start1 1 :end1 4)))
	(test-t (eql (mismatch #((a a a) (a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :start1 1) 5))
	(test-t (eql (mismatch #((a a a) (a b c) (b c d) (d e f) (e f g)) #((b b c) (c c d) (e e f)) :key cdr :test equal :from-end t :end1 3 :start2 1 :end2 2) 2))
	(test-t (eql (mismatch "abc" "xyz") 0))
	(test-t (null (mismatch "" "")))
	(test-t (null (mismatch "a" "a")))
	(test-t (null (mismatch "abc" "abc")))
	(test-t (null (mismatch "abc" "ABC" :key char-downcase)))
	(test-t (null (mismatch "abc" "ABC" :test char-equal)))
	(test-t (eql (mismatch "abcde" "abc") 3))
	(test-t (eql (mismatch "abc" "abcde") 3))
	(test-t (eql (mismatch "abc" "abxyz") 2))
	(test-t (eql (mismatch "abcde" "abx") 2))
	(test-t (null (mismatch "abc" "abc" :from-end t)))
	(test-t (eql (mismatch "abcxyz" "xyzxyz" :from-end t) 3))
	(test-t (eql (mismatch "abcxyz" "xyz" :from-end t) 3))
	(test-t (eql (mismatch "xyz" "abcxyz" :from-end t) 0))
	(test-t (eql (mismatch "ayz" "abcxyz" :from-end t) 1))
	(test-t (null (mismatch "abc" "xyz" :test char<)))
	(test-t (eql (mismatch "abc" "xyz" :test char>) 0))
	(test-t (eql (mismatch "abcxyz" "abcdefg") 3))
	(test-t (eql (mismatch "1xyz" "22xyz" :from-end t) 1))
	
	(test-t (let ((lst (copy-seq "012345678"))) (and (equal (replace lst lst :start1 2 :start2 0) "010123456") (equal lst "010123456"))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z)))) (and (eq list0 list) (equal list0 '(x y z d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 1))) (and (eq list0 list) (equal list0 '(a x y z e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 1 :end1 nil))) (and (eq list0 list) (equal list0 '(a x y z e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 1 :start2 1))) (and (eq list0 list) (equal list0 '(a y z d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 1 :start2 1 :end2 nil))) (and (eq list0 list) (equal list0 '(a y z d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 1 :end1 nil :start2 1 :end2 nil))) (and (eq list0 list) (equal list0 '(a y z d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 1 :end1 2 :start2 1))) (and (eq list0 list) (equal list0 '(a y c d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 1 :end1 1))) (and (eq list0 list) (equal list0 '(a b c d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 2 :end1 2))) (and (eq list0 list) (equal list0 '(a b c d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 3 :end1 3))) (and (eq list0 list) (equal list0 '(a b c d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 4 :end1 4))) (and (eq list0 list) (equal list0 '(a b c d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 '(x y z) :start1 5 :end1 5))) (and (eq list0 list) (equal list0 '(a b c d e)))))
	(test-t (null (replace nil nil)))
	(test-t (null (replace nil '(a b c))))
	(test-t (let* ((list0 (list 'a 'b 'c)) (list (replace list0 '()))) (and (eq list0 list) (equal list0 '(a b c)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 list0))) (and (eq list0 list) (equal list0 '(a b c d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 list0 :start1 3))) (and (eq list0 list) (equal list0 '(a b c a b)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 list0 :start1 1))) (and (eq list0 list) (equal list0 '(a a b c d)))))
	(test-t (let* ((list0 (list 'a 'b 'c 'd 'e)) (list (replace list0 list0 :start1 1 :end1 3))) (and (eq list0 list) (equal list0 '(a a b d e)))))
	(test-t (let* ((list0 (list 'a 'b 'c)) (list (replace list0 '(x y z)))) (and (eq list0 list) (equal list0 '(x y z)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z)))) (and (eq vector0 vector) (equalp vector0 #(x y z d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 1))) (and (eq vector0 vector) (equalp vector0 #(a x y z e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 1 :end1 nil))) (and (eq vector0 vector) (equalp vector0 #(a x y z e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 1 :start2 1))) (and (eq vector0 vector) (equalp vector0 #(a y z d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 1 :start2 1 :end2 nil))) (and (eq vector0 vector) (equalp vector0 #(a y z d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 1 :end1 nil :start2 1 :end2 nil))) (and (eq vector0 vector) (equalp vector0 #(a y z d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 1 :end1 2 :start2 1))) (and (eq vector0 vector) (equalp vector0 #(a y c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 1 :end1 1))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 2 :end1 2))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 3 :end1 3))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 4 :end1 4))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 '(x y z) :start1 5 :end1 5))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (null (replace nil #())))
	(test-t (null (replace nil #(a b c))))
	(test-t (let* ((vector0 (vector 'a 'b 'c)) (vector (replace vector0 '()))) (and (eq vector0 vector) (equalp vector0 #(a b c)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 vector0))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 vector0 :start1 3))) (and (eq vector0 vector) (equalp vector0 #(a b c a b)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 vector0 :start1 1))) (and (eq vector0 vector) (equalp vector0 #(a a b c d)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 vector0 :start1 1 :end1 3))) (and (eq vector0 vector) (equalp vector0 #(a a b d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c)) (vector (replace vector0 '(x y z)))) (and (eq vector0 vector) (equalp vector0 #(x y z)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z)))) (and (eq vector0 vector) (equalp vector0 #(x y z d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 1))) (and (eq vector0 vector) (equalp vector0 #(a x y z e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 1 :end1 nil))) (and (eq vector0 vector) (equalp vector0 #(a x y z e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 1 :start2 1))) (and (eq vector0 vector) (equalp vector0 #(a y z d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 1 :start2 1 :end2 nil))) (and (eq vector0 vector) (equalp vector0 #(a y z d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 1 :end1 nil :start2 1 :end2 nil))) (and (eq vector0 vector) (equalp vector0 #(a y z d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 1 :end1 2 :start2 1))) (and (eq vector0 vector) (equalp vector0 #(a y c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 1 :end1 1))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 2 :end1 2))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 3 :end1 3))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 4 :end1 4))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 #(x y z) :start1 5 :end1 5))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (null (replace nil #())))
	(test-t (null (replace nil #(a b c))))
	(test-t (let* ((vector0 (vector 'a 'b 'c)) (vector (replace vector0 #()))) (and (eq vector0 vector) (equalp vector0 #(a b c)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 vector0))) (and (eq vector0 vector) (equalp vector0 #(a b c d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 vector0 :start1 3))) (and (eq vector0 vector) (equalp vector0 #(a b c a b)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 vector0 :start1 1))) (and (eq vector0 vector) (equalp vector0 #(a a b c d)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c 'd 'e)) (vector (replace vector0 vector0 :start1 1 :end1 3))) (and (eq vector0 vector) (equalp vector0 #(a a b d e)))))
	(test-t (let* ((vector0 (vector 'a 'b 'c)) (vector (replace vector0 #(x y z)))) (and (eq vector0 vector) (equalp vector0 #(x y z)))))
	(test-t (let* ((str0 (copy-seq "abc")) (str (replace str0 "xyz"))) (and (eq str0 str) (equalp str0 "xyz"))))
	(test-t (let* ((str0 (copy-seq "")) (str (replace str0 ""))) (and (eq str0 str) (equalp str0 ""))))
	(test-t (let* ((str0 (copy-seq "")) (str (replace str0 "xyz"))) (and (eq str0 str) (equalp str0 ""))))
	(test-t (let* ((str0 (copy-seq "abc")) (str (replace str0 ""))) (and (eq str0 str) (equalp str0 "abc"))))
	(test-t (let* ((str0 (copy-seq "abcdef")) (str (replace str0 "xyz" :start1 3))) (and (eq str0 str) (equalp str0 "abcxyz"))))
	(test-t (let* ((str0 (copy-seq "abcdef")) (str (replace str0 "xyz" :start1 4 :start2 1))) (and (eq str0 str) (equalp str0 "abcdyz"))))
	(test-t (let* ((str0 (copy-seq "abcdef")) (str (replace str0 "xyz" :start1 1 :end1 2 :start2 1))) (and (eq str0 str) (equalp str0 "aycdef"))))
	(test-t (let* ((str0 (copy-seq "abcdef")) (str (replace str0 "xyz" :start1 1 :start2 1 :end2 2))) (and (eq str0 str) (equalp str0 "aycdef"))))
	(test-t (let* ((str0 (copy-seq "abcdef")) (str (replace str0 str0 :start1 1))) (and (eq str0 str) (equalp str0 "aabcde"))))
	(test-t (equal (substitute #\. #\space "0 2 4 6") "0.2.4.6"))
	(test-t (equal (substitute 9 4 '(1 2 4 1 3 4 5)) '(1 2 9 1 3 9 5)))
	(test-t (equal (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) '(1 2 9 1 3 4 5)))
	(test-t (equal (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) '(1 2 4 1 3 9 5)))
	(test-t (equal (substitute 9 3 '(1 2 4 1 3 4 5) :test >) '(9 9 4 9 3 4 5)))
	(test-t (equal (substitute-if 0 evenp '((1) (2) (3) (4)) :start 2 :key car) '((1) (2) (3) 0)))
	(test-t (equal (substitute-if 9 oddp '(1 2 4 1 3 4 5)) '(9 2 4 9 9 4 9)))
	(test-t (equal (substitute-if 9 evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) '(1 2 4 1 3 9 5)))
	(test-t (let ((some-things (list 'a 'car 'b 'cdr 'c)))
		  (and (equal (nsubstitute-if "function was here" fboundp some-things
					      :count 1 :from-end t)
			      '(a car b "function was here" c))
		       (equal some-things '(a car b "function was here" c)))))
	(test-t (let ((alpha-tester (copy-seq "ab "))) (and (equal (nsubstitute-if-not #\z alpha-char-p alpha-tester) "abz") (equal alpha-tester "abz"))))
	(test-t (equal (substitute 'a 'x '(x y z)) '(a y z)))
	(test-t (equal (substitute 'b 'y '(x y z)) '(x b z)))
	(test-t (equal (substitute 'c 'z '(x y z)) '(x y c)))
	(test-t (equal (substitute 'a 'p '(x y z)) '(x y z)))
	(test-t (equal (substitute 'a 'x '()) '()))
	(test-t (equal (substitute #\x #\b '(#\a #\b #\c #\d #\e) :test char<) '(#\a #\b #\x #\x #\x)))
	(test-t (equal (substitute '(a) 'x '((x) (y) (z)) :key car) '((a) (y) (z))))
	(test-t (equal (substitute 'c 'b '(a b a b a b a b)) '(a c a c a c a c)))
	(test-t (equal (substitute 'a 'b '(b b b)) '(a a a)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f)) '(a z b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count nil) '(a z b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 0) '(a x b x c x d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count -100) '(a x b x c x d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 1) '(a z b x c x d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 2) '(a z b z c x d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 3) '(a z b z c z d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 4) '(a z b z c z d z e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 5) '(a z b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 6) '(a z b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 7) '(a z b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count nil :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 0 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count -100 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 1 :from-end t) '(a x b x c x d x e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 2 :from-end t) '(a x b x c x d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 3 :from-end t) '(a x b x c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 4 :from-end t) '(a x b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 5 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 6 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :count 7 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :start 2 :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :start 2 :end nil :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :start 2 :end 6 :count 100) '(a x b z c z d x e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :start 2 :end 11 :count 100) '(a x b z c z d z e z f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :start 2 :end 8 :count 10) '(a x b z c z d z e x f)))
	(test-t (equal (substitute 'z 'x '(a x b x c x d x e x f) :start 2 :end 8 :count 2 :from-end t) '(a x b x c z d z e x f)))
	(test-t (equal (substitute #\z #\c '(#\a #\b #\c #\d #\e #\f) :test char<) '(#\a #\b #\c #\z #\z #\z)))
	(test-t (equal (substitute "peace" "war" '("war" "War" "WAr" "WAR") :test string-equal) '("peace" "peace" "peace" "peace")))
	(test-t (equal (substitute "peace" "WAR" '("war" "War" "WAr" "WAR") :test string=) '("war" "War" "WAr" "peace")))
	(test-t (equal (substitute "peace" "WAR" '("war" "War" "WAr" "WAR") :test string= :key string-upcase) '("peace" "peace" "peace" "peace")))
	(test-t (equal (substitute "peace" "WAR" '("war" "War" "WAr" "WAR") :start 1 :end 2 :test string= :key string-upcase) '("war" "peace" "WAr" "WAR")))
	(test-t (equal (substitute "peace" "WAR" '("war" "War" "WAr" "WAR") :start 1 :end nil :test string= :key string-upcase) '("war" "peace" "peace" "peace")))
	(test-t (equal (substitute "peace" "war" '("war" "War" "WAr" "WAR") :test string= :key string-upcase) '("war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute 'a 'x #(x y z)) #(a y z)))
	(test-t (equalp (substitute 'b 'y #(x y z)) #(x b z)))
	(test-t (equalp (substitute 'c 'z #(x y z)) #(x y c)))
	(test-t (equalp (substitute 'a 'p #(x y z)) #(x y z)))
	(test-t (equalp (substitute 'a 'x #()) #()))
	(test-t (equalp (substitute #\x #\b #(#\a #\b #\c #\d #\e) :test char<) #(#\a #\b #\x #\x #\x)))
	(test-t (equalp (substitute '(a) 'x #((x) (y) (z)) :key car) #((a) (y) (z))))
	(test-t (equalp (substitute 'c 'b #(a b a b a b a b)) #(a c a c a c a c)))
	(test-t (equalp (substitute 'a 'b #(b b b)) #(a a a)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f)) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count nil) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 0) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count -100) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 1) #(a z b x c x d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 2) #(a z b z c x d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 3) #(a z b z c z d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 4) #(a z b z c z d z e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 5) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 6) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 7) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count nil :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 0 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count -100 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 1 :from-end t) #(a x b x c x d x e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 2 :from-end t) #(a x b x c x d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 3 :from-end t) #(a x b x c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 4 :from-end t) #(a x b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 5 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 6 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :count 7 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :start 2 :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :start 2 :end nil :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :start 2 :end 6 :count 100) #(a x b z c z d x e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :start 2 :end 11 :count 100) #(a x b z c z d z e z f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :start 2 :end 8 :count 10) #(a x b z c z d z e x f)))
	(test-t (equalp (substitute 'z 'x #(a x b x c x d x e x f) :start 2 :end 8 :count 2 :from-end t) #(a x b x c z d z e x f)))
	(test-t (equalp (substitute #\z #\c #(#\a #\b #\c #\d #\e #\f) :test char<) #(#\a #\b #\c #\z #\z #\z)))
	(test-t (equalp (substitute "peace" "war" #("love" "hate" "war" "peace") :test equal) #("love" "hate" "peace" "peace")))
	(test-t (equalp (substitute "peace" "war" #("war" "War" "WAr" "WAR") :test string-equal) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (substitute "peace" "WAR" #("war" "War" "WAr" "WAR") :test string=) #("war" "War" "WAr" "peace")))
	(test-t (equalp (substitute "peace" "WAR" #("war" "War" "WAr" "WAR") :test string= :key string-upcase) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (substitute "peace" "WAR" #("war" "War" "WAr" "WAR") :start 1 :end 2 :test string= :key string-upcase) #("war" "peace" "WAr" "WAR")))
	(test-t (equalp (substitute "peace" "WAR" #("war" "War" "WAr" "WAR") :start 1 :end nil :test string= :key string-upcase) #("war" "peace" "peace" "peace")))
	(test-t (equalp (substitute "peace" "war" #("war" "War" "WAr" "WAR") :test string= :key string-upcase) #("war" "War" "WAr" "WAR")))
	(test-t (string= (substitute #\A #\a "abcabc") "AbcAbc"))
	(test-t (string= (substitute #\A #\a "") ""))
	(test-t (string= (substitute #\A #\a "xyz") "xyz"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :start 5 :end nil) "aaaaaAAAAA"))
	(test-t (string= (substitute #\x #\5 "0123456789" :test char<) "012345xxxx"))
	(test-t (string= (substitute #\x #\5 "0123456789" :test char>) "xxxxx56789"))
	(test-t (string= (substitute #\x #\D "abcdefg" :key char-upcase :test char>) "xxxdefg"))
	(test-t (string= (substitute #\x #\D "abcdefg" :start 1 :end 2 :key char-upcase :test char>) "axcdefg"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :count 2) "AAaaaaaaaa"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :count -1) "aaaaaaaaaa"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :count 0) "aaaaaaaaaa"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :count nil) "AAAAAAAAAA"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :count 100) "AAAAAAAAAA"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :count 9) "AAAAAAAAAa"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :count 9 :from-end t) "aAAAAAAAAA"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :start 2 :end 8 :count 3) "aaAAAaaaaa"))
	(test-t (string= (substitute #\A #\a "aaaaaaaaaa" :start 2 :end 8 :from-end t :count 3) "aaaaaAAAaa"))
	(test-t (string= (substitute #\x #\A "aaaaaaaaaa" :start 2 :end 8 :from-end t :count 3) "aaaaaaaaaa"))
	(test-t (string= (substitute #\X #\A "aaaaaaaaaa" :start 2 :end 8 :from-end t :key char-upcase :count 3) "aaaaaXXXaa"))
	(test-t (string= (substitute #\X #\D "abcdefghij" :start 2 :end 8 :from-end t :key char-upcase :test char< :count 3) "abcdeXXXij"))
	(test-t (equal (substitute-if 'a (lambda (arg) (eq arg 'x)) '(x y z)) '(a y z)))
	(test-t (equal (substitute-if 'b (lambda (arg) (eq arg 'y)) '(x y z)) '(x b z)))
	(test-t (equal (substitute-if 'c (lambda (arg) (eq arg 'z)) '(x y z)) '(x y c)))
	(test-t (equal (substitute-if 'a (lambda (arg) (eq arg 'p)) '(x y z)) '(x y z)))
	(test-t (equal (substitute-if 'a (lambda (arg) (eq arg 'x)) '()) '()))
	(test-t (equal (substitute-if #\x (lambda (arg) (char< #\b arg)) '(#\a #\b #\c #\d #\e)) '(#\a #\b #\x #\x #\x)))
	(test-t (equal (substitute-if '(a) (lambda (arg) (eq arg 'x)) '((x) (y) (z)) :key car) '((a) (y) (z))))
	(test-t (equal (substitute-if 'c (lambda (arg) (eq arg 'b)) '(a b a b a b a b)) '(a c a c a c a c)))
	(test-t (equal (substitute-if 'a (lambda (arg) (eq arg 'b)) '(b b b)) '(a a a)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f)) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count nil) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 0) '(a x b x c x d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count -100) '(a x b x c x d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 1) '(a z b x c x d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 2) '(a z b z c x d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 3) '(a z b z c z d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 4) '(a z b z c z d z e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 5) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 6) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 7) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count nil :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 0 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count -100 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 1 :from-end t) '(a x b x c x d x e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 2 :from-end t) '(a x b x c x d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 3 :from-end t) '(a x b x c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 4 :from-end t) '(a x b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 5 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 6 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :count 7 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :start 2 :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :start 2 :end nil :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :start 2 :end 6 :count 100) '(a x b z c z d x e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :start 2 :end 11 :count 100) '(a x b z c z d z e z f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :start 2 :end 8 :count 10) '(a x b z c z d z e x f)))
	(test-t (equal (substitute-if 'z (lambda (arg) (eq arg 'x)) '(a x b x c x d x e x f) :start 2 :end 8 :count 2 :from-end t) '(a x b x c z d z e x f)))
	(test-t (equal (substitute-if #\z (lambda (arg) (char< #\c arg)) '(#\a #\b #\c #\d #\e #\f)) '(#\a #\b #\c #\z #\z #\z)))
	(test-t (equal (substitute-if "peace" (lambda (arg) (equal "war" arg)) '("love" "hate" "war" "peace")) '("love" "hate" "peace" "peace")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string-equal "war" arg)) '("war" "War" "WAr" "WAR")) '("peace" "peace" "peace" "peace")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR") :key string-upcase) '("peace" "peace" "peace" "peace")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR") :start 1 :end 2 :key string-upcase) '("war" "peace" "WAr" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR") :start 1 :end nil :key string-upcase) '("war" "peace" "peace" "peace")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "war" arg)) '("war" "War" "WAr" "WAR") :key string-upcase) '("war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 1 :key string-upcase) '("war" "peace" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 2 :key string-upcase) '("war" "peace" "peace" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 2 :from-end t :key string-upcase) '("war" "War" "WAr" "WAR" "war" "peace" "peace" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 0 :from-end t :key string-upcase) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count -2 :from-end t :key string-upcase) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count nil :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 6 :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 7 :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equal (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 100 :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	
	(test-t (equalp (substitute-if 'a (lambda (arg) (eq arg 'x)) #(x y z)) #(a y z)))
	(test-t (equalp (substitute-if 'b (lambda (arg) (eq arg 'y)) #(x y z)) #(x b z)))
	(test-t (equalp (substitute-if 'c (lambda (arg) (eq arg 'z)) #(x y z)) #(x y c)))
	(test-t (equalp (substitute-if 'a (lambda (arg) (eq arg 'p)) #(x y z)) #(x y z)))
	(test-t (equalp (substitute-if 'a (lambda (arg) (eq arg 'x)) #()) #()))
	(test-t (equalp (substitute-if #\x (lambda (arg) (char< #\b arg)) #(#\a #\b #\c #\d #\e)) #(#\a #\b #\x #\x #\x)))
	(test-t (equalp (substitute-if '(a) (lambda (arg) (eq arg 'x)) #((x) (y) (z)) :key car) #((a) (y) (z))))
	(test-t (equalp (substitute-if 'c (lambda (arg) (eq arg 'b)) #(a b a b a b a b)) #(a c a c a c a c)))
	(test-t (equalp (substitute-if 'a (lambda (arg) (eq arg 'b)) #(b b b)) #(a a a)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f)) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count nil) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 0) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count -100) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 1) #(a z b x c x d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 2) #(a z b z c x d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 3) #(a z b z c z d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 4) #(a z b z c z d z e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 5) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 6) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 7) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count nil :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 0 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count -100 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 1 :from-end t) #(a x b x c x d x e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 2 :from-end t) #(a x b x c x d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 3 :from-end t) #(a x b x c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 4 :from-end t) #(a x b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 5 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 6 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :count 7 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :start 2 :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :start 2 :end nil :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :start 2 :end 6 :count 100) #(a x b z c z d x e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :start 2 :end 11 :count 100) #(a x b z c z d z e z f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :start 2 :end 8 :count 10) #(a x b z c z d z e x f)))
	(test-t (equalp (substitute-if 'z (lambda (arg) (eq arg 'x)) #(a x b x c x d x e x f) :start 2 :end 8 :count 2 :from-end t) #(a x b x c z d z e x f)))
	(test-t (equalp (substitute-if #\z (lambda (arg) (char< #\c arg)) #(#\a #\b #\c #\d #\e #\f)) #(#\a #\b #\c #\z #\z #\z)))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (equal "war" arg)) #("love" "hate" "war" "peace")) #("love" "hate" "peace" "peace")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string-equal "war" arg)) #("war" "War" "WAr" "WAR")) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR") :key string-upcase) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR") :start 1 :end 2 :key string-upcase) #("war" "peace" "WAr" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR") :start 1 :end nil :key string-upcase) #("war" "peace" "peace" "peace")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "war" arg)) #("war" "War" "WAr" "WAR") :key string-upcase) #("war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 1 :key string-upcase) #("war" "peace" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 2 :key string-upcase) #("war" "peace" "peace" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 2 :from-end t :key string-upcase) #("war" "War" "WAr" "WAR" "war" "peace" "peace" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 0 :from-end t :key string-upcase) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count -2 :from-end t :key string-upcase) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count nil :from-end t :key string-upcase) #("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 6 :from-end t :key string-upcase) #("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 7 :from-end t :key string-upcase) #("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equalp (substitute-if "peace" (lambda (arg) (string= "WAR" arg)) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 100 :from-end t :key string-upcase) #("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "abcabc") "AbcAbc"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "") ""))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "xyz") "xyz"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :start 5 :end nil) "aaaaaAAAAA"))
	(test-t (string= (substitute-if #\x (lambda (arg) (char< #\5 arg)) "0123456789") "012345xxxx"))
	(test-t (string= (substitute-if #\x (lambda (arg) (char> #\5 arg)) "0123456789") "xxxxx56789"))
	(test-t (string= (substitute-if #\x (lambda (arg) (char> #\D arg)) "abcdefg" :key char-upcase) "xxxdefg"))
	(test-t (string= (substitute-if #\x (lambda (arg) (char> #\D arg)) "abcdefg" :start 1 :end 2 :key char-upcase) "axcdefg"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :count 2) "AAaaaaaaaa"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :count -1) "aaaaaaaaaa"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :count 0) "aaaaaaaaaa"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :count nil) "AAAAAAAAAA"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :count 100) "AAAAAAAAAA"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :count 9) "AAAAAAAAAa"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :count 9 :from-end t) "aAAAAAAAAA"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :start 2 :end 8 :count 3) "aaAAAaaaaa"))
	(test-t (string= (substitute-if #\A (lambda (arg) (eql #\a arg)) "aaaaaaaaaa" :start 2 :end 8 :from-end t :count 3) "aaaaaAAAaa"))
	(test-t (string= (substitute-if #\x (lambda (arg) (eql #\A arg)) "aaaaaaaaaa" :start 2 :end 8 :from-end t :count 3) "aaaaaaaaaa"))
	(test-t (string= (substitute-if #\X (lambda (arg) (eql #\A arg)) "aaaaaaaaaa" :start 2 :end 8 :from-end t :key char-upcase :count 3) "aaaaaXXXaa"))
	(test-t (string= (substitute-if #\X (lambda (arg) (char< #\D arg)) "abcdefghij" :start 2 :end 8 :from-end t :key char-upcase :count 3) "abcdeXXXij"))
	(test-t (equal (substitute-if-not 'a (lambda (arg) (not (eq arg 'x))) '(x y z)) '(a y z)))
	(test-t (equal (substitute-if-not 'b (lambda (arg) (not (eq arg 'y))) '(x y z)) '(x b z)))
	(test-t (equal (substitute-if-not 'c (lambda (arg) (not (eq arg 'z))) '(x y z)) '(x y c)))
	(test-t (equal (substitute-if-not 'a (lambda (arg) (not (eq arg 'p))) '(x y z)) '(x y z)))
	(test-t (equal (substitute-if-not 'a (lambda (arg) (not (eq arg 'x))) '()) '()))
	(test-t (equal (substitute-if-not #\x (lambda (arg) (not (char< #\b arg))) '(#\a #\b #\c #\d #\e)) '(#\a #\b #\x #\x #\x)))
	(test-t (equal (substitute-if-not '(a) (lambda (arg) (not (eq arg 'x))) '((x) (y) (z)) :key car) '((a) (y) (z))))
	(test-t (equal (substitute-if-not 'c (lambda (arg) (not (eq arg 'b))) '(a b a b a b a b)) '(a c a c a c a c)))
	(test-t (equal (substitute-if-not 'a (lambda (arg) (not (eq arg 'b))) '(b b b)) '(a a a)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f)) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count nil) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 0) '(a x b x c x d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count -100) '(a x b x c x d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 1) '(a z b x c x d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 2) '(a z b z c x d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 3) '(a z b z c z d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 4) '(a z b z c z d z e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 5) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 6) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 7) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count nil :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 0 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count -100 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 1 :from-end t) '(a x b x c x d x e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 2 :from-end t) '(a x b x c x d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 3 :from-end t) '(a x b x c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 4 :from-end t) '(a x b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 5 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 6 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :count 7 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :start 2 :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :start 2 :end nil :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :start 2 :end 6 :count 100) '(a x b z c z d x e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :start 2 :end 11 :count 100) '(a x b z c z d z e z f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :start 2 :end 8 :count 10) '(a x b z c z d z e x f)))
	(test-t (equal (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) '(a x b x c x d x e x f) :start 2 :end 8 :count 2 :from-end t) '(a x b x c z d z e x f)))
	(test-t (equal (substitute-if-not #\z (lambda (arg) (not (char< #\c arg))) '(#\a #\b #\c #\d #\e #\f)) '(#\a #\b #\c #\z #\z #\z)))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (equal "war" arg))) '("love" "hate" "war" "peace")) '("love" "hate" "peace" "peace")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string-equal "war" arg))) '("war" "War" "WAr" "WAR")) '("peace" "peace" "peace" "peace")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR") :key string-upcase) '("peace" "peace" "peace" "peace")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR") :start 1 :end 2 :key string-upcase) '("war" "peace" "WAr" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR") :start 1 :end nil :key string-upcase) '("war" "peace" "peace" "peace")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "war" arg))) '("war" "War" "WAr" "WAR") :key string-upcase) '("war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 1 :key string-upcase) '("war" "peace" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 2 :key string-upcase) '("war" "peace" "peace" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 2 :from-end t :key string-upcase) '("war" "War" "WAr" "WAR" "war" "peace" "peace" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 0 :from-end t :key string-upcase) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count -2 :from-end t :key string-upcase) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count nil :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 6 :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 7 :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equal (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 100 :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equalp (substitute-if-not 'a (lambda (arg) (not (eq arg 'x))) #(x y z)) #(a y z)))
	(test-t (equalp (substitute-if-not 'b (lambda (arg) (not (eq arg 'y))) #(x y z)) #(x b z)))
	(test-t (equalp (substitute-if-not 'c (lambda (arg) (not (eq arg 'z))) #(x y z)) #(x y c)))
	(test-t (equalp (substitute-if-not 'a (lambda (arg) (not (eq arg 'p))) #(x y z)) #(x y z)))
	(test-t (equalp (substitute-if-not 'a (lambda (arg) (not (eq arg 'x))) #()) #()))
	(test-t (equalp (substitute-if-not #\x (lambda (arg) (not (char< #\b arg))) #(#\a #\b #\c #\d #\e)) #(#\a #\b #\x #\x #\x)))
	(test-t (equalp (substitute-if-not '(a) (lambda (arg) (not (eq arg 'x))) #((x) (y) (z)) :key car) #((a) (y) (z))))
	(test-t (equalp (substitute-if-not 'c (lambda (arg) (not (eq arg 'b))) #(a b a b a b a b)) #(a c a c a c a c)))
	(test-t (equalp (substitute-if-not 'a (lambda (arg) (not (eq arg 'b))) #(b b b)) #(a a a)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f)) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count nil) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 0) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count -100) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 1) #(a z b x c x d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 2) #(a z b z c x d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 3) #(a z b z c z d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 4) #(a z b z c z d z e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 5) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 6) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 7) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count nil :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 0 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count -100 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 1 :from-end t) #(a x b x c x d x e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 2 :from-end t) #(a x b x c x d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 3 :from-end t) #(a x b x c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 4 :from-end t) #(a x b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 5 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 6 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :count 7 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :start 2 :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :start 2 :end nil :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :start 2 :end 6 :count 100) #(a x b z c z d x e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :start 2 :end 11 :count 100) #(a x b z c z d z e z f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :start 2 :end 8 :count 10) #(a x b z c z d z e x f)))
	(test-t (equalp (substitute-if-not 'z (lambda (arg) (not (eq arg 'x))) #(a x b x c x d x e x f) :start 2 :end 8 :count 2 :from-end t) #(a x b x c z d z e x f)))
	(test-t (equalp (substitute-if-not #\z (lambda (arg) (not (char< #\c arg))) #(#\a #\b #\c #\d #\e #\f)) #(#\a #\b #\c #\z #\z #\z)))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (equal "war" arg))) #("love" "hate" "war" "peace")) #("love" "hate" "peace" "peace")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string-equal "war" arg))) #("war" "War" "WAr" "WAR")) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR") :key string-upcase) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR") :start 1 :end 2 :key string-upcase) #("war" "peace" "WAr" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR") :start 1 :end nil :key string-upcase) #("war" "peace" "peace" "peace")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "war" arg))) #("war" "War" "WAr" "WAR") :key string-upcase) #("war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 1 :key string-upcase) #("war" "peace" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 2 :key string-upcase) #("war" "peace" "peace" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 2 :from-end t :key string-upcase) #("war" "War" "WAr" "WAR" "war" "peace" "peace" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 0 :from-end t :key string-upcase) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count -2 :from-end t :key string-upcase) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count nil :from-end t :key string-upcase) #("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 6 :from-end t :key string-upcase) #("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 7 :from-end t :key string-upcase) #("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equalp (substitute-if-not "peace" (lambda (arg) (not (string= "WAR" arg))) #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR") :start 1 :end 7 :count 100 :from-end t :key string-upcase) #("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "abcabc") "AbcAbc"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "") ""))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "xyz") "xyz"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :start 5 :end nil) "aaaaaAAAAA"))
	(test-t (string= (substitute-if-not #\x (lambda (arg) (not (char< #\5 arg))) "0123456789") "012345xxxx"))
	(test-t (string= (substitute-if-not #\x (lambda (arg) (not (char> #\5 arg))) "0123456789") "xxxxx56789"))
	(test-t (string= (substitute-if-not #\x (lambda (arg) (not (char> #\D arg))) "abcdefg" :key char-upcase) "xxxdefg"))
	(test-t (string= (substitute-if-not #\x (lambda (arg) (not (char> #\D arg))) "abcdefg" :start 1 :end 2 :key char-upcase) "axcdefg"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :count 2) "AAaaaaaaaa"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :count -1) "aaaaaaaaaa"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :count 0) "aaaaaaaaaa"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :count nil) "AAAAAAAAAA"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :count 100) "AAAAAAAAAA"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :count 9) "AAAAAAAAAa"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :count 9 :from-end t) "aAAAAAAAAA"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :start 2 :end 8 :count 3) "aaAAAaaaaa"))
	(test-t (string= (substitute-if-not #\A (lambda (arg) (not (eql #\a arg))) "aaaaaaaaaa" :start 2 :end 8 :from-end t :count 3) "aaaaaAAAaa"))
	(test-t (string= (substitute-if-not #\x (lambda (arg) (not (eql #\A arg))) "aaaaaaaaaa" :start 2 :end 8 :from-end t :count 3) "aaaaaaaaaa"))
	(test-t (string= (substitute-if-not #\X (lambda (arg) (not (eql #\A arg))) "aaaaaaaaaa" :start 2 :end 8 :from-end t :key char-upcase :count 3) "aaaaaXXXaa"))
	(test-t (string= (substitute-if-not #\X (lambda (arg) (not (char< #\D arg))) "abcdefghij" :start 2 :end 8 :from-end t :key char-upcase :count 3) "abcdeXXXij"))
	(test-t (equal (nsubstitute 'a 'x (copy-seq '(x y z))) '(a y z)))
	(test-t (equal (nsubstitute 'b 'y (copy-seq '(x y z))) '(x b z)))
	(test-t (equal (nsubstitute 'c 'z (copy-seq '(x y z))) '(x y c)))
	(test-t (equal (nsubstitute 'a 'p (copy-seq '(x y z))) '(x y z)))
	(test-t (equal (nsubstitute 'a 'x (copy-seq '())) '()))
	(test-t (equal (nsubstitute #\x #\b (copy-seq '(#\a #\b #\c #\d #\e)) :test char<) '(#\a #\b #\x #\x #\x)))
	(test-t (equal (nsubstitute '(a) 'x (copy-seq '((x) (y) (z))) :key car) '((a) (y) (z))))
	(test-t (equal (nsubstitute 'c 'b (copy-seq '(a b a b a b a b))) '(a c a c a c a c)))
	(test-t (equal (nsubstitute 'a 'b (copy-seq '(b b b))) '(a a a)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f))) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count nil) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 0) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count -100) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 1) '(a z b x c x d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 2) '(a z b z c x d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 3) '(a z b z c z d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 4) '(a z b z c z d z e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 5) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 6) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 7) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count nil :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 0 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count -100 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 1 :from-end t) '(a x b x c x d x e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 2 :from-end t) '(a x b x c x d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 3 :from-end t) '(a x b x c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 4 :from-end t) '(a x b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 5 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 6 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :count 7 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :start 2 :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :start 2 :end nil :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :start 2 :end 6 :count 100) '(a x b z c z d x e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :start 2 :end 11 :count 100) '(a x b z c z d z e z f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :start 2 :end 8 :count 10) '(a x b z c z d z e x f)))
	(test-t (equal (nsubstitute 'z 'x (copy-seq '(a x b x c x d x e x f)) :start 2 :end 8 :count 2 :from-end t) '(a x b x c z d z e x f)))
	(test-t (equal (nsubstitute #\z #\c (copy-seq '(#\a #\b #\c #\d #\e #\f)) :test char<) '(#\a #\b #\c #\z #\z #\z)))
	(test-t (equal (nsubstitute "peace" "war" (copy-seq '("love" "hate" "war" "peace")) :test equal) '("love" "hate" "peace" "peace")))
	(test-t (equal (nsubstitute "peace" "war" (copy-seq '("war" "War" "WAr" "WAR")) :test string-equal) '("peace" "peace" "peace" "peace")))
	(test-t (equal (nsubstitute "peace" "WAR" (copy-seq '("war" "War" "WAr" "WAR")) :test string=) '("war" "War" "WAr" "peace")))
	(test-t (equal (nsubstitute "peace" "WAR" (copy-seq '("war" "War" "WAr" "WAR")) :test string= :key string-upcase) '("peace" "peace" "peace" "peace")))
	(test-t (equal (nsubstitute "peace" "WAR" (copy-seq '("war" "War" "WAr" "WAR")) :start 1 :end 2 :test string= :key string-upcase) '("war" "peace" "WAr" "WAR")))
	(test-t (equalp (nsubstitute 'a 'x (copy-seq #(x y z))) #(a y z)))
	(test-t (equalp (nsubstitute 'b 'y (copy-seq #(x y z))) #(x b z)))
	(test-t (equalp (nsubstitute 'c 'z (copy-seq #(x y z))) #(x y c)))
	(test-t (equalp (nsubstitute 'a 'p (copy-seq #(x y z))) #(x y z)))
	(test-t (equalp (nsubstitute 'a 'x (copy-seq #())) #()))
	(test-t (equalp (nsubstitute #\x #\b (copy-seq #(#\a #\b #\c #\d #\e)) :test char<) #(#\a #\b #\x #\x #\x)))
	(test-t (equalp (nsubstitute '(a) 'x (copy-seq #((x) (y) (z))) :key car) #((a) (y) (z))))
	(test-t (equalp (nsubstitute 'c 'b (copy-seq #(a b a b a b a b))) #(a c a c a c a c)))
	(test-t (equalp (nsubstitute 'a 'b (copy-seq #(b b b))) #(a a a)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f))) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count nil) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 0) #(a x b x c x d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count -100) #(a x b x c x d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 1) #(a z b x c x d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 2) #(a z b z c x d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 3) #(a z b z c z d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 4) #(a z b z c z d z e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 5) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 6) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 7) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count nil :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 0 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count -100 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 1 :from-end t) #(a x b x c x d x e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 2 :from-end t) #(a x b x c x d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 3 :from-end t) #(a x b x c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 4 :from-end t) #(a x b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 5 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 6 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :count 7 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :start 2 :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :start 2 :end nil :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :start 2 :end 6 :count 100) #(a x b z c z d x e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :start 2 :end 11 :count 100) #(a x b z c z d z e z f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :start 2 :end 8 :count 10) #(a x b z c z d z e x f)))
	(test-t (equalp (nsubstitute 'z 'x (copy-seq #(a x b x c x d x e x f)) :start 2 :end 8 :count 2 :from-end t) #(a x b x c z d z e x f)))
	(test-t (equalp (nsubstitute #\z #\c (copy-seq #(#\a #\b #\c #\d #\e #\f)) :test char<) #(#\a #\b #\c #\z #\z #\z)))
	(test-t (equalp (nsubstitute "peace" "war" (copy-seq #("love" "hate" "war" "peace")) :test equal) #("love" "hate" "peace" "peace")))
	(test-t (equalp (nsubstitute "peace" "war" (copy-seq #("war" "War" "WAr" "WAR")) :test string-equal) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (nsubstitute "peace" "WAR" (copy-seq #("war" "War" "WAr" "WAR")) :test string=) #("war" "War" "WAr" "peace")))
	(test-t (equalp (nsubstitute "peace" "WAR" (copy-seq #("war" "War" "WAr" "WAR")) :test string= :key string-upcase) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (nsubstitute "peace" "WAR" (copy-seq #("war" "War" "WAr" "WAR")) :start 1 :end 2 :test string= :key string-upcase) #("war" "peace" "WAr" "WAR")))
	(test-t (equalp (nsubstitute "peace" "WAR" (copy-seq #("war" "War" "WAr" "WAR")) :start 1 :end nil :test string= :key string-upcase) #("war" "peace" "peace" "peace")))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "abcabc")) "AbcAbc"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "")) ""))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "xyz")) "xyz"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :start 5 :end nil) "aaaaaAAAAA"))
	(test-t (string= (nsubstitute #\x #\5 (copy-seq "0123456789") :test char<) "012345xxxx"))
	(test-t (string= (nsubstitute #\x #\5 (copy-seq "0123456789") :test char>) "xxxxx56789"))
	(test-t (string= (nsubstitute #\x #\D (copy-seq "abcdefg") :key char-upcase :test char>) "xxxdefg"))
	(test-t (string= (nsubstitute #\x #\D (copy-seq "abcdefg") :start 1 :end 2 :key char-upcase :test char>) "axcdefg"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :count 2) "AAaaaaaaaa"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :count -1) "aaaaaaaaaa"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :count 0) "aaaaaaaaaa"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :count nil) "AAAAAAAAAA"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :count 100) "AAAAAAAAAA"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :count 9) "AAAAAAAAAa"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :count 9 :from-end t) "aAAAAAAAAA"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :start 2 :end 8 :count 3) "aaAAAaaaaa"))
	(test-t (string= (nsubstitute #\A #\a (copy-seq "aaaaaaaaaa") :start 2 :end 8 :from-end t :count 3) "aaaaaAAAaa"))
	(test-t (string= (nsubstitute #\x #\A (copy-seq "aaaaaaaaaa") :start 2 :end 8 :from-end t :count 3) "aaaaaaaaaa"))
	(test-t (string= (nsubstitute #\X #\A (copy-seq "aaaaaaaaaa") :start 2 :end 8 :from-end t :key char-upcase :count 3) "aaaaaXXXaa"))
	(test-t (string= (nsubstitute #\X #\D (copy-seq "abcdefghij") :start 2 :end 8 :from-end t :key char-upcase :test char< :count 3) "abcdeXXXij"))
	(test-t (equal (nsubstitute-if 'a (lambda (arg) (eq arg 'x)) (copy-seq '(x y z))) '(a y z)))
	(test-t (equal (nsubstitute-if 'b (lambda (arg) (eq arg 'y)) (copy-seq '(x y z))) '(x b z)))
	(test-t (equal (nsubstitute-if 'c (lambda (arg) (eq arg 'z)) (copy-seq '(x y z))) '(x y c)))
	(test-t (equal (nsubstitute-if 'a (lambda (arg) (eq arg 'p)) (copy-seq '(x y z))) '(x y z)))
	(test-t (equal (nsubstitute-if 'a (lambda (arg) (eq arg 'x)) (copy-seq '())) '()))
	(test-t (equal (nsubstitute-if #\x (lambda (arg) (char< #\b arg)) (copy-seq '(#\a #\b #\c #\d #\e))) '(#\a #\b #\x #\x #\x)))
	(test-t (equal (nsubstitute-if '(a) (lambda (arg) (eq arg 'x)) (copy-seq '((x) (y) (z))) :key car) '((a) (y) (z))))
	(test-t (equal (nsubstitute-if 'c (lambda (arg) (eq arg 'b)) (copy-seq '(a b a b a b a b))) '(a c a c a c a c)))
	(test-t (equal (nsubstitute-if 'a (lambda (arg) (eq arg 'b)) (copy-seq '(b b b))) '(a a a)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f))) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count nil) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 0) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count -100) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 1) '(a z b x c x d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 2) '(a z b z c x d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 3) '(a z b z c z d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 4) '(a z b z c z d z e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 5) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 6) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 7) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count nil :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 0 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count -100 :from-end t) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 1 :from-end t) '(a x b x c x d x e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 2 :from-end t) '(a x b x c x d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 3 :from-end t) '(a x b x c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 4 :from-end t) '(a x b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 5 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 6 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :count 7 :from-end t) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :start 2 :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :start 2 :end nil :count 1) '(a x b z c x d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :start 2 :end 6 :count 100) '(a x b z c z d x e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :start 2 :end 11 :count 100) '(a x b z c z d z e z f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :start 2 :end 8 :count 10) '(a x b z c z d z e x f)))
	(test-t (equal (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq '(a x b x c x d x e x f)) :start 2 :end 8 :count 2 :from-end t) '(a x b x c z d z e x f)))
	(test-t (equal (nsubstitute-if #\z (lambda (arg) (char< #\c arg)) (copy-seq '(#\a #\b #\c #\d #\e #\f))) '(#\a #\b #\c #\z #\z #\z)))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (equal "war" arg)) (copy-seq '("love" "hate" "war" "peace"))) '("love" "hate" "peace" "peace")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string-equal "war" arg)) (copy-seq '("war" "War" "WAr" "WAR"))) '("peace" "peace" "peace" "peace")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR")) :key string-upcase) '("peace" "peace" "peace" "peace")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR")) :start 1 :end 2 :key string-upcase) '("war" "peace" "WAr" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR")) :start 1 :end nil :key string-upcase) '("war" "peace" "peace" "peace")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "war" arg)) (copy-seq '("war" "War" "WAr" "WAR")) :key string-upcase) '("war" "War" "WAr" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 1 :key string-upcase) '("war" "peace" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 2 :key string-upcase) '("war" "peace" "peace" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 2 :from-end t :key string-upcase) '("war" "War" "WAr" "WAR" "war" "peace" "peace" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 0 :from-end t :key string-upcase) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count -2 :from-end t :key string-upcase) '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count nil :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 6 :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 7 :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equal (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq '("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 100 :from-end t :key string-upcase) '("war" "peace" "peace" "peace" "peace" "peace" "peace" "WAR")))
	(test-t (equalp (nsubstitute-if 'a (lambda (arg) (eq arg 'x)) (copy-seq #(x y z))) #(a y z)))
	(test-t (equalp (nsubstitute-if 'b (lambda (arg) (eq arg 'y)) (copy-seq #(x y z))) #(x b z)))
	(test-t (equalp (nsubstitute-if 'c (lambda (arg) (eq arg 'z)) (copy-seq #(x y z))) #(x y c)))
	(test-t (equalp (nsubstitute-if 'a (lambda (arg) (eq arg 'p)) (copy-seq #(x y z))) #(x y z)))
	(test-t (equalp (nsubstitute-if 'a (lambda (arg) (eq arg 'x)) (copy-seq #())) #()))
	(test-t (equalp (nsubstitute-if #\x (lambda (arg) (char< #\b arg)) (copy-seq #(#\a #\b #\c #\d #\e))) #(#\a #\b #\x #\x #\x)))
	(test-t (equalp (nsubstitute-if '(a) (lambda (arg) (eq arg 'x)) (copy-seq #((x) (y) (z))) :key car) #((a) (y) (z))))
	(test-t (equalp (nsubstitute-if 'c (lambda (arg) (eq arg 'b)) (copy-seq #(a b a b a b a b))) #(a c a c a c a c)))
	(test-t (equalp (nsubstitute-if 'a (lambda (arg) (eq arg 'b)) (copy-seq #(b b b))) #(a a a)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f))) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count nil) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 0) #(a x b x c x d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count -100) #(a x b x c x d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 1) #(a z b x c x d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 2) #(a z b z c x d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 3) #(a z b z c z d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 4) #(a z b z c z d z e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 5) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 6) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 7) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count nil :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 0 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count -100 :from-end t) #(a x b x c x d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 1 :from-end t) #(a x b x c x d x e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 2 :from-end t) #(a x b x c x d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 3 :from-end t) #(a x b x c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 4 :from-end t) #(a x b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 5 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 6 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :count 7 :from-end t) #(a z b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :start 2 :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :start 2 :end nil :count 1) #(a x b z c x d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :start 2 :end 6 :count 100) #(a x b z c z d x e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :start 2 :end 11 :count 100) #(a x b z c z d z e z f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :start 2 :end 8 :count 10) #(a x b z c z d z e x f)))
	(test-t (equalp (nsubstitute-if 'z (lambda (arg) (eq arg 'x)) (copy-seq #(a x b x c x d x e x f)) :start 2 :end 8 :count 2 :from-end t) #(a x b x c z d z e x f)))
	(test-t (equalp (nsubstitute-if #\z (lambda (arg) (char< #\c arg)) (copy-seq #(#\a #\b #\c #\d #\e #\f))) #(#\a #\b #\c #\z #\z #\z)))
	(test-t (equalp (nsubstitute-if "peace" (lambda (arg) (equal "war" arg)) (copy-seq #("love" "hate" "war" "peace"))) #("love" "hate" "peace" "peace")))
	(test-t (equalp (nsubstitute-if "peace" (lambda (arg) (string-equal "war" arg)) (copy-seq #("war" "War" "WAr" "WAR"))) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq #("war" "War" "WAr" "WAR")) :key string-upcase) #("peace" "peace" "peace" "peace")))
	(test-t (equalp (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq #("war" "War" "WAr" "WAR")) :start 1 :end 2 :key string-upcase) #("war" "peace" "WAr" "WAR")))
	(test-t (equalp (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq #("war" "War" "WAr" "WAR")) :start 1 :end nil :key string-upcase) #("war" "peace" "peace" "peace")))
	(test-t (equalp (nsubstitute-if "peace" (lambda (arg) (string= "war" arg)) (copy-seq #("war" "War" "WAr" "WAR")) :key string-upcase) #("war" "War" "WAr" "WAR")))
	(test-t (equalp (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 1 :key string-upcase) #("war" "peace" "WAr" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 2 :key string-upcase) #("war" "peace" "peace" "WAR" "war" "War" "WAr" "WAR")))
	(test-t (equalp (nsubstitute-if "peace" (lambda (arg) (string= "WAR" arg)) (copy-seq #("war" "War" "WAr" "WAR" "war" "War" "WAr" "WAR")) :start 1 :end 7 :count 2 :from-end t :key string-upcase) #("war" "War" "WAr" "WAR" "war" "peace" "peace" "WAR")))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "abcabc")) "AbcAbc"))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "")) ""))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "xyz")) "xyz"))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "aaaaaaaaaa") :start 5 :end nil) "aaaaaAAAAA"))
	(test-t (string= (nsubstitute-if #\x (lambda (arg) (char< #\5 arg)) (copy-seq "0123456789")) "012345xxxx"))
	(test-t (string= (nsubstitute-if #\x (lambda (arg) (char> #\5 arg)) (copy-seq "0123456789")) "xxxxx56789"))
	(test-t (string= (nsubstitute-if #\x (lambda (arg) (char> #\D arg)) (copy-seq "abcdefg") :key char-upcase) "xxxdefg"))
	(test-t (string= (nsubstitute-if #\x (lambda (arg) (char> #\D arg)) (copy-seq "abcdefg") :start 1 :end 2 :key char-upcase) "axcdefg"))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "aaaaaaaaaa") :count 2) "AAaaaaaaaa"))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "aaaaaaaaaa") :count -1) "aaaaaaaaaa"))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "aaaaaaaaaa") :count 0) "aaaaaaaaaa"))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "aaaaaaaaaa") :count nil) "AAAAAAAAAA"))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "aaaaaaaaaa") :count 100) "AAAAAAAAAA"))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "aaaaaaaaaa") :count 9) "AAAAAAAAAa"))
	(test-t (string= (nsubstitute-if #\A (lambda (arg) (eql #\a arg)) (copy-seq "aaaaaaaaaa") :count 9 :from-end t) "aAAAAAAAAA"))
	(test-t (equal (nsubstitute-if-not 'a (lambda (arg) (not (eq arg 'x))) (copy-seq '(x y z))) '(a y z)))
	(test-t (equal (nsubstitute-if-not 'b (lambda (arg) (not (eq arg 'y))) (copy-seq '(x y z))) '(x b z)))
	(test-t (equal (nsubstitute-if-not 'c (lambda (arg) (not (eq arg 'z))) (copy-seq '(x y z))) '(x y c)))
	(test-t (equal (nsubstitute-if-not 'a (lambda (arg) (not (eq arg 'p))) (copy-seq '(x y z))) '(x y z)))
	(test-t (equal (nsubstitute-if-not 'a (lambda (arg) (not (eq arg 'x))) (copy-seq '())) '()))
	(test-t (equal (nsubstitute-if-not #\x (lambda (arg) (not (char< #\b arg))) (copy-seq '(#\a #\b #\c #\d #\e))) '(#\a #\b #\x #\x #\x)))
	(test-t (equal (nsubstitute-if-not '(a) (lambda (arg) (not (eq arg 'x))) (copy-seq '((x) (y) (z))) :key car) '((a) (y) (z))))
	(test-t (equal (nsubstitute-if-not 'c (lambda (arg) (not (eq arg 'b))) (copy-seq '(a b a b a b a b))) '(a c a c a c a c)))
	(test-t (equal (nsubstitute-if-not 'a (lambda (arg) (not (eq arg 'b))) (copy-seq '(b b b))) '(a a a)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f))) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count nil) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count 0) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count -100) '(a x b x c x d x e x f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count 1) '(a z b x c x d x e x f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count 2) '(a z b z c x d x e x f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count 3) '(a z b z c z d x e x f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count 4) '(a z b z c z d z e x f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count 5) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count 6) '(a z b z c z d z e z f)))
	(test-t (equal (nsubstitute-if-not 'z (lambda (arg) (not (eq arg 'x))) (copy-seq '(a x b x c x d x e x f)) :count 7) '(a z b z c z d z e z f)))
	
	(test-t (string= (concatenate 'string "all" " " "together" " " "now") "all together now"))
	(test-t (equal (concatenate 'list '() '(a b c) '(x y z)) '(a b c x y z)))
	(test-t (equal (concatenate 'list '(a) #(b) '(c) #(x y) '(z)) '(a b c x y z)))
	(test-t (null (concatenate 'list)))
	(test-t (let* ((list0 '(a b c)) (list (concatenate 'list list0))) (and (not (eq list0 list)) (equal list list0) (equal list '(a b c)))))
	(test-t (equalp (concatenate 'vector '() '(a b c) '(x y z)) #(a b c x y z)))
	(test-t (equalp (concatenate 'vector '(a) #(b) '(c) #(x y) '(z)) #(a b c x y z)))
	(test-t (equalp (concatenate 'vector) #()))
	(test-t (let* ((vector0 #(a b c)) (vector (concatenate 'vector vector0))) (and (not (eq vector0 vector)) (equalp vector vector0) (equalp vector #(a b c)))))
	(test-t (string= (concatenate 'string "abc" "def" "ghi" "jkl" "mno" "pqr") "abcdefghijklmnopqr"))
	(test-t (string= (concatenate 'string "" "abc" "" "def" "" "ghi" "" "" "jkl" "" "mno" "" "pqr" "" "") "abcdefghijklmnopqr"))
	(test-t (string= (concatenate 'string) ""))
	(test-t (string= (concatenate 'string "abc" '(#\d #\e #\f #\g) #(#\h #\i #\j #\k #\l)) "abcdefghijkl"))
	(test-t (let ((test1 (list 1 3 4 6 7)) (test2 (list 2 5 8))) (equal (merge 'list test1 test2 <) '(1 2 3 4 5 6 7 8))))
	(test-t (let ((test1 (vector '(red . 1) '(blue . 4))) (test2 (vector '(yellow . 2) '(green . 7)))) (equalp (merge 'vector test1 test2 < :key cdr) #((red . 1) (yellow . 2) (blue . 4) (green . 7)))))
	(test-t (equal (merge 'list (list 1 3 5 7 9) (list 0 2 4 6 8) <) '(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equal (merge 'list (list 0 1 2) nil <) '(0 1 2)))
	(test-t (equal (merge 'list nil (list 0 1 2) <) '(0 1 2)))
	(test-t (equal (merge 'list nil nil <) nil))
	(test-t (equal (merge 'list (list '(1 1) '(2 1) '(3 1)) (list '(1 2) '(2 2) '(3 2)) <= :key car) '((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))))
	(test-t (equal (merge 'list (list '(1 1) '(2 1) '(2 1 1) '(3 1)) (list '(1 2) '(2 2) '(3 2)) <= :key car) '((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2))))
	(test-t (equal (merge 'list (list '(1 1) '(2 1) '(2 1 1) '(3 1)) (list '(1 2) '(2 2) '(3 2) '(3 2 2)) <= :key car) '((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2) (3 2 2))))
	(test-t (equal (merge 'list (list 3 1 9 5 7) (list 8 6 0 2 4) <) '(3 1 8 6 0 2 4 9 5 7)))
	(test-t (equal (merge 'list (vector 1 3 5 7 9) (list 0 2 4 6 8) <) '(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equal (merge 'list (vector 0 1 2) nil <) '(0 1 2)))
	(test-t (equal (merge 'list #() (list 0 1 2) <) '(0 1 2)))
	(test-t (equal (merge 'list #() #() <) nil))
	(test-t (equal (merge 'list (vector '(1 1) '(2 1) '(3 1)) (list '(1 2) '(2 2) '(3 2)) <= :key car) '((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))))
	(test-t (equal (merge 'list (vector '(1 1) '(2 1) '(2 1 1) '(3 1)) (list '(1 2) '(2 2) '(3 2)) <= :key car) '((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2))))
	(test-t (equal (merge 'list (vector '(1 1) '(2 1) '(2 1 1) '(3 1)) (list '(1 2) '(2 2) '(3 2) '(3 2 2)) <= :key car) '((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2) (3 2 2))))
	(test-t (equal (merge 'list (vector 3 1 9 5 7) (list 8 6 0 2 4) <) '(3 1 8 6 0 2 4 9 5 7)))
	(test-t (equal (merge 'list (list 1 3 5 7 9) (vector 0 2 4 6 8) <) '(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equal (merge 'list (list 0 1 2) #() <) '(0 1 2)))
	(test-t (equal (merge 'list nil (vector 0 1 2) <) '(0 1 2)))
	(test-t (equal (merge 'list nil #() <) nil))
	(test-t (equal (merge 'list (list '(1 1) '(2 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2)) <= :key car) '((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))))
	(test-t (equal (merge 'list (list '(1 1) '(2 1) '(2 1 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2)) <= :key car) '((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2))))
	(test-t (equal (merge 'list (list '(1 1) '(2 1) '(2 1 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2) '(3 2 2)) <= :key car) '((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2) (3 2 2))))
	(test-t (equal (merge 'list (list 3 1 9 5 7) (vector 8 6 0 2 4) <) '(3 1 8 6 0 2 4 9 5 7)))
	(test-t (equal (merge 'list (vector 1 3 5 7 9) (vector 0 2 4 6 8) <) '(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equal (merge 'list (vector 0 1 2) #() <) '(0 1 2)))
	(test-t (equal (merge 'list #() (vector 0 1 2) <) '(0 1 2)))
	(test-t (equal (merge 'list #() #() <) nil))
	(test-t (equal (merge 'list (vector '(1 1) '(2 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2)) <= :key car) '((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))))
	(test-t (equal (merge 'list (vector '(1 1) '(2 1) '(2 1 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2)) <= :key car) '((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2))))
	(test-t (equal (merge 'list (vector '(1 1) '(2 1) '(2 1 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2) '(3 2 2)) <= :key car) '((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2) (3 2 2))))
	(test-t (equal (merge 'list (vector 3 1 9 5 7) (vector 8 6 0 2 4) <) '(3 1 8 6 0 2 4 9 5 7)))
	(test-t (equalp (merge 'vector (list 1 3 5 7 9) (list 0 2 4 6 8) <) #(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equalp (merge 'vector (list 1 3 5 7 9) (list 0 2 4 6 8) <) #(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equalp (merge 'vector (list 0 1 2) nil <) #(0 1 2)))
	(test-t (equalp (merge 'vector nil (list 0 1 2) <) #(0 1 2)))
	(test-t (equalp (merge 'vector nil nil <) #()))
	(test-t (equalp (merge 'vector (list '(1 1) '(2 1) '(3 1)) (list '(1 2) '(2 2) '(3 2)) <= :key car) #((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))))
	(test-t (equalp (merge 'vector (list '(1 1) '(2 1) '(2 1 1) '(3 1)) (list '(1 2) '(2 2) '(3 2)) <= :key car) #((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2))))
	(test-t (equalp (merge 'vector (list '(1 1) '(2 1) '(2 1 1) '(3 1)) (list '(1 2) '(2 2) '(3 2) '(3 2 2)) <= :key car) #((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2) (3 2 2))))
	(test-t (equalp (merge 'vector (list 3 1 9 5 7) (list 8 6 0 2 4) <) #(3 1 8 6 0 2 4 9 5 7)))
	(test-t (equalp (merge 'vector (vector 1 3 5 7 9) (list 0 2 4 6 8) <) #(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equalp (merge 'vector (vector 1 3 5 7 9) (list 0 2 4 6 8) <) #(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equalp (merge 'vector (vector 0 1 2) nil <) #(0 1 2)))
	(test-t (equalp (merge 'vector #() (list 0 1 2) <) #(0 1 2)))
	(test-t (equalp (merge 'vector #() #() <) #()))
	(test-t (equalp (merge 'vector (vector '(1 1) '(2 1) '(3 1)) (list '(1 2) '(2 2) '(3 2)) <= :key car) #((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))))
	(test-t (equalp (merge 'vector (vector '(1 1) '(2 1) '(2 1 1) '(3 1)) (list '(1 2) '(2 2) '(3 2)) <= :key car) #((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2))))
	(test-t (equalp (merge 'vector (vector '(1 1) '(2 1) '(2 1 1) '(3 1)) (list '(1 2) '(2 2) '(3 2) '(3 2 2)) <= :key car) #((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2) (3 2 2))))
	(test-t (equalp (merge 'vector (vector 3 1 9 5 7) (list 8 6 0 2 4) <) #(3 1 8 6 0 2 4 9 5 7)))
	(test-t (equalp (merge 'vector (list 1 3 5 7 9) (vector 0 2 4 6 8) <) #(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equalp (merge 'vector (list 1 3 5 7 9) (vector 0 2 4 6 8) <) #(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equalp (merge 'vector (list 0 1 2) #() <) #(0 1 2)))
	(test-t (equalp (merge 'vector nil (vector 0 1 2) <) #(0 1 2)))
	(test-t (equalp (merge 'vector nil #() <) #()))
	(test-t (equalp (merge 'vector (list '(1 1) '(2 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2)) <= :key car) #((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))))
	(test-t (equalp (merge 'vector (list '(1 1) '(2 1) '(2 1 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2)) <= :key car) #((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2))))
	(test-t (equalp (merge 'vector (list '(1 1) '(2 1) '(2 1 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2) '(3 2 2)) <= :key car) #((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2) (3 2 2))))
	(test-t (equalp (merge 'vector (list 3 1 9 5 7) (vector 8 6 0 2 4) <) #(3 1 8 6 0 2 4 9 5 7)))
	(test-t (equalp (merge 'vector (vector 1 3 5 7 9) (vector 0 2 4 6 8) <) #(0 1 2 3 4 5 6 7 8 9)))
	(test-t (equalp (merge 'vector (vector 0 1 2) #() <) #(0 1 2)))
	(test-t (equalp (merge 'vector #() (vector 0 1 2) <) #(0 1 2)))
	(test-t (equalp (merge 'vector #() #() <) #()))
	(test-t (equalp (merge 'vector (vector '(1 1) '(2 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2)) <= :key car) #((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))))
	(test-t (equalp (merge 'vector (vector '(1 1) '(2 1) '(2 1 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2)) <= :key car) #((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2))))
	(test-t (equalp (merge 'vector (vector '(1 1) '(2 1) '(2 1 1) '(3 1)) (vector '(1 2) '(2 2) '(3 2) '(3 2 2)) <= :key car) #((1 1) (1 2) (2 1) (2 1 1) (2 2) (3 1) (3 2) (3 2 2))))
	(test-t (equalp (merge 'vector (vector 3 1 9 5 7) (vector 8 6 0 2 4) <) #(3 1 8 6 0 2 4 9 5 7)))
	(test-t (string= (merge 'string (list #\a #\c #\e) (list #\b #\d #\f) char<) "abcdef"))
	(test-t (string= (merge 'string (list #\a #\b #\c) (list #\d #\e #\f) char<) "abcdef"))
	(test-t (string= (merge 'string (list #\a #\b #\c) '() char<) "abc"))
	(test-t (string= (merge 'string '() (list #\a #\b #\c) char<) "abc"))
	(test-t (string= (merge 'string (list #\a #\b #\c) (copy-seq "") char<) "abc"))
	(test-t (string= (merge 'string (list #\a #\b #\z) #(#\c #\x #\y) char<) "abcxyz"))
	(test-t (equal (remove 4 '(1 3 4 5 9)) '(1 3 5 9)))
	(test-t (equal (remove 4 '(1 2 4 1 3 4 5)) '(1 2 1 3 5)))
	(test-t (equal (remove 4 '(1 2 4 1 3 4 5) :count 1) '(1 2 1 3 4 5)))
	(test-t (equal (remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) '(1 2 4 1 3 5)))
	(test-t (equal (remove 3 '(1 2 4 1 3 4 5) :test >) '(4 3 4 5)))
	(test-t (let* ((lst '(list of four elements)) (lst2 (copy-seq lst)) (lst3 (delete 'four lst))) (and (equal lst3 '(list of elements)) (not (equal lst lst2)))))
	(test-t (equal (remove-if oddp '(1 2 4 1 3 4 5)) '(2 4 4)))
	(test-t (equal (remove-if evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) '(1 2 4 1 3 5)))
	(test-t (equal (remove-if-not evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t) '(1 2 3 4 5 6 8)))
	(test-t (equal (delete 4 (list 1 2 4 1 3 4 5)) '(1 2 1 3 5)))
	(test-t (equal (delete 4 (list 1 2 4 1 3 4 5) :count 1) '(1 2 1 3 4 5)))
	(test-t (equal (delete 4 (list 1 2 4 1 3 4 5) :count 1 :from-end t) '(1 2 4 1 3 5)))
	(test-t (equal (delete 3 (list 1 2 4 1 3 4 5) :test >) '(4 3 4 5)))
	(test-t (equal (delete-if oddp (list 1 2 4 1 3 4 5)) '(2 4 4)))
	(test-t (equal (delete-if evenp (list 1 2 4 1 3 4 5) :count 1 :from-end t) '(1 2 4 1 3 5)))
	(test-t (equal (delete-if evenp (list 1 2 3 4 5 6)) '(1 3 5)))
	(test-t (let* ((list0 (list 0 1 2 3 4)) (list (remove 3 list0))) (and (not (eq list0 list)) (equal list0 '(0 1 2 3 4)) (equal list '(0 1 2 4)))))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c)) '(b c b c)))
	(test-t (equal (remove 'b (list 'a 'b 'c 'a 'b 'c)) '(a c a c)))
	(test-t (equal (remove 'c (list 'a 'b 'c 'a 'b 'c)) '(a b a b)))
	(test-t (equal (remove 'a (list 'a 'a 'a)) '()))
	(test-t (equal (remove 'z (list 'a 'b 'c)) '(a b c)))
	(test-t (equal (remove 'a '()) '()))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count 0) '(a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count 1) '(b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) '(a b c b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count 2) '(b c b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) '(b c b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count 3) '(b c b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) '(b c b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count 4) '(b c b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) '(b c b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count -1) '(a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count -10) '(a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c) :count -100) '(a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) '(a b c b c b c b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) '(a b c b c b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) '(a b c b c b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) '(a b c b c b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) '(a b c a b c b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) '(a b c a b c a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) '(a b c a b c a b c a b c)))
	(test-t (equal (remove 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) '(a b c a b c a b c a b c)))
	(test-t (equal (remove 'a (list '(a) '(b) '(c) '(a) '(b) '(c)) :key car) '((b) (c) (b) (c))))
	(test-t (equal (remove 'a (list '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) '((a . b) (b . c) (a . b) (b . c))))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal) '()))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1) '(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :from-end t) '(("Love") ("LOve") ("LOVe"))))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 2 :from-end t) '(("Love") ("LOve"))))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :start 1 :end 3) '(("Love") ("LOVe") ("LOVE"))))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :from-end t :start 1 :end 3) '(("Love") ("LOve") ("LOVE"))))
	(test-t (equal (remove "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 10 :from-end t :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (let* ((vector0 (vector 0 1 2 3 4)) (vector (remove 3 vector0))) (and (not (eq vector0 vector)) (equalp vector0 #(0 1 2 3 4)) (equalp vector #(0 1 2 4)))))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c)) #(b c b c)))
	(test-t (equalp (remove 'b (vector 'a 'b 'c 'a 'b 'c)) #(a c a c)))
	(test-t (equalp (remove 'c (vector 'a 'b 'c 'a 'b 'c)) #(a b a b)))
	(test-t (equalp (remove 'a (vector 'a 'a 'a)) #()))
	(test-t (equalp (remove 'z (vector 'a 'b 'c)) #(a b c)))
	(test-t (equalp (remove 'a #()) #()))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count 0) #(a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count 1) #(b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) #(a b c b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count 2) #(b c b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) #(b c b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count 3) #(b c b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) #(b c b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count 4) #(b c b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) #(b c b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count -1) #(a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count -10) #(a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c) :count -100) #(a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) #(a b c b c b c b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) #(a b c b c b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) #(a b c a b c b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove 'a (vector '(a) '(b) '(c) '(a) '(b) '(c)) :key car) #((b) (c) (b) (c))))
	(test-t (equalp (remove 'a (vector '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) #((a . b) (b . c) (a . b) (b . c))))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal) #()))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :start 1 :end 3) #(("Love") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :from-end t :start 1 :end 3) #(("Love") ("LOve") ("LOVE"))))
	(test-t (equalp (remove "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 10 :from-end t :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (string= (remove #\a (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (remove #\a (copy-seq "")) ""))
	(test-t (string= (remove #\a (copy-seq "xyz")) "xyz"))
	(test-t (string= (remove #\a (copy-seq "ABCABC")) "ABCABC"))
	(test-t (string= (remove #\a (copy-seq "ABCABC") :key char-downcase) "BCBC"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (let* ((str0 (copy-seq "abc")) (str (remove #\a str0))) (and (not (eq str0 str)) (string= str0 "abc") (string= str "bc"))))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (remove #\b (copy-seq "abcabc")) "acac"))
	(test-t (string= (remove #\c (copy-seq "abcabc")) "abab"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 2) "bcbc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 2 :from-end t) "bcbc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 3) "bcbc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 3 :from-end t) "bcbc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 4) "bcbc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count 4 :from-end t) "bcbc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count -1) "abcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabc") :count -100) "abcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1) "abcbcbcbc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1 :count 1) "abcbcabcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1 :count 2) "abcbcbcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1 :end nil :count 2) "abcbcbcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1 :end 8) "abcbcbcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1) "abcbcabcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1 :from-end t) "abcabcbcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1 :end 8 :count 0 :from-end t) "abcabcabcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1 :end 8 :count -100 :from-end t) "abcabcabcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 1 :end 1) "abcabcabcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 2 :end 2) "abcabcabcabc"))
	(test-t (string= (remove #\a (copy-seq "abcabcabcabc") :start 12 :end 12) "abcabcabcabc"))
	(test-t (let* ((list0 (list 0 1 2 3 4)) (list (remove-if (lambda (arg) (eql arg 3)) list0))) (and (not (eq list0 list)) (equal list0 '(0 1 2 3 4)) (equal list '(0 1 2 4)))))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c)) '(b c b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'b)) (list 'a 'b 'c 'a 'b 'c)) '(a c a c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'c)) (list 'a 'b 'c 'a 'b 'c)) '(a b a b)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'a 'a)) '()))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'z)) (list 'a 'b 'c)) '(a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) '()) '()))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 0) '(a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 1) '(b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) '(a b c b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 2) '(b c b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) '(b c b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 3) '(b c b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) '(b c b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 4) '(b c b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) '(b c b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count -1) '(a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count -10) '(a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count -100) '(a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) '(a b c b c b c b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) '(a b c b c b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) '(a b c b c b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) '(a b c b c b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) '(a b c a b c b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list '(a) '(b) '(c) '(a) '(b) '(c)) :key car) '((b) (c) (b) (c))))
	(test-t (equal (remove-if (lambda (arg) (eql arg 'a)) (list '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) '((a . b) (b . c) (a . b) (b . c))))
	(test-t (equal (remove-if (lambda (arg) (eql arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (remove-if (lambda (arg) (eql arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (remove-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '()))
	(test-t (equal (remove-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) '(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (remove-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) '(("Love") ("LOve") ("LOVe"))))
	(test-t (equal (remove-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) '(("Love") ("LOve"))))
	(test-t (equal (remove-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (equal (remove-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :start 1 :end 3) '(("Love") ("LOVe") ("LOVE"))))
	(test-t (equal (remove-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t :start 1 :end 3) '(("Love") ("LOve") ("LOVE"))))
	(test-t (equal (remove-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 10 :from-end t :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (let* ((vector0 (vector 0 1 2 3 4)) (vector (remove-if (lambda (arg) (eql arg 3)) vector0))) (and (not (eq vector0 vector)) (equalp vector0 #(0 1 2 3 4)) (equalp vector #(0 1 2 4)))))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c)) #(b c b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'b)) (vector 'a 'b 'c 'a 'b 'c)) #(a c a c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'c)) (vector 'a 'b 'c 'a 'b 'c)) #(a b a b)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'a 'a)) #()))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'z)) (vector 'a 'b 'c)) #(a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) #()) #()))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 0) #(a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 1) #(b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) #(a b c b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 2) #(b c b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) #(b c b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 3) #(b c b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) #(b c b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 4) #(b c b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) #(b c b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count -1) #(a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count -10) #(a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count -100) #(a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) #(a b c b c b c b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) #(a b c b c b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) #(a b c a b c b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector '(a) '(b) '(c) '(a) '(b) '(c)) :key car) #((b) (c) (b) (c))))
	(test-t (equalp (remove-if (lambda (arg) (eql arg 'a)) (vector '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) #((a . b) (b . c) (a . b) (b . c))))
	(test-t (equalp (remove-if (lambda (arg) (eql arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if (lambda (arg) (eql arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #()))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #()))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :start 1 :end 3) #(("Love") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t :start 1 :end 3) #(("Love") ("LOve") ("LOVE"))))
	(test-t (equalp (remove-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 10 :from-end t :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "")) ""))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "xyz")) "xyz"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "ABCABC") :key char-downcase) "BCBC"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (let* ((str0 (copy-seq "abc")) (str (remove-if (lambda (arg) (string-equal arg #\a)) str0))) (and (not (eq str0 str)) (string= str0 "abc") (string= str "bc"))))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\b)) (copy-seq "abcabc")) "acac"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\c)) (copy-seq "abcabc")) "abab"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 2) "bcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 2 :from-end t) "bcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 3) "bcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 3 :from-end t) "bcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 4) "bcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 4 :from-end t) "bcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count -1) "abcabc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count -100) "abcabc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabcabcabc") :start 1) "abcbcbcbc"))
	(test-t (string= (remove-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabcabcabc") :start 1 :count 1) "abcbcabcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :count 2) "abcbcbcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end nil :count 2) "abcbcbcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8) "abcbcbcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1) "abcbcabcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1 :from-end t) "abcabcbcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 0 :from-end t) "abcabcabcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8 :count -100 :from-end t) "abcabcabcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 1) "abcabcabcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 2 :end 2) "abcabcabcabc"))
	(test-t (string= (remove-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 12 :end 12) "abcabcabcabc"))
	(test-t (let* ((list0 (list 0 1 2 3 4)) (list (remove-if-not (lambda (arg) (not (eql arg 3))) list0))) (and (not (eq list0 list)) (equal list0 '(0 1 2 3 4)) (equal list '(0 1 2 4)))))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c)) '(b c b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'b))) (list 'a 'b 'c 'a 'b 'c)) '(a c a c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'c))) (list 'a 'b 'c 'a 'b 'c)) '(a b a b)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'a 'a)) '()))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'z))) (list 'a 'b 'c)) '(a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) '()) '()))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 0) '(a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 1) '(b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) '(a b c b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 2) '(b c b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) '(b c b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 3) '(b c b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) '(b c b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 4) '(b c b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) '(b c b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count -1) '(a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count -10) '(a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count -100) '(a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) '(a b c b c b c b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) '(a b c b c b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) '(a b c b c b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) '(a b c b c b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) '(a b c a b c b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) '(a b c a b c a b c a b c)))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list '(a) '(b) '(c) '(a) '(b) '(c)) :key car) '((b) (c) (b) (c))))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg 'a))) (list '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) '((a . b) (b . c) (a . b) (b . c))))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (remove-if-not (lambda (arg) (not (eql arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '()))
	(test-t (equal (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) '(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) '(("Love") ("LOve") ("LOVe"))))
	(test-t (equal (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) '(("Love") ("LOve"))))
	(test-t (equal (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (equal (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :start 1 :end 3) '(("Love") ("LOVe") ("LOVE"))))
	(test-t (equal (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t :start 1 :end 3) '(("Love") ("LOve") ("LOVE"))))
	(test-t (equal (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 10 :from-end t :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (let* ((vector0 (vector 0 1 2 3 4)) (vector (remove-if-not (lambda (arg) (not (eql arg 3))) vector0))) (and (not (eq vector0 vector)) (equalp vector0 #(0 1 2 3 4)) (equalp vector #(0 1 2 4)))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c)) #(b c b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'b))) (vector 'a 'b 'c 'a 'b 'c)) #(a c a c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'c))) (vector 'a 'b 'c 'a 'b 'c)) #(a b a b)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'a 'a)) #()))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'z))) (vector 'a 'b 'c)) #(a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) #()) #()))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 0) #(a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 1) #(b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) #(a b c b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 2) #(b c b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) #(b c b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 3) #(b c b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) #(b c b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 4) #(b c b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) #(b c b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count -1) #(a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count -10) #(a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count -100) #(a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) #(a b c b c b c b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) #(a b c b c b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) #(a b c a b c b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) #(a b c a b c a b c a b c)))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector '(a) '(b) '(c) '(a) '(b) '(c)) :key car) #((b) (c) (b) (c))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg 'a))) (vector '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) #((a . b) (b . c) (a . b) (b . c))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (eql arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #()))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #()))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :start 1 :end 3) #(("Love") ("LOVe") ("LOVE"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t :start 1 :end 3) #(("Love") ("LOve") ("LOVE"))))
	(test-t (equalp (remove-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 10 :from-end t :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "")) ""))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "xyz")) "xyz"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "ABCABC") :key char-downcase) "BCBC"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (let* ((str0 (copy-seq "abc")) (str (remove-if-not (lambda (arg) (not (string-equal arg #\a))) str0))) (and (not (eq str0 str)) (string= str0 "abc") (string= str "bc"))))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\b))) (copy-seq "abcabc")) "acac"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\c))) (copy-seq "abcabc")) "abab"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 2) "bcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 2 :from-end t) "bcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 3) "bcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 3 :from-end t) "bcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 4) "bcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 4 :from-end t) "bcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count -1) "abcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count -100) "abcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabcabcabc") :start 1) "abcbcbcbc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabcabcabc") :start 1 :count 1) "abcbcabcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :count 2) "abcbcbcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end nil :count 2) "abcbcbcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8) "abcbcbcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1) "abcbcabcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1 :from-end t) "abcabcbcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 0 :from-end t) "abcabcabcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8 :count -100 :from-end t) "abcabcabcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 1) "abcabcabcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 2 :end 2) "abcabcabcabc"))
	(test-t (string= (remove-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 12 :end 12) "abcabcabcabc"))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c)) '(b c b c)))
	(test-t (equal (delete 'b (list 'a 'b 'c 'a 'b 'c)) '(a c a c)))
	(test-t (equal (delete 'c (list 'a 'b 'c 'a 'b 'c)) '(a b a b)))
	(test-t (equal (delete 'a (list 'a 'a 'a)) '()))
	(test-t (equal (delete 'z (list 'a 'b 'c)) '(a b c)))
	(test-t (equal (delete 'a '()) '()))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count 0) '(a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count 1) '(b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) '(a b c b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count 2) '(b c b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) '(b c b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count 3) '(b c b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) '(b c b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count 4) '(b c b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) '(b c b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count -1) '(a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count -10) '(a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c) :count -100) '(a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) '(a b c b c b c b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) '(a b c b c b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) '(a b c b c b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) '(a b c b c b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) '(a b c a b c b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) '(a b c a b c a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) '(a b c a b c a b c a b c)))
	(test-t (equal (delete 'a (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) '(a b c a b c a b c a b c)))
	(test-t (equal (delete 'a (list '(a) '(b) '(c) '(a) '(b) '(c)) :key car) '((b) (c) (b) (c))))
	(test-t (equal (delete 'a (list '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) '((a . b) (b . c) (a . b) (b . c))))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal) '()))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1) '(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :from-end t) '(("Love") ("LOve") ("LOVe"))))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 2 :from-end t) '(("Love") ("LOve"))))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :start 1 :end 3) '(("Love") ("LOVe") ("LOVE"))))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :from-end t :start 1 :end 3) '(("Love") ("LOve") ("LOVE"))))
	(test-t (equal (delete "love" (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 10 :from-end t :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c)) #(b c b c)))
	(test-t (equalp (delete 'b (vector 'a 'b 'c 'a 'b 'c)) #(a c a c)))
	(test-t (equalp (delete 'c (vector 'a 'b 'c 'a 'b 'c)) #(a b a b)))
	(test-t (equalp (delete 'a (vector 'a 'a 'a)) #()))
	(test-t (equalp (delete 'z (vector 'a 'b 'c)) #(a b c)))
	(test-t (equalp (delete 'a #()) #()))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count 0) #(a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count 1) #(b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) #(a b c b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count 2) #(b c b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) #(b c b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count 3) #(b c b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) #(b c b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count 4) #(b c b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) #(b c b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count -1) #(a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count -10) #(a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c) :count -100) #(a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) #(a b c b c b c b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) #(a b c b c b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) #(a b c a b c b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete 'a (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete 'a (vector '(a) '(b) '(c) '(a) '(b) '(c)) :key car) #((b) (c) (b) (c))))
	(test-t (equalp (delete 'a (vector '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) #((a . b) (b . c) (a . b) (b . c))))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal) #()))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :start 1 :end 3) #(("Love") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 1 :from-end t :start 1 :end 3) #(("Love") ("LOve") ("LOVE"))))
	(test-t (equalp (delete "love" (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :test string-equal :count 10 :from-end t :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (string= (delete #\a (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (delete #\a (copy-seq "")) ""))
	(test-t (string= (delete #\a (copy-seq "xyz")) "xyz"))
	(test-t (string= (delete #\a (copy-seq "ABCABC")) "ABCABC"))
	(test-t (string= (delete #\a (copy-seq "ABCABC") :key char-downcase) "BCBC"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (delete #\b (copy-seq "abcabc")) "acac"))
	(test-t (string= (delete #\c (copy-seq "abcabc")) "abab"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 2) "bcbc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 2 :from-end t) "bcbc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 3) "bcbc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 3 :from-end t) "bcbc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 4) "bcbc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count 4 :from-end t) "bcbc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count -1) "abcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabc") :count -100) "abcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1) "abcbcbcbc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1 :count 1) "abcbcabcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1 :count 2) "abcbcbcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1 :end nil :count 2) "abcbcbcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1 :end 8) "abcbcbcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1) "abcbcabcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1 :from-end t) "abcabcbcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1 :end 8 :count 0 :from-end t) "abcabcabcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1 :end 8 :count -100 :from-end t) "abcabcabcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 1 :end 1) "abcabcabcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 2 :end 2) "abcabcabcabc"))
	(test-t (string= (delete #\a (copy-seq "abcabcabcabc") :start 12 :end 12) "abcabcabcabc"))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c)) '(b c b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'b)) (list 'a 'b 'c 'a 'b 'c)) '(a c a c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'c)) (list 'a 'b 'c 'a 'b 'c)) '(a b a b)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'a 'a)) '()))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'z)) (list 'a 'b 'c)) '(a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) '()) '()))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 0) '(a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 1) '(b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) '(a b c b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 2) '(b c b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) '(b c b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 3) '(b c b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) '(b c b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 4) '(b c b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) '(b c b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count -1) '(a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count -10) '(a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c) :count -100) '(a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) '(a b c b c b c b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) '(a b c b c b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) '(a b c b c b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) '(a b c b c b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) '(a b c a b c b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list '(a) '(b) '(c) '(a) '(b) '(c)) :key car) '((b) (c) (b) (c))))
	(test-t (equal (delete-if (lambda (arg) (eql arg 'a)) (list '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) '((a . b) (b . c) (a . b) (b . c))))
	(test-t (equal (delete-if (lambda (arg) (eql arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (delete-if (lambda (arg) (eql arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (delete-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '()))
	(test-t (equal (delete-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) '(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (delete-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) '(("Love") ("LOve") ("LOVe"))))
	(test-t (equal (delete-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) '(("Love") ("LOve"))))
	(test-t (equal (delete-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (equal (delete-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :start 1 :end 3) '(("Love") ("LOVe") ("LOVE"))))
	(test-t (equal (delete-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t :start 1 :end 3) '(("Love") ("LOve") ("LOVE"))))
	(test-t (equal (delete-if (lambda (arg) (string-equal arg "love")) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 10 :from-end t :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c)) #(b c b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'b)) (vector 'a 'b 'c 'a 'b 'c)) #(a c a c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'c)) (vector 'a 'b 'c 'a 'b 'c)) #(a b a b)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'a 'a)) #()))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'z)) (vector 'a 'b 'c)) #(a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) #()) #()))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 0) #(a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 1) #(b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) #(a b c b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 2) #(b c b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) #(b c b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 3) #(b c b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) #(b c b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 4) #(b c b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) #(b c b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count -1) #(a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count -10) #(a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c) :count -100) #(a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) #(a b c b c b c b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) #(a b c b c b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) #(a b c a b c b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector '(a) '(b) '(c) '(a) '(b) '(c)) :key car) #((b) (c) (b) (c))))
	(test-t (equalp (delete-if (lambda (arg) (eql arg 'a)) (vector '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) #((a . b) (b . c) (a . b) (b . c))))
	(test-t (equalp (delete-if (lambda (arg) (eql arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if (lambda (arg) (eql arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #()))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #()))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :start 1 :end 3) #(("Love") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t :start 1 :end 3) #(("Love") ("LOve") ("LOVE"))))
	(test-t (equalp (delete-if (lambda (arg) (string-equal arg "love")) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 10 :from-end t :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "")) ""))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "xyz")) "xyz"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "ABCABC") :key char-downcase) "BCBC"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\b)) (copy-seq "abcabc")) "acac"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\c)) (copy-seq "abcabc")) "abab"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 2) "bcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 2 :from-end t) "bcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 3) "bcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 3 :from-end t) "bcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 4) "bcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count 4 :from-end t) "bcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count -1) "abcabc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabc") :count -100) "abcabc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabcabcabc") :start 1) "abcbcbcbc"))
	(test-t (string= (delete-if (lambda (arg) (string-equal arg #\a)) (copy-seq "abcabcabcabc") :start 1 :count 1) "abcbcabcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :count 2) "abcbcbcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end nil :count 2) "abcbcbcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8) "abcbcbcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1) "abcbcabcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1 :from-end t) "abcabcbcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 0 :from-end t) "abcabcabcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 8 :count -100 :from-end t) "abcabcabcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 1 :end 1) "abcabcabcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 2 :end 2) "abcabcabcabc"))
	(test-t (string= (delete-if (lambda (arg) (eql arg #\a)) (copy-seq "abcabcabcabc") :start 12 :end 12) "abcabcabcabc"))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c)) '(b c b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'b))) (list 'a 'b 'c 'a 'b 'c)) '(a c a c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'c))) (list 'a 'b 'c 'a 'b 'c)) '(a b a b)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'a 'a)) '()))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'z))) (list 'a 'b 'c)) '(a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) '()) '()))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 0) '(a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 1) '(b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) '(a b c b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 2) '(b c b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) '(b c b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 3) '(b c b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) '(b c b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 4) '(b c b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) '(b c b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count -1) '(a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count -10) '(a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c) :count -100) '(a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) '(a b c b c b c b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) '(a b c b c b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) '(a b c b c b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) '(a b c b c b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) '(a b c b c a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) '(a b c a b c b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) '(a b c a b c a b c a b c)))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list '(a) '(b) '(c) '(a) '(b) '(c)) :key car) '((b) (c) (b) (c))))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg 'a))) (list '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) '((a . b) (b . c) (a . b) (b . c))))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (delete-if-not (lambda (arg) (not (eql arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) '(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) '()))
	(test-t (equal (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) '(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equal (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) '(("Love") ("LOve") ("LOVe"))))
	(test-t (equal (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) '(("Love") ("LOve"))))
	(test-t (equal (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (equal (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :start 1 :end 3) '(("Love") ("LOVe") ("LOVE"))))
	(test-t (equal (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t :start 1 :end 3) '(("Love") ("LOve") ("LOVE"))))
	(test-t (equal (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (list '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 10 :from-end t :start 1 :end 3) '(("Love") ("LOVE"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c)) #(b c b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'b))) (vector 'a 'b 'c 'a 'b 'c)) #(a c a c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'c))) (vector 'a 'b 'c 'a 'b 'c)) #(a b a b)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'a 'a)) #()))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'z))) (vector 'a 'b 'c)) #(a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) #()) #()))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 0) #(a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 1) #(b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 1 :from-end t) #(a b c b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 2) #(b c b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 2 :from-end t) #(b c b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 3) #(b c b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 3 :from-end t) #(b c b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 4) #(b c b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count 4 :from-end t) #(b c b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count -1) #(a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count -10) #(a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c) :count -100) #(a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1) #(a b c b c b c b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end nil :count 2) #(a b c b c b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8) #(a b c b c b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1) #(a b c b c a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 1 :from-end t) #(a b c a b c b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count 0 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 8 :count -100 :from-end t) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 1 :end 1) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 2 :end 2) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector 'a 'b 'c 'a 'b 'c 'a 'b 'c 'a 'b 'c) :start 12 :end 12) #(a b c a b c a b c a b c)))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector '(a) '(b) '(c) '(a) '(b) '(c)) :key car) #((b) (c) (b) (c))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg 'a))) (vector '(a . b) '(b . c) '(c . a) '(a . b) '(b . c) '(c . a)) :key cdr) #((a . b) (b . c) (a . b) (b . c))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (eql arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count -10) #(("Love") ("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #()))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car) #()))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1) #(("LOve") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t) #(("Love") ("LOve") ("LOVe"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 2 :from-end t) #(("Love") ("LOve"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :start 1 :end 3) #(("Love") ("LOVe") ("LOVE"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 1 :from-end t :start 1 :end 3) #(("Love") ("LOve") ("LOVE"))))
	(test-t (equalp (delete-if-not (lambda (arg) (not (string-equal arg "love"))) (vector '("Love") '("LOve") '("LOVe") '("LOVE")) :key car :count 10 :from-end t :start 1 :end 3) #(("Love") ("LOVE"))))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "")) ""))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "xyz")) "xyz"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "ABCABC") :key char-downcase) "BCBC"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc")) "bcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\b))) (copy-seq "abcabc")) "acac"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\c))) (copy-seq "abcabc")) "abab"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 0) "abcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 1) "bcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 1 :from-end t) "abcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 2) "bcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 2 :from-end t) "bcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 3) "bcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 3 :from-end t) "bcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 4) "bcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count 4 :from-end t) "bcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count -1) "abcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count -10) "abcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabc") :count -100) "abcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabcabcabc") :start 1) "abcbcbcbc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (string-equal arg #\a))) (copy-seq "abcabcabcabc") :start 1 :count 1) "abcbcabcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :count 2) "abcbcbcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end nil :count 2) "abcbcbcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8) "abcbcbcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1) "abcbcabcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 1 :from-end t) "abcabcbcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8 :count 0 :from-end t) "abcabcabcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 8 :count -100 :from-end t) "abcabcabcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 1 :end 1) "abcabcabcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 2 :end 2) "abcabcabcabc"))
	(test-t (string= (delete-if-not (lambda (arg) (not (eql arg #\a))) (copy-seq "abcabcabcabc") :start 12 :end 12) "abcabcabcabc"))
	(test-t (equal (remove-duplicates "aBcDAbCd" :test char-equal :from-end t) "aBcD"))
	(test-t (equal (remove-duplicates '(a b c b d d e)) '(a c b d e)))
	(test-t (equal (remove-duplicates '(a b c b d d e) :from-end t) '(a b c d e)))
	(test-t (let* ((list0 (list 0 1 2 3 4 5 6)) (list (delete-duplicates list0 :key oddp :start 1 :end 6))) (equal list '(0 4 5 6))))
	(test-t (let* ((list0 (list 2 1 0 1 0 1 2)) (list (remove-duplicates list0))) (and (not (eq list0 list)) (equal list0 '(2 1 0 1 0 1 2)) (equal list '(0 1 2)))))
	(test-t (let* ((vector0 (vector 2 1 0 1 0 1 2)) (vector (remove-duplicates vector0))) (and (not (eq vector0 vector)) (equalp vector0 #(2 1 0 1 0 1 2)) (equalp vector #(0 1 2)))))
	(test-t (equal (remove-duplicates (list 0 1 2 2 3 3 3)) '(0 1 2 3)))
	(test-t (equal (remove-duplicates (list 0 0 0 2 0 1 1 2 2 2 1 1 1 1 2)) '(0 1 2)))
	(test-t (equal (remove-duplicates (list 'a 'a 'b 'c 'c)) '(a b c)))
	(test-t (equal (remove-duplicates (list 0 1 2)) '(0 1 2)))
	(test-t (equal (remove-duplicates (list 2 0 2 1 1 1 0 0 0 1 2)) '(0 1 2)))
	(test-t (equal (remove-duplicates (list)) '()))
	(test-t (equal (remove-duplicates (list '(x . 0) '(y . 1) '(z . 2) '(a . 0) '(b . 1) '(c . 2)) :key cdr) '((a . 0) (b . 1) (c . 2))))
	(test-t (equal (remove-duplicates (list '(x . 0) '(y . 1) '(z . 2) '(a . 0) '(b . 1) '(c . 2)) :key cdr :test (lambda (a b) (and (oddp a) (oddp b)))) '((x . 0) (z . 2) (a . 0) (b . 1) (c . 2))))
	(test-t (equal (remove-duplicates (list '(x . 0) '(y . 1) '(z . 2) '(a . 0) '(b . 1) '(c . 2)) :key cdr :test (lambda (a b) (and (evenp a) (evenp b)))) '((y . 1) (b . 1) (c . 2))))
	(test-t (equal (remove-duplicates (list 0 1 2 0 1 2 0 1 2 0 1 2) :start 3 :end 9) '(0 1 2 0 1 2 0 1 2)))
	(test-t (equal (remove-duplicates (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 6) '(1 . 7) '(2 . 8) '(0 . 9) '(1 . 10) '(2 . 11))) (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 6) '(1 . 7) '(2 . 8) '(0 . 9) '(1 . 10) '(2 . 11))))
	(test-t (equal (remove-duplicates (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 6) '(1 . 7) '(2 . 8) '(0 . 9) '(1 . 10) '(2 . 11)) :key car) '((0 . 9) (1 . 10) (2 . 11))))
	(test-t (equal (remove-duplicates (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 6) '(1 . 7) '(2 . 8) '(0 . 9) '(1 . 10) '(2 . 11)) :key car :from-end t) (list '(0 . 0) '(1 . 1) '(2 . 2))))
	(test-t (equal (remove-duplicates (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 6) '(1 . 7) '(2 . 8) '(0 . 9) '(1 . 10) '(2 . 11)) :start 3 :key car) (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 9) '(1 . 10) '(2 . 11))))
	(test-t (equal (remove-duplicates (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 6) '(1 . 7) '(2 . 8) '(0 . 9) '(1 . 10) '(2 . 11)) :start 3 :key car :from-end t) (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5))))
	(test-t (equal (remove-duplicates (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 6) '(1 . 7) '(2 . 8) '(0 . 9) '(1 . 10) '(2 . 11)) :start 3 :end nil :key car) (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 9) '(1 . 10) '(2 . 11))))
	(test-t (equal (remove-duplicates (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 6) '(1 . 7) '(2 . 8) '(0 . 9) '(1 . 10) '(2 . 11)) :start 3 :end 9 :key car) '((0 . 0) (1 . 1) (2 . 2) (0 . 6) (1 . 7) (2 . 8) (0 . 9) (1 . 10) (2 . 11))))
	(test-t (equal (remove-duplicates (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 6) '(1 . 7) '(2 . 8) '(0 . 9) '(1 . 10) '(2 . 11)) :start 3 :end 9 :key car :from-end t) (list '(0 . 0) '(1 . 1) '(2 . 2) '(0 . 3) '(1 . 4) '(2 . 5) '(0 . 9) '(1 . 10) '(2 . 11))))
	(test-t (equal (remove-duplicates (list "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday") :key length) (list "Tuesday" "Wednesday" "Saturday" "Sunday")))
	(test-t (equal (remove-duplicates (list "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday") :key (lambda (arg) (char arg 0)) :test char=) (list "Monday" "Wednesday" "Thursday" "Friday" "Sunday")))
	(test-t (equal (remove-duplicates (list #\a #\b #\c #\A #\B #\C) :key char-upcase) '(#\A #\B #\C)))
	(test-t (equal (remove-duplicates (list #\a #\b #\c #\A #\B #\C) :key char-upcase :from-end t) '(#\a #\b #\c)))
	(test-t (equal (remove-duplicates (list #\a #\b #\c #\A #\B #\C) :test char=) (list #\a #\b #\c #\A #\B #\C)))
	(test-t (equal (remove-duplicates (list #\a #\b #\c #\A #\B #\C) :test char-equal) (list #\A #\B #\C)))
	(test-t (equal (remove-duplicates (list #\a #\b #\c #\A #\B #\C) :test char-equal :from-end t) (list #\a #\b #\c)))
	(test-t (equal (remove-duplicates (list #\a #\1 #\b #\1 #\2 #\c #\0 #\A #\0 #\B #\C #\9) :key alpha-char-p) (list #\C #\9)))
	(test-t (equal (remove-duplicates (list #\a #\1 #\b #\1 #\2 #\c #\0 #\A #\0 #\B #\C #\9) :key alphanumericp) (list #\9)))
	(test-t (equal (remove-duplicates (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11))) (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11))))
	(test-t (equal (remove-duplicates (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11)) :key car) (list '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11))))
	(test-t (equal (remove-duplicates (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11)) :key car :start 3 :end 9) (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11))))
	(test-t (equal (remove-duplicates (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11)) :key car :start 3 :end 9 :test char-equal) (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11))))
	(test-t (equal (remove-duplicates (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11)) :key car :start 3 :end 9 :test char-equal :from-end t) (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\a . 9) '(#\B . 10) '(#\c . 11))))
	(test-t (equal (remove-duplicates (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11)) :key car :start 3) (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11))))
	(test-t (equal (remove-duplicates (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11)) :key car :start 3 :end nil) (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11))))
	(test-t (equal (remove-duplicates (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11)) :key car :start 3 :from-end t) (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8))))
	(test-t (equal (remove-duplicates (list '(#\A . 0) '(#\b . 1) '(#\C . 2) '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11)) :key car :end 9) (list '(#\a . 3) '(#\B . 4) '(#\c . 5) '(#\A . 6) '(#\b . 7) '(#\C . 8) '(#\a . 9) '(#\B . 10) '(#\c . 11))))
	(test-t (equalp (remove-duplicates (vector 0 1 2 2 3 3 3)) #(0 1 2 3)))
	(test-t (equalp (remove-duplicates (vector 0 0 0 2 0 1 1 2 2 2 1 1 1 1 2)) #(0 1 2)))
	(test-t (equalp (remove-duplicates (vector 'a 'a 'b 'c 'c)) #(a b c)))
	(test-t (equalp (remove-duplicates (vector 0 1 2)) #(0 1 2)))
	(test-t (equalp (remove-duplicates (vector 2 0 2 1 1 1 0 0 0 1 2)) #(0 1 2)))
	(test-t (equalp (remove-duplicates (vector)) #()))
	(test-t (equalp (remove-duplicates (vector '(x . 0) '(y . 1) '(z . 2) '(a . 0) '(b . 1) '(c . 2)) :key cdr) #((a . 0) (b . 1) (c . 2))))
	(test-t (equalp (remove-duplicates (vector 0 1 2 0 1 2 0 1 2 0 1 2) :start 3 :end 9) #(0 1 2 0 1 2 0 1 2)))
	(test-t (equalp (remove-duplicates (vector "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday") :key length) (vector "Tuesday" "Wednesday" "Saturday" "Sunday")))
	(test-t (equalp (remove-duplicates (vector #\a #\b #\c #\A #\B #\C) :key char-upcase) #(#\A #\B #\C)))
	(test-t (equalp (remove-duplicates (vector #\a #\b #\c #\A #\B #\C) :key char-upcase :from-end t) #(#\a #\b #\c)))
	(test-t (equalp (remove-duplicates (vector #\a #\b #\c #\A #\B #\C) :test char=) (vector #\a #\b #\c #\A #\B #\C)))
	(test-t (equalp (remove-duplicates (vector #\a #\b #\c #\A #\B #\C) :test char-equal) (vector #\A #\B #\C)))
	(test-t (equalp (remove-duplicates (vector #\a #\b #\c #\A #\B #\C) :test char-equal :from-end t) (vector #\a #\b #\c)))
	(test-t (equalp (remove-duplicates (vector #\a #\1 #\b #\1 #\2 #\c #\0 #\A #\0 #\B #\C #\9) :key alpha-char-p) (vector #\C #\9)))
	(test-t (equalp (remove-duplicates (vector #\a #\1 #\b #\1 #\2 #\c #\0 #\A #\0 #\B #\C #\9) :key alphanumericp) (vector #\9)))
	(test-t (string= (remove-duplicates (copy-seq "")) ""))
	(test-t (string= (remove-duplicates (copy-seq "abc")) "abc"))
	(test-t (string= (remove-duplicates (copy-seq "abcabc")) "abc"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabc")) "abc"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabc") :from-end t) "cba"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA")) "abcCBA"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :from-end t) "cbaABC"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :key char-downcase) "CBA"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :key char-downcase :from-end t) "cba"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :start 3) "cbaabcCBA"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :start 3 :from-end t) "cbaabcABC"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :start 3 :end 9) "cbaabcABCCBA"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :start 3 :end 9 :key char-upcase) "cbaABCCBA"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :start 3 :end 9 :key char-upcase :from-end t) "cbaabcCBA"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :start 3 :end 9 :test char-equal :from-end t) "cbaabcCBA"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :start 3 :end 9 :key upper-case-p :test eq) "cbacCCBA"))
	(test-t (string= (remove-duplicates (copy-seq "cbaabcABCCBA") :start 3 :end 9 :key upper-case-p :test eq :from-end t) "cbaaACBA"))
	
	;;	
	;; ----------------------------------- end sacla --------------------------------------------- 
	;; 
	
	(let ((boole-n-vector
	       (vector boole-clr   boole-and  boole-andc1 boole-2
		       boole-andc2 boole-1    boole-xor   boole-ior
		       boole-nor   boole-eqv  boole-c1    boole-orc1
		       boole-c2    boole-orc2 boole-nand  boole-set)))
	  (do ((n 0 (+ n 1)))
	      ((= n 16))
	    (if (not (= n (logand (boole (boole-n-vector n) #b0101 #b0011) #b1111)))
		(format #t "~A: ~A ~A~%" n (boole-n-vector n) (logand (boole (boole-n-vector n) #b0101 #b0011) #b1111))))
	  (let ((lst '()))
	    (do ((n #b0000 (+ n 1)))
		((> n #b1111))
	      (set! lst (cons (boole (boole-n-vector n) 5 3) lst)))
	    (if (not (equal? (reverse lst)
			     (list 0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)))
		(format #t ";boole: ~A~%" (reverse lst)))))
	
	(test (digit-char-p #\a) #f)
	(test (digit-char-p #\a 16) 10)
	(test (let ((v (vector 1 2 3 4 5))) (cl-fill v 32 :start 2 :end 3)) '#(1 2 32 4 5))
	(test (let ((v (vector 1 2 3 4 5))) (cl-fill v 32 :start 2)) '#(1 2 32 32 32))
	(test (let ((v (vector 1 2 3))) (cl-fill v 32)) '#(32 32 32))
	(test (let ((lst (list 1 2 3))) (cl-fill lst "hi")) '("hi" "hi" "hi"))
	(test (some zero? '(1 2 3)) #f)
	(test (some zero? '(1 0 3)) #t)
	(test (some (lambda args (apply > args)) #(1 2 3) #(2 3 4)) #f)
	(test (some (lambda args (apply > args)) #(1 2 3) #(2 3 1)) #t)
	(test (some (lambda (a) (and (positive? a) a)) '(0 -3 1 2)) 1)
	(test (notany zero? '(1 2 3)) #t)
	(test (notany zero? '(1 0 3)) #f)
	(test (notany (lambda args (apply > args)) #(1 2 3) #(2 3 4)) #t)
	(test (notany (lambda args (apply > args)) #(1 2 3) #(2 3 1)) #f)
	(test (notany (lambda (a) (and (positive? a) a)) '(0 -3 1 2)) #f)
	(test (every zero? '(1 2 3)) #f)
	(test (every zero? '(0 0)) #t)
	(test (every (lambda args (apply < args)) #(1 2 3) #(2 3 4)) #t)
	(test (every (lambda args (apply < args)) #(1 2 3) #(2 3 1)) #f)
	(test (notevery zero? '(1 2 3)) #t)
	(test (notevery zero? '(0 0)) #f)
	(test (notevery (lambda args (apply < args)) #(1 2 3) #(2 3 4)) #f)
	(test (notevery (lambda args (apply < args)) #(1 2 3) #(2 3 1)) #t)
	(test ((complement >) 1 2 3) #t)
	(test (cl-abs -1) 1)
	(test (cl-abs 1.0) 1.0)
	(test (cl-abs 1+i) (magnitude 1+i))
	(test (signum 3) 1)
	(test (signum 0) 0)
	(test (signum -3) -1)
	(test (signum 3.0) 1.0)
	(test (isqrt 12) 3)
	(test (1+ 1) 2)
	(test (1- 1) 0)
	(test (/= 0 0) #f)
	(test (/= 1 2 3) #t)
	(test (/= 3 45 3) #f)
	(test (zerop 0) #t)
	(test (zerop 1) #f)
	(test (minusp -1) #t)
	(test (minusp 1) #f)
	(test (plusp 1) #t)
	(test (plusp -1) #f)
	(test (oddp 3) #t)
	(test (oddp 4) #f)
	(test (evenp 3) #f)
	(test (evenp 4) #t)
	(test (conjugate 1+i) 1-i)
	(test (conjugate 3.7) 3.7)
	(test (ldb (byte 8 8) #x123) 1)
	(test (ldb (byte 8 0) #x123) #x23)
	(test (ldb (byte 4 4) #x123) 2)
	(test (ldb (byte 1 4) #x123) 0)
	(test (ldb (byte 1 5) #x123) 1)
	(test (ldb (byte 16 16) -1) 65535)
	(test (ldb (byte 12 18) #x12345678) 1165)
	(test (dpb 1 (byte 8 0) #x100) #x101)
	(test (dpb #x22 (byte 8 1) #x100) #x44) ;!
	(test (dpb #x22 (byte 8 8) #x100) #x2200) ; not #x2300
	(test (dpb #x1001 (byte 16 0) -1) -61439)
	(test (dpb #x1 (byte 8 8) #xffffff) #xff01ff)
	(test (dpb #x1 (byte 8 16) #xffffff) #x1ffff)	
	(test (dpb #x1 (byte 8 16) #xffffffff) #xff01ffff) 
	(test (dpb -1 (byte 8 0) 0) 255)
	(test (dpb -1 (byte 8 2) 0) 1020)
	(test (dpb 0 (byte 16 16) #xffffffff) 65535)
	(test (mask-field (byte 8 8) #xfffffff) #xff00)
	(test (mask-field (byte 1 8) #xfffffff) #x100)
	(test (ldb-test (byte 1 8) #xfffffff) #t)
	(test (ldb-test (byte 1 8) #x10ff) #f)
	(test (deposit-field #xabcdef (byte 8 8) 0) #xcd00)
	(test (deposit-field #xabcdef (byte 8 4) 0) #xde0)
	(test (deposit-field #xabcdef (byte 8 8) #xffffffff) #xffffcdff)
	(test (count-if zero? '(0 1 2 0)) 2)
	(test (count-if-not zero? '(0 1 2 0 3)) 3)
	(test (count-if zero? '#(0 1 2 0)) 2)
	(test (count-if zero? '((0 1) (1 0) (2 3) (0 1)) :key car) 2)
	(test (count-if zero? '(0 1 2 0) :from-end #t) 2)
	(test (count-if zero? '(0 1 2 0) :start 1) 1)
	(test (count-if zero? '(0 1 2 0) :start 1 :end 3) 0)
	(test (count-if zero? '(0 1 2 0) :end 3) 1)
	(test (count-if zero? '(0 1 2 0) :end 4) 2)
	(test (count-if zero? '(0 1 2 0) :end 4 :from-end #t) 2)
	(test (identity 1) 1)
	(test (stringp "hi") #t)
	(test (stringp #\h) #f)
	(test (characterp #\a) #t)
	(test (characterp "a") #f)
	(test (realp 1) #t)
	(test (realp 3.14) #t)
	(test (realp 1.0+i) #f)
	(test (complexp 1) #f)
	(test (complexp 1.0+i) #t)
	(test (floatp 1) #f)
	(test (floatp 3.14) #t)
	(test (rationalp 1) #t)
	(test (rationalp 1.12) #f)
	(test (rationalp 3/4) #t)
	(test (rationalp "hiho") #f)
	(test (integerp "hiho") #f)
	(test (integerp 3.14) #f)
	(test (integerp 3) #t)
	(test (numberp 3) #t)
	(test (numberp "hiho") #f)
	(test (consp '()) #f)
	(test (consp '(1 2)) #t)
	(test (consp 3) #f)
	(test (atom 3) #t)
	(test (atom '()) #t)
	(test (atom '(1 2 3)) #f)
	(test (vectorp '#(1 2 3)) #t)
	(test (vectorp "hiho") #f)
	(test (symbolp 'hi) #t)
	(test (symbolp "hiho") #f)
	(test (last '(1 2 3)) '(3))
	(test (last '()) '())
	(test (tree-equal '() '()) #t)
	(test (tree-equal (list 1 2 (list 3 5) 5) (list 1 2 (list 3 4) 5)) #f)
	(test (tree-equal (list 1 2 (list 3 4) 5) (list 1 2 (list 3 4) 5)) #t)
	(test (nthcdr 0 '(1 2 3)) '(1 2 3))
	(test (nthcdr 2 '(1 2 3)) '(3))
	(test (nthcdr 4 '(1 2 3)) '())
	(test (listp '()) #t)
	(test (listp 3) #f)
	(test (listp '(1 . 2)) #t)
	(test (listp (list 1 2)) #t)
	(test (null '()) #t)
	(test (null '(1 2 3)) #f)
	(test (butlast '(1 2 3 4)) '(1 2 3))
	(test (butlast '((1 2) (3 4))) '((1 2)))
	(test (butlast '(1)) '())
	(test (butlast '()) '())
	(test (copy-list '()) '())
	(test (copy-list '(1 2 3)) '(1 2 3))
	(test (copy-tree '(1 (2 3) 4)) '(1 (2 3) 4))
	(test (rest '(1 2 3)) '(2 3))
	(test (let ((i1 1) (i2 2)) (setf i1 3) (list i1 i2)) (list 3 2))
	(test (let ((i1 1) (i2 2)) (setf i1 123 i2 32) (list i1 i2)) (list 123 32))
	(test (let ((hi (vector 1 2 3))) (setf (hi 0) (+ 1 2) (hi 2) (* 2 3)) hi) (vector 3 2 6))
	(test (let ((val 0)) (progn (+ val 1))) 1)
	(test (let ((val 0)) (prog1 (+ val 1) (+ val 2))) 1)
	(test (let ((val 0)) (prog2 (+ val 1) (+ val 2) (+ val 3))) 2)
	(test (let ((lst (list 1))) (push 2 lst)) (list 2 1))
	(test (let ((lst (list 1 2 3))) (list (pop lst) lst)) (list 1 (list 2 3)))
	(test (let ((x 0)) (incf x) x) 1)
	(test (let ((x 0)) (incf x 2) x) 2)	
	(test (let ((x 0)) (decf x) x) -1)
	(test (let ((x 0)) (decf x 2) x) -2)	
	(test (let ((lst (list 1 2))) (pushnew 1 lst)) (list 1 2))
	(test (let ((lst (list 1 2))) (pushnew 3 lst)) (list 3 1 2))
	(test (let ((a 1) (b 2)) (psetq a b b a) (list a b)) '(2 1))
	(test (let ((a 1) (b 2) (c 3)) (psetq a (+ b c) b (+ a c) c (+ a b)) (list a b c)) '(5 4 3))
	(test (let ((val #f)) (unless val 1)) 1)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (first val)) 1)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (second val)) 2)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (third val)) 3)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (fourth val)) 4)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (fifth val)) 5)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (sixth val)) 6)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (seventh val)) 7)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (eighth val)) 8)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (ninth val)) 9)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (tenth val)) 10)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (nth 7 val)) 8)
	(test (let ((val (list 1 2 3 4 5 6 7 8 9 10))) (nth 17 val)) '())
	
        (test (let*-values (((x) (values 1))) x) 1)
        (test (let*-values ((x (values 1))) x) '(1))
	(test (let*-values (((x) (values 1)) ((y) (values 2))) (list x y)) '(1 2))
	(test (let*-values (((x) (values 1)) ((y) (values (+ x 1)))) (list x y)) '(1 2))
	
	(test (let () (enum one two three) (list one two three)) '(0 1 2))
	
	(test (let () (defstruct x1 a b c) (let ((xx1 (make-x1 1 2 3))) (list (x1-a xx1) (x1-b xx1) (x1-c xx1) (x1? xx1)))) '(1 2 3 #t))
	(test (let () (defstruct x1 a (b "hi") (c 3/4)) (let ((xx1 (make-x1 1))) (list (x1-a xx1) (x1-b xx1) (x1-c xx1) (x1? xx1)))) '(1 "hi" 3/4 #t))
	(test (let () (defstruct x1 a (b "hi") (c 3/4)) (let ((xx1 (make-x1 :b 1))) (list (x1-a xx1) (x1-b xx1) (x1-c xx1) (x1? xx1)))) '(#f 1 3/4 #t))
	(test (let () (defstruct x1 a b c) (let ((xx1 (make-x1 1 2 3))) (set! (x1-a xx1) 32) (list (x1-a xx1) (x1-b xx1) (x1-c xx1)))) '(32 2 3))
	
	(let ()
	  (defstruct ship (x 0.0) (y 0.0 :type 'real))
	  (test (let ((s1 (make-ship 1.0 2.0)))
		  (let ((s2 (copy-ship s1)))
		    (list (ship-x s2) (ship-y s2))))
		'(1.0 2.0))
	  (test (let ((s3 (make-ship :y 1.0 :x 2.0)))
		  (list (ship-x s3) (ship-y s3)))
		'(2.0 1.0)))
	
	(let()
	  (defstruct ship1 x y)
	  (let ((s1 (make-ship1 "hi" (list 1 2 3))))
	    (let ((s2 (copy-ship1 s1)))
	      (test (list (ship1-x s2) (ship1-y s2)) '("hi" (1 2 3))))))
	
	(let ()
	  (defstruct ship2 (x 0.0) (y 1.0 :read-only #t))
	  (let ((s1 (make-ship2)))
	    (test (let ((tag (catch #t
				    (lambda ()
				      (set! (ship2-y s1) 123.0))
				    (lambda args (car args)))))
		    tag)
		  'syntax-error)
	    (set! (ship2-x s1) 123.0)
	    (test (ship2-x s1)  123.0)))
	
	(let ()
	  (defstruct (ship3 (:conc-name hi)) (x 0.0) (y 1.0 :read-only #t))
	  (let ((s1 (make-ship3 :x 3.0)))
	    (test (list (hi-x s1) (hi-y s1)) '(3.0 1.0))))
	
	(let ()
	  (defstruct (ship4 (:constructor new-ship)) (x 0.0) (y 1.0 :read-only #t))
	  (let ((s1 (new-ship 1.0 2.0)))
	    (test (list (ship4-x s1) (ship4-y s1)) '(1.0 2.0))))
	
	)
     ) ; end CL
