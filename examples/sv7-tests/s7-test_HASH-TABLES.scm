(let ((ht (make-hash-table)))
  (test (hash-table? ht) #t)
  (test (equal? ht ht) #t)
  (test (let () (hash-table-set! ht 'key 3.14) (hash-table-ref ht 'key)) 3.14)
  (test (let () (hash-table-set! ht "ky" 3.14) (hash-table-ref ht "ky")) 3.14)
  (test (let () (hash-table-set! ht 123 "hiho") (hash-table-ref ht 123)) "hiho")
  (test (let () (hash-table-set! ht 3.14 "hi") (hash-table-ref ht 3.14)) "hi")
  (test (let () (hash-table-set! ht pi "hiho") (hash-table-ref ht pi)) "hiho")
  (test (hash-table-ref ht "123") #f)
  (let ((ht1 (copy ht)))
    (test (hash-table? ht1) #t)
    (test (hash-table-iterator? ht1) #f)
    (test (hash-table-iterator? (make-hash-table-iterator ht1)) #t)
    (test (= (length ht) (length ht1)) #t)
    (test (equal? ht ht1) #t)
    (test (eq? ht ht) #t)
    (test (eqv? ht ht) #t)
    (set! (ht 'key) 32)
    (set! (ht1 'key) 123)
    (test (and (= (ht 'key) 32) (= (ht1 'key) 123)) #t)
    (set! (ht "key") 321)
    (test (ht "key") 321)
    (test (ht 'key) 32)
    (set! (ht 123) 43)
    (set! (ht "123") 45)
    (test (ht 123) 43)
    (test (ht "123") 45)
    (test (hash-table-set! ht "1" 1) 1)
    (test (set! (ht "2") 1) 1)
    (test (set! (hash-table-ref ht "3") 1) 1)
    (test (hash-table-ref ht "3") 1))
  (test (let () (set! (hash-table-ref ht 'key) 32) (hash-table-ref ht 'key)) 32)

  (for-each
   (lambda (arg)
     (test (let () (hash-table-set! ht 'key arg) (hash-table-ref ht 'key)) arg))
   (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2))))

(for-each
 (lambda (arg)
   (test (hash-table-iterator? arg) #f)
   (test (hash-table-set! arg 'key 32) 'error))
 (list "hi" '() -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))

(let ((ht1 (make-hash-table 31))
      (ht2 (make-hash-table 31)))
  (if (not (equal? ht1 ht2))
      (format #t ";ht1 and ht2 are empty, but not equal??~%"))

      ;; these 1st tests take advantage of s7's hashing function
  (hash-table-set! ht1 'abc 1)
  (hash-table-set! ht1 'abcabc 2)
  (hash-table-set! ht1 'abcabcabc 3)
  (hash-table-set! ht2 'abcabcabc 3)  
  (hash-table-set! ht2 'abcabc 2) 
  (hash-table-set! ht2 'abc 1)
  (if (not (equal? ht1 ht2))
      (format #t ";ht1 and ht2 have the same key value pairs, but are not equal??~%"))
  
  (set! ht2 (make-hash-table 31))
  (hash-table-set! ht2 'abc 1)
  (hash-table-set! ht2 'abcabc 2) 
  (hash-table-set! ht2 'abcabcabc 3)  
  (if (not (equal? ht1 ht2))
      (format #t ";ht1 and ht2 have the same key value pairs in the same order, but are not equal??~%"))
  
  (hash-table-set! ht2 'abc "1")
  (if (equal? ht1 ht2) 
      (format #t ";ht1 and ht2 are equal but values are not~%"))
  (hash-table-set! ht2 'abc 1)
  (if (not (equal? ht1 ht2))
      (format #t ";after reset ht1 and ht2 have the same key value pairs in the same order, but are not equal??~%"))
  (hash-table-set! ht2 1 'abc)
  (if (equal? ht1 ht2)
      (format #t ";ht1 and ht2 are equal but entries are not~%"))
  (hash-table-set! ht1 1 'abc)
  (if (not (equal? ht1 ht2))
      (format #t ";after add ht1 and ht2 have the same key value pairs, but are not equal??~%"))

      ;; these should force chaining in any case
  (set! ht1 (make-hash-table 31))
  (set! ht2 (make-hash-table 60))
  (do ((i 0 (+ i 1)))
      ((= i 100))
    (hash-table-set! ht1 i (* i 2))
    (hash-table-set! ht2 i (* i 2)))
  (if (not (equal? ht1 ht2))
      (format #t ";ht1 and ht2 have the same (integer) key value pairs in the same order, but are not equal??~%"))
  
  (set! ht2 (make-hash-table 31))
  (do ((i 99 (- i 1)))
      ((< i 0))
    (hash-table-set! ht2 i (* i 2)))
  (if (not (equal? ht1 ht2))
      (format #t ";ht1 and ht2 have the same (integer) key value pairs, but are not equal??~%"))
  
  (fill! ht1 '())
  (set! ht2 (make-hash-table))
  (if (not (equal? ht1 ht2))
      (format #t ";ht1 and ht2 are now empty, but not equal??~%")))

(let ((ht (make-hash-table))
      (l1 '(x y z))
      (l2 '(y x z)))
  (set! (hash-table-ref ht 'x) 123)
  (define (hi)
    (hash-table-ref ht (cadr l1))) ; 123
  (test (hi) #f))

(test (make-hash-table most-positive-fixnum) 'error)
(test (make-hash-table (+ 1 (expt 2 31))) 'error)
(test (make-hash-table most-negative-fixnum) 'error)

(let ((hi (make-hash-table 7)))
  (test (object->string hi) "#<hash-table>")
  (set! (hi 1) "1")
  (test (object->string hi) "#<hash-table (1 . \"1\")>")
  (set! (hi -1) "-1")
  (test (object->string hi) "#<hash-table (-1 . \"-1\") (1 . \"1\")>")
  (set! (hi 9) "9")
  (test (object->string hi) "#<hash-table (9 . \"9\") (-1 . \"-1\") (1 . \"1\")>")
  (set! (hi -9) "-9")
  (test (object->string hi) "#<hash-table (-9 . \"-9\") (9 . \"9\") (-1 . \"-1\") (1 . \"1\")>")
  (test (hi 1) "1")
  (test (hi -9) "-9")
  (set! (hi 2) "2")
  (test (object->string hi) "#<hash-table (-9 . \"-9\") (9 . \"9\") (-1 . \"-1\") (1 . \"1\") (2 . \"2\")>")

  (let ((old-plen *vector-print-length*))
    (set! *vector-print-length* 3)
    (test (object->string hi) "#<hash-table (-9 . \"-9\") (9 . \"9\") (-1 . \"-1\") ...>")
    (set! *vector-print-length* 0)
    (test (object->string hi) "#<hash-table ...>")
    (test (object->string (hash-table)) "#<hash-table>")
    (set! *vector-print-length* old-plen))
  )

(let ((ht (make-hash-table 277)))
  (test (hash-table? ht) #t)
  (test (>= (hash-table-size ht) 277) #t)
  (test (let () (hash-table-set! ht 'key 3.14) (hash-table-ref ht 'key)) 3.14)
  (test (let () (hash-table-set! ht "ky" 3.14) (hash-table-ref ht "ky")) 3.14)
  (for-each
   (lambda (arg)
     (test (let () (hash-table-set! ht 'key arg) (hash-table-ref ht 'key)) arg))
   (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2))))

(for-each
 (lambda (arg)
   (test (hash-table? arg) #f))
 (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t #f '() '#(()) (list 1 2 3) '(1 . 2)))

(test (hash-table? (make-vector 3 '())) #f)
(test (let ((ht (make-hash-table))) (set! (ht 'a) 123) (map values ht)) '((a . 123)))

(let ((ht (make-hash-table)))	
  (test (hash-table-ref ht 'not-a-key) #f)
  (test (hash-table-ref ht "not-a-key") #f)
  (hash-table-set! ht 'key 3/4)
  (hash-table-set! ht "key" "hi")
  (test (hash-table-ref ht "key") "hi")
  (test (hash-table-ref ht 'key) 3/4)
  
  (hash-table-set! ht 'asd 'hiho)
  (test (hash-table-ref ht 'asd) 'hiho)
  (hash-table-set! ht 'asd 1234)
  (test (hash-table-ref ht 'asd) 1234))

(let ((ht (make-hash-table)))
  (define (ht-add h)
    (+ (h 1) (h 2)))
  (hash-table-set! ht 1 2)
  (hash-table-set! ht 2 3)
  (test (ht-add ht) 5))

(for-each
 (lambda (arg)
   (test (hash-table-ref arg 'key) 'error))
 (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))

(let ((ht1 (make-hash-table 653))
      (ht2 (make-hash-table 277)))
  (test (equal? ht1 ht2) #t) ; equal? because both are empty
  (hash-table-set! ht1 'key 'hiho)
  (hash-table-set! ht2 (hash-table-ref ht1 'key) 3.14)
  (test (>= (hash-table-size ht1) 653) #t)
  (test (hash-table-ref ht2 'hiho) 3.14)
  (test (hash-table-ref ht2 (hash-table-ref ht1 'key)) 3.14))

(let ((ht1 (make-hash-table)))
   (set! (ht1 1) 'hi)
   (let ((ht2 (make-hash-table)))
      (set! (ht2 1) ht1)
      (test ((ht2 1) 1) 'hi)))

(let ((ht1 (make-hash-table)))
   (set! (ht1 1/0) "NaN!")
   (let ((nan 1/0))
      (test (ht1 nan) "NaN!")
      (set! (ht1 nan) 0)
      (test (ht1 nan) 0)
      (test (object->string ht1) "#<hash-table (nan.0 . 0)>")))

(if (not with-bignums)
    (begin
      (let ((ht1 (make-hash-table)))
	(set! (ht1 1.0) "1.0")
	(let ((eps 9e-16)
	      (bigeps 1e-11))
	  (test (ht1 1.0) "1.0")
	  
	  (set! (ht1 (+ 1.0 eps)) "1.0+eps")
	  (test (ht1 1.0) "1.0+eps")
	  
	  (set! (ht1 (- 1.0 eps)) "1.0-eps")
	  (test (ht1 1.0) "1.0-eps")
	  
	  (set! (ht1 (+ 1.0 bigeps)) "1.0+bigeps")
	  (test (ht1 1.0) "1.0-eps")
	  
	  (set! (ht1 (- 1.0 bigeps)) "1.0-bigeps")
	  (test (ht1 1.0) "1.0-eps")
	  
	  (set! (ht1 1) "1")
	  (test (ht1 1) "1")
	  (test (ht1 1.0) "1.0-eps")
	  
	  (set! (ht1 1.0) "1.0")
	  (set! (ht1 (+ 1.0 eps)) "1.0")
	  (test (ht1 1.0) "1.0") 
	  
	  (set! (ht1 -1.0) "-1.0")
	  (test (ht1 -1.0) "-1.0")
	  
	  (set! (ht1 (+ -1.0 eps)) "-1.0+eps")
	  (test (ht1 -1.0) "-1.0+eps")
	  
	  (set! (ht1 (- -1.0 eps)) "-1.0-eps")
	  (test (ht1 -1.0) "-1.0-eps")
	  
	  (set! (ht1 (+ -1.0 bigeps)) "-1.0+bigeps")
	  (test (ht1 -1.0) "-1.0-eps")
	  
	  (set! (ht1 (- -1.0 bigeps)) "-1.0-bigeps")
	  (test (ht1 -1.0) "-1.0-eps")
	  
	  (set! (ht1 1) "-1")
	  (test (ht1 1) "-1")
	  (test (ht1 -1.0) "-1.0-eps")
	  
	  (set! (ht1 -1.0) "-1.0")
	  (set! (ht1 (+ -1.0 eps)) "-1.0")
	  (test (ht1 -1.0) "-1.0") 
	  
	  (set! (ht1 1+1e-200i) "1+noi")
	  (test (ht1 1+1e-200i) "1+noi")
	  (test (ht1 1.0) "1.0")
	  (test (ht1 1+1e-16i) "1+noi")
	  
	  (set! (ht1 1-1e-200i) "1-noi")
	  (test (ht1 1-1e-200i) "1-noi")
	  (test (ht1 1.0) "1.0")
	  
	  (set! (ht1 1e300) "1e300")
	  (test (ht1 1e300) "1e300")
	  
	  (set! (ht1 2e300) "2e300")
	  (test (ht1 2e300) "2e300")
	  (test (ht1 1e300) "1e300")
	  ))
      
      (let ((ht1 (make-hash-table)))
	(set! (ht1 1.0) "1.0")
	(set! (ht1 (+ 1.0 9e-16)) "1.0+eps")
	(set! (ht1 1) "1")
	(test (ht1 1.0) "1.0+eps")
	
	(set! (ht1 1.0) "1.0")
	(set! (ht1 (+ 1.0 9e-16)) "1.0+eps")
	(test (ht1 1.0) "1.0+eps")
	)
      
      (let ((ht1 (make-hash-table)))
	(set! (ht1 1) "1")
	(set! (ht1 1.0) "1.0")
	(test (ht1 1) "1")
	(set! (ht1 1/0) "nan")
	(test (ht1 0/0) "nan")
	(set! (ht1 (/ (log 0) (log 0))) "nan-nani")
	(test (ht1 (/ (log 0) (log 0))) "nan-nani")
	(test (ht1 (- 0/0)) "nan")
	(test (ht1 (real-part (/ (log 0) (log 0)))) "nan")
	(test (ht1 (make-rectangular 0/0 1/0)) "nan-nani")
	(set! (ht1 (real-part (log 0))) "-inf")
	(test (ht1 (real-part (log 0))) "-inf")
	(set! (ht1 (- (real-part (log 0)))) "inf")
	(test (ht1 (- (real-part (log 0)))) "inf")
	(set! (ht1 (log 0)) "log(0)")
	(test (ht1 (log 0)) "log(0)")
	(set! (ht1 (make-rectangular 80143857/25510582 1)) "pi+i")
	(test (ht1 (make-rectangular pi (- 1.0 1e-16))) "pi+i")
	)
      )) ; with bignums


(test (hash-table?) 'error)
(test (hash-table? 1 2) 'error)

(test (make-hash-table most-positive-fixnum) 'error)
(test (make-hash-table most-negative-fixnum) 'error)
(test (make-hash-table 10 1) 'error)

(let ((ht (make-hash-table)))
  (test (hash-table? ht ht) 'error)
  (test (hash-table-ref ht #\a #\b) 'error)
  (test (hash-table-ref ht) 'error)
  (test (hash-table-ref) 'error)
  (test (hash-table-set!) 'error)
  (test (hash-table-set! ht) 'error)
  (test (hash-table-set! ht #\a) 'error)
  (test (hash-table-set! ht #\a #\b #\c) 'error)
  (test (fill! ht 123) 'error)
  (set! (ht 'key) 32)
  (test (ht 'key) 32)
  (set! (ht :key) 123)
  (test (ht 'key) 32)
  (test (ht :key) 123)
  (fill! ht '())
  (test (ht 'key) #f))

(let ((ht (make-hash-table)))
  (test (hash-table-set! ht #\a 'key) 'key)
  (for-each
   (lambda (arg)
     (test (hash-table-set! ht arg 3.14) 3.14))
   (list #\a '#(1 2 3) 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))
  (for-each
   (lambda (arg)
     (test (hash-table-ref ht arg) 3.14))
   (list #\a '#(1 2 3) 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))
  (test (hash-table-size ht 123) 'error))

(for-each
 (lambda (arg)
   (test (hash-table-size arg) 'error))
 (list "hi" -1 0 #\a 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))
(test (hash-table-size) 'error)

(for-each
 (lambda (arg)
   (test (make-hash-table arg) 'error)
   (test (make-hash-table-iterator arg) 'error))
 (list "hi" -1 0 #\a 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t (list 1 2 3) '(1 . 2)))

(let ()
 (define ht (make-hash-table))
 (set! (ht 123) "123")
 (set! (ht 456) "456")
 (define hti (make-hash-table-iterator ht))
 (test (hash-table-iterator? hti) #t)
 (test (object->string hti) "#<hash-table-iterator>")
 (test (equal? hti hti) #t)
 (test (eq? hti hti) #t)
 (test (eqv? hti hti) #t)
 (test (morally-equal? hti hti) #t)

 (let ((hti2 hti))
   (test (equal? hti2 hti) #t)
   (test (morally-equal? hti2 hti) #t)
   (set! hti2 (copy hti))
   (test (equal? hti2 hti) #f)
   ;; (test (morally-equal? hti2 hti) #t)
   (test (let ((val (hti2))) (or (equal? val '(123 . "123")) (equal? val '(456 . "456")))) #t) ; order depends on table size
   )

 (let ((vals (list (hti) (hti))))
   (if (not (equal? (sort! vals (lambda (a b) (< (car a) (car b)))) '((123 . "123") (456 . "456"))))
       (format #t ";hash-table-iterator: ~A~%" vals))
   (let ((val (hti)))
     (if (not (null? val))
	 (format #t ";hash-table-iterator at end: ~A~%" val)))
   (let ((val (hti)))
     (if (not (null? val))
	 (format #t ";hash-table-iterator at end (2): ~A~%" val)))))

(test (make-hash-table-iterator) 'error)
(test (make-hash-table-iterator (make-hash-table) 1) 'error)
(test (hash-table-iterator?) 'error)
(test (hash-table-iterator? 1 2) 'error)

(let ((ht1 (make-hash-table))
      (ht2 (make-hash-table)))
  (test (equal? ht1 ht2) #t)
  (test (equal? ht1 (make-vector (hash-table-size ht1) '())) #f)
  (hash-table-set! ht1 'key 'hiho)
  (test (equal? ht1 ht2) #f)
  (hash-table-set! ht2 'key 'hiho)
  (test (equal? ht1 ht2) #t)

  (hash-table-set! ht1 'a '())
  (test (ht1 'a) '())
  )

(let ((ht (make-hash-table 1)))
  (test (>= (length ht) 1) #t)
  (set! (ht 1) 32)
  (test (>= (length ht) 1) #t))

(let ((ht (hash-table '("hi" . 32) '("ho" . 1))))
  (test (ht "hi") 32)
  (test (ht "ho") 1))

(let ((ht (hash-table)))
  (test (hash-table? ht) #t)
  (test (>= (length ht) 461) #t)
  (test (ht 1) #f))

(for-each
 (lambda (arg)
   (test (hash-table arg) 'error))
 (list "hi" -1 0 #\a 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #t abs #<eof> #<unspecified> (lambda () 1)))

(test (set! (hash-table) 1) 'error)
(test (set! (make-hash-table) 1) 'error)

;; no null hash-tables?

(let ((ht (make-hash-table)))
  ;; these are broken on purpose -- ht has no entries, so its lenth is 0, so we don't check arg nums etc
  (test (map (lambda (x) x) ht) '())
  (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) ht) ctr) 0)
  (test (map (lambda (x y) (cons x y)) (list 1 2 3) ht) '())
  (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) #(1 2 3) ht) ctr) 0)
  (test (map (lambda (x y) (cons x y)) ht "123") '())
  (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) ht '()) ctr) 0)

  (let ((rt (reverse ht)))
    (test (map (lambda (x) x) rt) '())
    (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) rt) ctr) 0))

  (set! (ht 1) 32)
  ;; these need to be independent of entry order
  
  (test (sort! (map (lambda (x) (cdr x)) ht) <) '(32))
  (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) ht) ctr) 1)
  (test (map (lambda (x y) (cons x y)) '() ht) '())
  (test (let ((ctr 0)) (for-each (lambda (x y) (set! ctr (+ ctr 1))) ht "") ctr) 0)
  (test (sort! (map (lambda (x y) (max (cdr x) y)) ht (list 1 2 3)) <) '(32))
  (test (let ((ctr 0)) (for-each (lambda (x y) (set! ctr (max (cdr x) y))) ht #(1 2 3)) ctr) 32)

  (let ((rt (reverse ht)))
    (test (equal? (rt 32) 1) #t)
    (test (equal? (rt 1) #f) #t)
    (test (ht (rt 32)) 32)
    (test (sort! (map (lambda (x) (cdr x)) rt) <) '(1))
    (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) rt) ctr) 1)
    (for-each (lambda (x) (test (ht (rt (cdr x))) (cdr x)) (test (rt (ht (car x))) (car x))) ht)
    (set! (rt 32) 123)
    (test (rt 32) 123)
    (test (ht 32) #f)
    (test (ht 1) 32))

  (set! (ht 2) 1)
  (test (ht (ht 2)) 32)
  (test (sort! (map (lambda (x) (cdr x)) ht) <) '(1 32))
  (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) ht) ctr) 2)
  (set! (ht 3) 123)
  (test (sort! (map (lambda (x) (cdr x)) ht) <) '(1 32 123))
  (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) ht) ctr) 3)
  (test (let ((ctr 0)) (for-each (lambda (x y) (set! ctr (+ ctr 1))) ht '(1)) ctr) 1)
  (test (let ((ctr 0)) (for-each (lambda (x y z) (set! ctr (+ ctr 1))) "12" ht '(1)) ctr) 1)
  (test (let ((ctr 0)) (for-each (lambda (x y z) (set! ctr (+ ctr 1))) "12" ht '(1 2)) ctr) 2)
  (test (let ((ctr 0)) (for-each (lambda (x y z) (set! ctr (+ ctr 1))) "12345" ht '(1 2 3 4 5 6)) ctr) 3)
  
  (test (sort! (map (lambda (x y) (max x (cdr y))) (list -1 -2 -3 -4) ht) <) '(1 32 123))
  (test (let ((sum 0)) (for-each (lambda (x y) (set! sum (+ sum x (cdr y)))) #(10 20 30) ht) sum) 216)
  
  (let ((rt (reverse ht)))
    (for-each (lambda (x) (test (ht (rt (cdr x))) (cdr x)) (test (rt (ht (car x))) (car x))) ht))
  
  (set! (ht (list 1 2 3)) "hi")
  (test (ht '(1 2 3)) "hi")
  (test (ht 2) 1)
  (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) ht) ctr) 4)
  (set! (ht "hi") 2)
  (test (ht "hi") 2)
  (test (ht (ht (ht "hi"))) 32)

  (let ((rt (reverse ht)))
    (test (rt "hi") '(1 2 3))
    (test (rt 2) "hi")
    (for-each (lambda (x) (test (ht (rt (cdr x))) (cdr x)) (test (rt (ht (car x))) (car x))) ht)
    (set! (rt 2) "ho")
    (test (rt 2) "ho")
    (test (ht '(1 2 3)) "hi")
    (set! (rt 123) 321)
    (test (rt 123) 321)
    (test (ht 3) 123))

  (fill! ht '())
  (set! (ht "hi") 1)
  (set! (ht "hoi") 2)
  (test (sort! (map (lambda (x) (cdr x)) ht) <) '(1 2))
  (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) ht) ctr) 2)
  
  (let ((rt (reverse ht)))
    (test (rt 2) "hoi")
    (set! (rt 2) "ha")
    (test (ht "hoi") 2))

  (set! (ht #\a) #\b)
  (test (ht #\a) #\b)
  (test (ht "hi") 1)

  (fill! ht '())
  (set! (ht #(1)) #(2))
  (test (ht #(1)) #(2))
  (set! (ht '(1)) '(3))
  (set! (ht "1") "4")
  (set! (ht ht) "5")
  (test (ht ht) "5")
  (test (ht '(1)) '(3))
  (test (let ((ctr 0)) (for-each (lambda (x) (set! ctr (+ ctr 1))) ht) ctr) 4)  
    
  (let ((rt (reverse ht)))
    (test (rt "5") ht)
    (for-each (lambda (x) (test (ht (rt (cdr x))) (cdr x)) (test (rt (ht (car x))) (car x))) ht))
  )  

(let ((ht1 (make-hash-table 32))
      (ht2 (make-hash-table 1024)))
  (do ((i 0 (+ i 1)))
      ((= i 256))
    (let ((str (number->string i)))
      (set! (ht1 str) i)
      (set! (ht2 i) str)))
  (let ((cases 0))
    (for-each
     (lambda (a b)
       (if (not (equal? (string->number (car a)) (cdr a)))
	   (format #t ";hash-table for-each (str . i): ~A?~%" a))
       (if (not (equal? (number->string (car b)) (cdr b)))
	   (format #t ";hash-table for-each (i . str): ~A?~%" b))
       (set! cases (+ cases 1)))
     ht1 ht2)
    (if (not (= cases 256))
	(format #t ";hash-table for-each cases: ~A~%" cases)))
  (let ((iter1 (make-hash-table-iterator ht1))
	(iter2 (make-hash-table-iterator ht2)))
    (test (equal? iter1 iter2) #f)
    (test (morally-equal? iter1 iter2) #f)
    (test (hash-table-iterator? iter2) #t)
    (let ((cases 0))
      (do ((a (iter1) (iter1))
	   (b (iter2) (iter2)))
	  ((or (null? a)
	       (null? b)))
	(if (not (equal? (string->number (car a)) (cdr a)))
	    (format #t ";hash-table iter1 (str . i): ~A?~%" a))
	(if (not (equal? (number->string (car b)) (cdr b)))
	    (format #t ";hash-table iter2 (i . str): ~A?~%" b))
	(set! cases (+ cases 1)))
      (if (not (= cases 256))
	  (format #t ";hash-table iter1/2 cases: ~A~%" cases)))))

(let ((ht (make-hash-table 31)))
  (let ((ht1 (make-hash-table 31)))
    (set! (ht1 'a1) 'b1)
    (set! (ht 'a0) ht1)
    (test ((ht 'a0) 'a1) 'b1)
    (test (hash-table-ref ht 'a0 'a1) 'b1)
    (test (ht 'a0 'a1) 'b1)))

(test (let ((h1 (hash-table '(a . 1) '(b . 2))) (h2 (make-hash-table 31))) (set! (h2 'a) 1) (set! (h2 'b) 2.0) (morally-equal? h1 h2)) #t)
(test (let ((h1 (hash-table '(a . 1) '(b . 2))) (h2 (make-hash-table 31))) (set! (h2 'a) 1.0) (set! (h2 'b) 2) (morally-equal? (list h1) (list h2))) #t)

(test (let ((ht (make-hash-table))) (hash-table-set! ht ht 1) (ht ht)) 1)
(test (let ((ht (make-hash-table))) (hash-table-set! ht ht ht) (equal? (ht ht) ht)) #t)

(test (let ((ht (make-hash-table))) (hash-table-set! ht 'a ht) (object->string ht)) "#1=#<hash-table (a . #1#)>")
(test (let ((h1 (make-hash-table))) (hash-table-set! h1 "hi" h1) (object->string h1)) "#1=#<hash-table (\"hi\" . #1#)>")
(test (let ((ht (make-hash-table))) (hash-table-set! ht 'a ht) (morally-equal? ht (copy ht))) #t)
(test (let ((ht (make-hash-table))) (hash-table-set! ht 'a ht) (equal? ht (copy ht))) #t)


;;; hash-table-index
(test (hash-table-index) 'error)
(test (hash-table-index 1 2) 'error)
(for-each
 (lambda (arg)
   (let ((b (hash-table-index arg)))
     (if (not (= b (hash-table-index arg)))
	 (format #t ";hash-table-index ~A: ~A ~A~%" arg b (hash-table-index arg)))))
  (list '() (list 1) '(1 . 2) #f #\a 'a-symbol (make-vector 3) abs _ht_ quasiquote macroexpand 1/0 (log 0) "" "hi" #() #(1 2) #<eof> #<unspecified> #<undefined>
       1 0 3.14 3/4 1.0+1.0i #t :hi))

(let ()
  (define (make-hash-list size)
    (make-vector size ()))
  
  (define (hash-list-set! lst id data)
    (let ((loc (modulo (hash-table-index id) (length lst))))
      (vector-set! lst loc (cons (cons id data) (vector-ref lst loc)))))
  
  (define (hash-list-ref lst id)
    (let ((loc (modulo (hash-table-index id) (length lst))))
      (assq id (vector-ref lst loc))))
  
  (define hash-list-branch copy)
  
  (define (hash-list-test)
    (let ((lst (make-hash-list 8)))
      (hash-list-set! lst 'a 1)
      (let ((aval (hash-list-ref lst 'a)))
	(if (not (equal? aval '(a . 1))) (format #t ";hash-list-ref 'a: ~A ~A~%" aval lst)))
      (if (hash-list-ref lst 'b) (format #t ";hash-list-ref 'b: ~A ~A~%" (hash-list-ref lst 'b) lst))
      (hash-list-set! lst 'b #t)
      (let ((aval (hash-list-ref lst 'a)))
	(if (not (equal? aval '(a . 1))) (format #t ";hash-list-ref 'a(b): ~A ~A~%" aval lst))
	(set! aval (hash-list-ref lst 'b))
	(if (not (equal? aval '(b . #t))) (format #t ";hash-list-ref 'b(a): ~A ~A~%" aval lst)))
      (let ((old-lst lst))
	(set! lst (hash-list-branch lst))
	(let ((aval (hash-list-ref lst 'a)))
	  (if (not (equal? aval '(a . 1))) (format #t ";hash-list-ref 'a(branched): ~A ~A~%" aval lst))
	  (hash-list-set! lst 'c 123)
	  (set! aval (hash-list-ref lst 'c))
	  (if (not (equal? aval '(c . 123))) (format #t ";hash-list-ref 'c: ~A ~A~%" aval lst))
	  (hash-list-set! lst 'a "hiho")
	  (set! aval (hash-list-ref lst 'a))
	  (if (not (equal? aval '(a . "hiho"))) (format #t ";hash-list-ref 'a(set): ~A ~A~%" aval lst)))
	(set! lst old-lst))
      (let ((aval (hash-list-ref lst 'a)))
	(if (not (equal? aval '(a . 1))) (format #t ";hash-list-ref 'a(restored): ~A ~A~%" aval lst))
	(set! aval (hash-list-ref lst 'b))
	(if (not (equal? aval '(b . #t))) (format #t ";hash-list-ref 'b(restored): ~A ~A~%" aval lst))
	(if (hash-list-ref lst 'c) (format #t ";hash-list-ref 'c(restored): ~A ~A~%" (hash-list-ref lst 'c) lst))
	lst)))
  
  (hash-list-test))

;; there's no real need for multidim hashes:

(let ((ht (make-hash-table)))
   (set! (ht (cons 'a 1)) 'b)
   (set! (ht (cons 'a 2)) 'c)
   (set! (ht (cons 'b 1)) 'd)
   (test (ht '(a . 1)) 'b)
   (test (ht '(b . 1)) 'd)
   (set! (ht '(a . 2)) 32)
   (test (ht '(a . 2)) 32))

(let ((ht (make-hash-table)))
  (set! (ht 1.0) 'a)
  (set! (ht 2.0) 'b)
  (set! (ht 3.0) 'c)
  (test (ht 2.0) 'b)
  (set! (ht 2.0) 'd)
  (test (ht 2.0) 'd)
  (test (ht 0.0) #f)
  (test (ht 1.0) 'a))

(let ((ht (make-hash-table)))
  (test (ht) 'error)
  (test (ht 0 1) 'error))

(let ()
  (define-macro (memoize f)
    `(define ,f (let ((ht (make-hash-table))
		      (old-f ,f))
		  (lambda args
		    (or (ht args)
			(let ((new-val (apply old-f args)))
			  (set! (ht args) new-val)
			  new-val))))))

  (define (our-abs num) (abs num))
  (memoize our-abs)
  (num-test (our-abs -1) 1)
  (with-environment (procedure-environment our-abs)
    (test (ht '(-1)) 1)))

(let ()
  (define-macro (define-memoized name&arg . body)
    (let ((arg (cadr name&arg))
	  (memo (gensym "memo")))
      `(define ,(car name&arg)
	 (let ((,memo (make-hash-table)))
	   (lambda (,arg)
	     (or (,memo ,arg)
		 (set! (,memo ,arg) (begin ,@body))))))))
  
  (define-memoized (f1 abc) (+ abc 2))
  (test (f1 3) 5)
  (test (f1 3) 5)
  (test (f1 2) 4)
  (let ((ht (call-with-exit
	     (lambda (return)
	       (for-each (lambda (x)
			   (if (hash-table? (cdr x))
			       (return (cdr x))))
			 (outer-environment (procedure-environment f1)))
	       #f))))
    (if (not (hash-table? ht))
	(format #t ";can't find memo? ~A~%" (environment->list (outer-environment (procedure-environment f1))))
	(test (length (map (lambda (x) x) ht)) 2))))

(let ()
  (define-macro (define-memoized name&args . body)
    (let ((args (cdr name&args))
	  (memo (gensym "memo")))
      `(define ,(car name&args)
	 (let ((,memo (make-hash-table)))
	   (lambda ,args
	     (or (,memo (list ,@args))
		 (set! (,memo (list ,@args)) (begin ,@body))))))))

  (define (ack m n)
    (cond ((= m 0) (+ n 1))
	  ((= n 0) (ack (- m 1) 1))
	  (else (ack (- m 1) (ack m (- n 1))))))

  (define-memoized (ack1 m n)
    (cond ((= m 0) (+ n 1))
	  ((= n 0) (ack1 (- m 1) 1))
	  (else (ack1 (- m 1) 
		      (ack1 m (- n 1))))))

  (test (ack 2 3) (ack1 2 3)))

 
(let ((ht (make-hash-table)))
  (test (eq? (car (catch #t (lambda () (set! (ht) 2)) (lambda args args))) 'wrong-number-of-args) #t)
  (test (eq? (car (catch #t (lambda () (set! (ht 0 0) 2)) (lambda args args))) 'wrong-number-of-args) #t)
  (test (eq? (car (catch #t (lambda () (set! ((ht 0) 0) 2)) (lambda args args))) 'syntax-error) #t))

(let ()
  (define (merge-hash-tables . tables)
    (apply hash-table (apply append (map (lambda (table) (map values table)) tables))))
  (let ((ht (merge-hash-tables (hash-table '(a . 1) '(b . 2)) (hash-table '(c . 3)))))
    (test (ht 'c) 3)))


;;; some implicit index tests

(test (#(#(1 2) #(3 4)) 1 1) 4)
(test (#("12" "34") 0 1) #\2)
(test (#((1 2) (3 4)) 1 0) 3)
(test (#((1 (2 3))) 0 1 0) 2)
(test ((vector (hash-table '(a . 1) '(b . 2))) 0 'a) 1)
(test ((list (lambda (x) x)) 0 "hi") "hi")
(test (let ((lst '("12" "34"))) (lst 0 1)) #\2)
(test (let ((lst (list #(1 2) #(3 4)))) (lst 0 1)) 2)
(test (#2d(("hi" "ho") ("ha" "hu")) 1 1 0) #\h)
(test ((list (lambda (a) (+ a 1)) (lambda (b) (* b 2))) 1 2) 4)
(test ((lambda (arg) arg) "hi" 0) 'error)

(let ((L1 (list 1 2 3))
      (V1 (vector 1 2 3))
      (M1 #2d((1 2 3) (4 5 6) (7 8 9)))
      (S1 "123")
      (H1 (hash-table '(1 . 1) '(2 . 2) '(3 . 3))))
  (let ((L2 (list L1 V1 M1 S1 H1))
	(V2 (vector L1 V1 M1 S1 H1))
	(H2 (hash-table (cons 0 L1) (cons 1 V1) (cons 2 M1) (cons 3 S1) (cons 4 H1)))
	(M2 (let ((v (make-vector '(3 3))))
	      (set! (v 0 0) L1)
	      (set! (v 0 1) V1)
	      (set! (v 0 2) M1)
	      (set! (v 1 0) S1)
	      (set! (v 1 1) H1)
	      (set! (v 1 2) L1)
	      (set! (v 2 0) S1)
	      (set! (v 2 1) H1)
	      (set! (v 2 2) L1)
	      v)))
#|
    (for-each
     (lambda (arg)
       (let* ((val (symbol->value arg))
	      (len (min 5 (length val))))
	 (do ((i 0 (+ i 1)))
	     ((= i len))
	   (format #t "(test (~S ~S) ~S)~%" arg i
		   (catch #t (lambda () (val i)) (lambda args 'error)))
	   (let ((len1 (catch #t (lambda () (min 5 (length (val i)))) (lambda args 0))))
	     (if (> len1 0)
		 (do ((k 0 (+ k 1)))
		     ((= k len1))
		   (format #t "(test (~S ~S ~S) ~S)~%" arg i k
			   (catch #t (lambda () (val i k)) (lambda args 'error)))
		   (let ((len2 (catch #t (lambda () (min 5 (length (val i k)))) (lambda args 0))))
		     (if (> len2 0)
			 (do ((m 0 (+ m 1)))
			     ((= m len2))
			   (format #t "(test (~S ~S ~S ~S) ~S)~%" arg i k m
				   (catch #t (lambda () (val i k m)) (lambda args 'error)))
			   (let ((len3 (catch #t (lambda () (min 5 (length (val i k m)))) (lambda args 0))))
			     (if (> len3 0)
				 (do ((n 0 (+ n 1)))
				     ((= n len3))
				   (format #t "(test (~S ~S ~S ~S ~S) ~S)~%" arg i k m n
					   (catch #t (lambda () (val i k m n)) (lambda args 'error)))))))))))))))
     (list 'L2 'V2 'M2 'H2))
|#

    (test (L2 0) '(1 2 3))
    (test (L2 0 0) 1)
    (test (L2 0 1) 2)
    (test (L2 0 2) 3)
    (test (L2 1) #(1 2 3))
    (test (L2 1 0) 1)
    (test (L2 1 1) 2)
    (test (L2 1 2) 3)
    (test (L2 2) #2D((1 2 3) (4 5 6) (7 8 9)))
    (test (L2 2 0) #(1 2 3))
    (test (L2 2 0 0) 1)
    (test (L2 2 0 1) 2)
    (test (L2 2 0 2) 3)
    (test (L2 2 1) #(4 5 6))
    (test (L2 2 1 0) 4)
    (test (L2 2 1 1) 5)
    (test (L2 2 1 2) 6)
    (test (L2 2 2) #(7 8 9))
    (test (L2 2 2 0) 7)
    (test (L2 2 2 1) 8)
    (test (L2 2 2 2) 9)
    (test (L2 2 3) 'error)
    (test (L2 2 4) 'error)
    (test (L2 3) "123")
    (test (L2 3 0) #\1)
    (test (L2 3 1) #\2)
    (test (L2 3 2) #\3)
    (test (L2 4) H1)
    (test (L2 4 0) #f)
    (test (L2 4 1) 1)
    (test (L2 4 2) 2)
    (test (L2 4 3) 3)
    (test (L2 4 4) #f)
    (test (V2 0) '(1 2 3))
    (test (V2 0 0) 1)
    (test (V2 0 1) 2)
    (test (V2 0 2) 3)
    (test (V2 1) #(1 2 3))
    (test (V2 1 0) 1)
    (test (V2 1 1) 2)
    (test (V2 1 2) 3)
    (test (V2 2) #2D((1 2 3) (4 5 6) (7 8 9)))
    (test (V2 2 0) #(1 2 3))
    (test (V2 2 0 0) 1)
    (test (V2 2 0 1) 2)
    (test (V2 2 0 2) 3)
    (test (V2 2 1) #(4 5 6))
    (test (V2 2 1 0) 4)
    (test (V2 2 1 1) 5)
    (test (V2 2 1 2) 6)
    (test (V2 2 2) #(7 8 9))
    (test (V2 2 2 0) 7)
    (test (V2 2 2 1) 8)
    (test (V2 2 2 2) 9)
    (test (V2 2 3) 'error)
    (test (V2 2 4) 'error)
    (test (V2 3) "123")
    (test (V2 3 0) #\1)
    (test (V2 3 1) #\2)
    (test (V2 3 2) #\3)
    (test (V2 4) H1)
    (test (V2 4 0) #f)
    (test (V2 4 1) 1)
    (test (V2 4 2) 2)
    (test (V2 4 3) 3)
    (test (V2 4 4) #f)
    (test (M2 0) #((1 2 3) #(1 2 3) #2D((1 2 3) (4 5 6) (7 8 9))))
    (test (M2 0 0) '(1 2 3))
    (test (M2 0 0 0) 1)
    (test (M2 0 0 1) 2)
    (test (M2 0 0 2) 3)
    (test (M2 0 1) #(1 2 3))
    (test (M2 0 1 0) 1)
    (test (M2 0 1 1) 2)
    (test (M2 0 1 2) 3)
    (test (M2 0 2) #2D((1 2 3) (4 5 6) (7 8 9)))
    (test (M2 0 2 0) #(1 2 3))
    (test (M2 0 2 0 0) 1)
    (test (M2 0 2 0 1) 2)
    (test (M2 0 2 0 2) 3)
    (test (M2 0 2 1) #(4 5 6))
    (test (M2 0 2 1 0) 4)
    (test (M2 0 2 1 1) 5)
    (test (M2 0 2 1 2) 6)
    (test (M2 0 2 2) #(7 8 9))
    (test (M2 0 2 2 0) 7)
    (test (M2 0 2 2 1) 8)
    (test (M2 0 2 2 2) 9)
    (test (M2 0 2 3) 'error)
    (test (M2 0 2 4) 'error)
    (test (M2 1) (vector "123" H1 '(1 2 3)))
    (test (M2 1 0) "123")
    (test (M2 1 0 0) #\1)
    (test (M2 1 0 1) #\2)
    (test (M2 1 0 2) #\3)
    (test (M2 1 1) H1)
    (test (M2 1 1 0) #f)
    (test (M2 1 1 1) 1)
    (test (M2 1 1 2) 2)
    (test (M2 1 1 3) 3)
    (test (M2 1 1 4) #f)
    (test (M2 1 2) '(1 2 3))
    (test (M2 1 2 0) 1)
    (test (M2 1 2 1) 2)
    (test (M2 1 2 2) 3)
    (test (M2 2) (vector "123" H1 '(1 2 3)))
    (test (M2 2 0) "123")
    (test (M2 2 0 0) #\1)
    (test (M2 2 0 1) #\2)
    (test (M2 2 0 2) #\3)
    (test (M2 2 1) H1)
    (test (M2 2 1 0) #f)
    (test (M2 2 1 1) 1)
    (test (M2 2 1 2) 2)
    (test (M2 2 1 3) 3)
    (test (M2 2 1 4) #f)
    (test (M2 2 2) '(1 2 3))
    (test (M2 2 2 0) 1)
    (test (M2 2 2 1) 2)
    (test (M2 2 2 2) 3)
    (test (M2 3) 'error)
    (test (M2 4) 'error)
    (test (H2 0) '(1 2 3))
    (test (H2 0 0) 1)
    (test (H2 0 1) 2)
    (test (H2 0 2) 3)
    (test (H2 1) #(1 2 3))
    (test (H2 1 0) 1)
    (test (H2 1 1) 2)
    (test (H2 1 2) 3)
    (test (H2 2) #2D((1 2 3) (4 5 6) (7 8 9)))
    (test (H2 2 0) #(1 2 3))
    (test (H2 2 0 0) 1)
    (test (H2 2 0 1) 2)
    (test (H2 2 0 2) 3)
    (test (H2 2 1) #(4 5 6))
    (test (H2 2 1 0) 4)
    (test (H2 2 1 1) 5)
    (test (H2 2 1 2) 6)
    (test (H2 2 2) #(7 8 9))
    (test (H2 2 2 0) 7)
    (test (H2 2 2 1) 8)
    (test (H2 2 2 2) 9)
    (test (H2 2 3) 'error)
    (test (H2 2 4) 'error)
    (test (H2 3) "123")
    (test (H2 3 0) #\1)
    (test (H2 3 1) #\2)
    (test (H2 3 2) #\3)
    (test (H2 4) H1)
    (test (H2 4 0) #f)
    (test (H2 4 1) 1)
    (test (H2 4 2) 2)
    (test (H2 4 3) 3)
    (test (H2 4 4) #f)
     ))

(let* ((L1 (cons 1 2))
       (L2 (list L1 3)))
  (test (L1 0) 1)
  (test (L1 1) 'error)
  (test (L1 2) 'error)
  (test (L2 0 0) 1)
  (test (L2 0 1) 'error)
  (test ((cons "123" 0) 0 1) #\2))

(let ((L1 (list "123" "456" "789")))
  (set-cdr! (cdr L1) L1)
  (test (L1 0 1) #\2)
  (test (L1 1 1) #\5)
  (test (L1 2 1) #\2)
  (test (L1 12 0) #\1))

(let ((L1 (list "123" "456" "789")))
  (set-car! (cdr L1) L1) 
  (test (L1 1 1 1 1 1 0 0) #\1))

(test ((list (list) "") 1 0) 'error)
(test ((list (list) "") 0 0) 'error)
(test (#(1 2) 0 0) 'error)
(test (#(1 #()) 1 0) 'error)

(test ('(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((12))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) 12)
