(test (not #f) #t)
(test (not #t) #f)
(test (not (not #t)) #t)
(test (not 0) #f)
(test (not 1) #f)
(test (not '()) #f)
(test (not 't) #f)
(test (not (list)) #f)
(test (not (list 3)) #f)
(test (not 'nil) #f)
(test (not not) #f)
(test (not "") #f)
(test (not lambda) #f)
(test (not quote) #f)

(for-each
 (lambda (arg)
   (if (not arg)
       (format #t ";(not ~A) -> #t?~%" arg)))
 (list "hi" (integer->char 65) 1 'a-symbol (make-vector 3) abs _ht_ quasiquote macroexpand 1/0 (log 0) 
       3.14 3/4 1.0+1.0i #\f (lambda (a) (+ a 1)) :hi #<eof> #<undefined> (if #f #f)))

(test (recompose 12 not #f) #f)

(test (not) 'error)
(test (not #f #t) 'error)
(test (not and) #f)
(test (not case) #f)

(let () ; check some optimizer branches
  (define (f1 sym) (not (symbol? sym))) (test (f1 'hi) #f) (test (f1 "hi") #t)  
  (define (f2 sym) (not (integer? sym))) (test (f2 2) #f) (test (f2 'hi) #t)
  (define (f3 sym) (not (char? sym))) (test (f3 2) #t) (test (f3 #\a) #f)
  (define (f4 sym) (not (list? sym))) (test (f4 2) #t) (test (f4 '(1 2 3)) #f)
  (define (f5 sym) (not (boolean? sym))) (test (f5 2) #t) (test (f5 #f) #f)
  (define (f6 sym) (not (eof-object? sym))) (test (f6 2) #t) (test (f6 #<eof>) #f)
  (define (f7 sym) (not (pair? (car sym)))) (test (f7 '(hi)) #t) (test (f7 '((1))) #f)
  (define (f8 sym) (not (eq? sym 'q))) (test (f8 'a) #t) (test (f8 'q) #f)
  (define (f9 sym) (pair? (cadr sym))) (test (f9 '(1 2 3)) #f) (test (f9 '(1 (2 3) 4)) #t)
  (define (f10 lst val) (eq? (car lst) val)) (test (f10 '(#f) #f) #t) (test (f10 '(a) 32) #f)
  (define (f11 lst) (eq? (caar lst) 'q)) (test (f11 '((a))) #f) (test (f11 '((q))) #t)
  (define (f12 lst) (= (length lst) 2)) (test (f12 '(1 2)) #t) (test (f12 '(1 2 3)) #f)
  (define (f13 lst) (< (length lst) 2)) (test (f13 '(1 2)) #f) (test (f13 '(1)) #t)
  (define (f14 lst) (negative? (length lst))) (test (f14 '(1 2)) #f) (test (f14 '(1 . 3)) #t)
  (define (f15 lst) (memq (car lst) '(a b c))) (test (f15 '(a)) '(a b c)) (test (f15 '(d)) #f)
  (define (f16 a b) (if a (begin (+ b a) (format #f "~A" a) (+ a a)))) (test (f16 1 2) 2)
  (define (f17 a) (aritable? a 1)) (test (f17 abs) #t)
  (define (f18) (set! (-s7-symbol-table-locked?) #f)) (f18) (test (f18) #f)
  (define (f18a) (set! (-s7-symbol-table-locked?) #f)) (test (f18a) #f) (test (let () (f18a)) #f)
  (define (f19) (set! (-s7-symbol-table-locked?) #f) 1) (f19) (test (f19) 1)
  (define (f19a) (set! (-s7-symbol-table-locked?) #f) 1) (test (f19a) 1) (test (let () (f19a)) 1)
  (define (f20) (set! (-s7-symbol-table-locked?) #f) (+ 1 2)) (f20) (test (f20) 3)
  (define (f20a) (set! (-s7-symbol-table-locked?) #f) (+ 1 2)) (test (f20a) 3) (test (let () (f20a)) 3)
  (define (f21) (set! (-s7-symbol-table-locked?) #f) (+ 1 2) 4) (f21) (test (f21) 4)
  (define (f21a) (set! (-s7-symbol-table-locked?) #f) (+ 1 2) 4) (test (f21a) 4) (test (let () (f21a)) 4)
  (define (f22) (begin (display ":") (display (object->string 2)) (display ":"))) (test (with-output-to-string (lambda () (f22))) ":2:")
  (define (f23 a b) (list a b))
  (define (f24 x y) (f23 (car x) (car y)))
  (define (f25 x y) (f23 (cdr x) (cdr y)))
  (test (f24 '(1 2) '(3 4)) '(1 3)) (test (f25 '(1 2) '(3 4)) '((2) (4)))
  (define (f24a s1 s2 s3) (+ (* s1 s2) (* (- 1.0 s1) s3))) (test (f24a 2.0 3.0 4.0) 2.0)
  (let () (define (a b) (define c 1) (+ b c)) (define (tst) (a 2)) (tst) (test (tst) 3))
  (define (f25) 
    (let ((x 0.0) (y 1.0)) 
      (call-with-exit 
       (lambda (return) 
	 (do ((i y (+ i 1))) ((= i 6)) 
	   (do ((i i (+ i 1))) ((>= i 7)) 
	     (set! x (+ x i)) 
	     (if (> x 123.0) (return x)))))) 
      x))
  (test (f25) 85.0)
  )
(let ()
  (test (let () (define (ho a) (+ a 2)) (define (hi) (+ (ho 1) (ho 2))) (hi)) 7)
  (test (let () (define (ho a) (+ a 2)) (define (hi) (+ (ho 1) (values 3 4))) (hi)) 10)
  (test (let () (define (ho a) (+ a 2)) (define (hi) (+ (values 3 4) (ho 1))) (hi)) 10)
  (test (let () (define (hi) (+ (values 1 2) (values 3 4))) (hi)) 10)
  (test (let () (define (ho a) (values a 1)) (define (hi) (- (ho 2))) (hi)) 1)
  (test (let () (define (ho1) (s7-version)) (define (ho2) (ho1)) (string? (ho2))) #t)
  (test (let () (define (hi) (vector 0)) (define (ho) (hi)) (ho)) #(0)))
(let ()
  (define (make-it . names) (apply vector names))
  (define (hi) (make-it pi pi pi pi))
  (test (hi) (vector pi pi pi pi)))
(test (let () (define (hi a b c d) (+ a (* (- b c) d))) (define (ho) (hi 1 2 3 4)) (ho)) -3)
(test (let () (define (hi a b c d) (+ a (* d (- b c)))) (define (ho) (hi 1 2 3 4)) (ho)) -3)
(test (let () (define (hi) (let ((x (values 1 2))) (if x (list x)))) (define (ho) (hi)) (catch #t (lambda () (ho)) (lambda args #f)) (ho)) 'error)
