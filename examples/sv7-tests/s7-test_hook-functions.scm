(for-each
 (lambda (arg)
   (test (set! *unbound-variable-hook* arg) 'error)
   (test (set! *load-hook* arg) 'error)
   
   (test (set! (hook-functions *unbound-variable-hook*) arg) 'error)
   (test (set! (hook-functions *error-hook*) arg) 'error)
   (test (set! (hook-functions *load-hook*) arg) 'error)
   
   (test (set! (hook-functions *unbound-variable-hook*) (list arg)) 'error)
   (test (set! (hook-functions *error-hook*) (list arg)) 'error)
   (test (set! (hook-functions *load-hook*) (list arg)) 'error)
   )
 (list -1 #\a '#(1 2 3) 3.14 3/4 1.0+1.0i 'hi :hi #<eof> #(1 2 3) '#(()) "hi" '(1 . 2) '(1 2 3)))

(let ((old-hook (hook-functions *unbound-variable-hook*))
      (hook-val #f))
  (set! (hook-functions *unbound-variable-hook*) 
	(list (lambda (hook) 
		(set! hook-val (hook 'variable)) 
		(set! (hook 'result) 123))))
  (let ((val (catch #t
		    (lambda ()
		      (+ 1 one-two-three))
		    (lambda args 'error))))
    (test val 124))
  (test (equal? one-two-three 123) #t)
  (test (equal? hook-val 'one-two-three) #t)
  (set! (hook-functions *unbound-variable-hook*) old-hook))

(let ((old-hook (hook-functions *unbound-variable-hook*)))
  (set! (hook-functions *unbound-variable-hook*) 
	(list (lambda (hook) 
		(set! (hook 'result) 32))))
  (let ((val (+ 1 _an_undefined_variable_i_hope_)))
    (test val 33))
  (let ((val (* _an_undefined_variable_i_hope_ _an_undefined_variable_i_hope_)))
    (test val 1024))
  (set! (hook-functions *unbound-variable-hook*) old-hook))

(let ((old-hook (hook-functions *unbound-variable-hook*)))
  (set! (hook-functions *unbound-variable-hook*) 
	(list (lambda (hook) 
		(if (eq? (hook 'variable) '__asdf__)
		    (set! (hook 'result) 32)
		    (set! (hook 'result) (+ 1 __asdf__))))))
  (let ((val (+ 1 _an_undefined_variable_i_hope_)))
    (set! (hook-functions *unbound-variable-hook*) old-hook)
    (test val 34)))

(let ((old-hook (hook-functions *unbound-variable-hook*))
      (x #f))
  (set! (hook-functions *unbound-variable-hook*) 
      (list 
       (lambda (hook)
	 (set! x 0)
	 (set! (hook 'result) #<undefined>))
       (lambda (hook) 
	 (set! (hook 'result) 32))
       (lambda (hook)
	 (if (not (number? (hook 'result)))
	     (format *stderr* "oops -- *unbound-variable-hook* func called incorrectly~%")))))
  (let ((val (+ 1 _an_undefined_variable_i_hope_)))
    (test val 33))
  (test x 0)
  (test (+ 1 _an_undefined_variable_i_hope_) 33)
  (set! (hook-functions *unbound-variable-hook*) old-hook))

(let ((old-load-hook (hook-functions *load-hook*))
      (val #f))
  (with-output-to-file "load-hook-test.scm"
    (lambda ()
      (format #t "(define (load-hook-test val) (+ val 1))")))
  (set! (hook-functions *load-hook*)
	(list (lambda (hook) 
		(if (or val
			(defined? 'load-hook-test))
		    (format #t ";*load-hook*: ~A ~A?~%" val load-hook-test))
		(set! val (hook 'name)))))
  (load "load-hook-test.scm")
  (if (or (not (string? val))
	  (not (string=? val "load-hook-test.scm")))
      (format #t ";*load-hook-test* file: ~S~%" val))
  (if (not (defined? 'load-hook-test))
      (format #t ";load-hook-test function not defined?~%")
      (if (not (= (load-hook-test 1) 2))
	  (format #t ";load-hook-test: ~A~%" (load-hook-test 1))))
  (set! (hook-functions *load-hook*) old-load-hook))

(let ((old-hook (hook-functions *error-hook*)))
  (set! (hook-functions *error-hook*) ())
  (test (hook-functions *error-hook*) ())
  (set! (hook-functions *error-hook*) (list (lambda (hook) #f)))
  (test (list? (hook-functions *error-hook*)) #t)
  (set! (hook-functions *error-hook*) ())
;  (set! *error-hook* (lambda (tag args) #f)) ; this no longer works (21-Sep-12)
;  (test (list? (hook-functions *error-hook*)) #t)
  (set! (hook-functions *error-hook*) old-hook))
  

(let ((h (make-hook 'x)))
  (test (procedure? h) #t)
  (test (procedure-arity h) '(0 1 #f)) ; apply lambda* to ('x)
  (test (eq? h h) #t)
  (test (eqv? h h) #t)
  (test (equal? h h) #t)
  (test (morally-equal? h h) #t)
  (let ((h1 (copy h)))
    (test (eq? h h1) #t)
    (test (morally-equal? h h1) #t))
  (test (hook-functions h) ())
  (test (h) #<unspecified>)
  (test (h 1) #<unspecified>)
  (test (h 1 2) 'error)
  (let ((f1 (lambda (hook) (set! (hook 'result) (hook 'x)))))
    (set! (hook-functions h) (list f1))
    (test (member f1 (hook-functions h)) (list f1))
    (test (hook-functions h) (list f1))
    (test (h 1) 1)
    (set! (hook-functions h) ())
    (test (hook-functions h) ())
    (let ((f2 (lambda* args (set! ((car args) 'result) ((car args) 'x)))))
      (set! (hook-functions h) (list f2))
      (test (hook-functions h) (list f2))
      (test (h 1) 1)))
  (for-each
   (lambda (arg)
     (test (set! (hook-functions h) arg) 'error))
   (list "hi" #f (integer->char 65) 1 (list 1 2) '#t '3 (make-vector 3) 3.14 3/4 1.0+1.0i #\f :hi #<eof> #<undefined> #<unspecified>)))

(let ((h (make-hook)))
  (test (procedure? h) #t)
  (test (procedure-arity h) '(0 0 #f))
  (test (procedure-documentation h) "")
  (test (hook-functions h) ())
  (test (h) #<unspecified>)
  (test (h 1) 'error)
  (let ((f1 (lambda (hook) (set! (hook 'result) 123))))
    (set! (hook-functions h) (list f1))
    (test (member f1 (hook-functions h)) (list f1))
    (test (hook-functions h) (list f1))
    (test (h) 123)
    (set! (hook-functions h) ())
    (test (hook-functions h) ())
    (let ((f2 (lambda* args (set! ((car args) 'result) 321))))
      (set! (hook-functions h) (list f2))
      (test (hook-functions h) (list f2))
      (test (h) 321))))

(let ((h (make-hook '(a 32) 'b)))
  (test (procedure? h) #t)
  (test (hook-functions h) ())
  (test (h) #<unspecified>)
  (test (h 1) #<unspecified>)
  (test (h 1 2) #<unspecified>)
  (test (h 1 2 3) 'error)
  (let ((f1 (lambda (hook) (set! (hook 'result) (+ (hook 'a) (or (hook 'b) 0))))))
    (set! (hook-functions h) (list f1))
    (test (member f1 (hook-functions h)) (list f1))
    (test (hook-functions h) (list f1))
    (test (h) 32)
    (test (h 1) 1)
    (test (h 1 2) 3)
    (set! (hook-functions h) ())
    (test (hook-functions h) ())))

(let ()
  (for-each
   (lambda (arg)
     (test (make-hook arg) 'error))
   (list "hi" #f 1 (list 1 2) '#t '3 (make-vector 3) 3.14 3/4 1.0+1.0i #\f :hi #<eof> #<undefined> #<unspecified>)))

(let ((h (make-hook)))
  (let ((f1 (lambda (hook) (if (number? (hook 'result)) (set! (hook 'result) (+ (hook 'result) 1)) (set! (hook 'result) 0)))))
    (test (h) #<unspecified>)
    (set! (hook-functions h) (list f1))
    (test (h) 0)
    (set! (hook-functions h) (list f1 f1 f1))
    (test (h) 2)))

(let ((h (make-hook '(x 0)))
      (end 0))
  (set! (hook-functions h)
	(list (lambda (hook)
		(if (not (integer? (hook 'x))) ; here hook = (procedure-environment h)
		    'oops
		    (set! (hook 'result) (+ (hook 'x) 1))))))

  (test (list (h 0) end) '(1 0))
  (test (h) 1)
  
  (set! ((procedure-environment h) 'init)
	(list (lambda (hook)
		(if (string? (hook 'x))
		    (set! (hook 'x) (string->number (hook 'x)))))))
  
  (test (h 0) 1)
  (test (h "0") 1)

  (set! ((procedure-environment h) 'end)
	(list (lambda (hook)
		(if (> (hook 'result) 1)
		    (set! end 1)))))

  (test (list (h 1) end) '(2 1))

  (set! ((procedure-environment h) 'init)
	(cons
	 (lambda (hook)
	   (if (symbol? (hook 'x))
	       (set! (hook 'x) 123)))
	 ((procedure-environment h) 'init)))

  (test (h 0) 1)
  (test (h "14") 15)
  (test (h 'a) 124))

(let ((hook-init-functions (make-procedure-with-setter
			    (lambda (hook)
			      ((procedure-environment hook) 'init))
			    (lambda (hook funcs)
			      (set! ((procedure-environment hook) 'init) funcs))))
      (hook-end-functions (make-procedure-with-setter
			    (lambda (hook)
			      ((procedure-environment hook) 'end))
			    (lambda (hook funcs)
			      (set! ((procedure-environment hook) 'end) funcs))))
      (hook-body-functions (make-procedure-with-setter
			    (lambda (hook)
			      ((procedure-environment hook) 'body))
			    (lambda (hook funcs)
			      (set! ((procedure-environment hook) 'body) funcs)))))

  (let ((h (make-hook 'x)))
    (let ((f1 (lambda (hook) (set! (hook 'result) (hook 'x)))))
      (test (hook-init-functions h) ())
      (test (hook-end-functions h) ())
      (test (hook-body-functions h) ())
      (test (hook-functions h) ())
      (test (h) #<unspecified>)
      (set! (hook-init-functions h) (list f1))
      (test (hook-init-functions h) (list f1))
      (test (h 32) 32)
      (test (h) #f)) ; that is, the default value of a lambda* arg
    (let ((f2 (lambda (hook) (if (number? (hook 'result)) (set! (hook 'result) (* 2 (hook 'result)))))))
      (set! (hook-end-functions h) (list f2))
      (test (hook-end-functions h) (list f2))
      (test (h) #f)
      (test (h 32) 32)) ; the end funcs happen after the result is saved for return
    (let ((endx 0))
      (set! (hook-end-functions h) ())
      (test (hook-end-functions h) ())
      (set! (hook-body-functions h) (list (lambda (hook) (set! (hook 'result) (* 2 (or (hook 'result) 1))))))
      (set! (hook-end-functions h) (list (lambda (hook) (set! endx (* 2 (hook 'result))))))
      (test (h 32) 64)
      (test endx 128)))

  (let ((h (make-hook)))
    (set! (hook-init-functions h) (list (lambda (hook) (augment-environment! hook (cons 'a-new-var 123)))))
    (set! (hook-body-functions h) (list (lambda (hook) (set! (hook 'result) (hook 'a-new-var)))))
    (test (h) 123)
    (set! (hook-init-functions h) ())
    (set! (hook-body-functions h) (list (lambda (hook) (set! (hook 'result) (hook 'a-new-var)))))
    (test (h) #<undefined>))

  (let ((h (make-hook)))
    (set! (hook-init-functions h) (list (lambda (hook) (augment-environment! (outer-environment (outer-environment hook)) (cons 'a-new-var 123)))))
    ;; tricky user could add a variable to every hook!
    (set! (hook-body-functions h) (list (lambda (hook) (set! (hook 'result) (hook 'a-new-var)))))
    (test (h) 123)
    (set! (hook-init-functions h) ())
    (set! (hook-body-functions h) (list (lambda (hook) (set! (hook 'result) (hook 'a-new-var)))))
    (test (h) 123))

  (let ((h (make-hook)))
    (test (defined? 'a-new-var (procedure-environment h)) #f))

  (test (defined? 'a-new-var) #f)

  (let* ((h (make-hook 'x))
	 (endx 0)
	 (val (call-with-exit
	       (lambda (return)
		 (set! (hook-body-functions h) 
		       (list (lambda (hook) 
			       (set! (hook 'result) (hook 'x))
			       (return 32)
			       (set! (hook 'result) -123))))
		 (set! (hook-end-functions h) 
		       (list (lambda (hook) 
			       (set! endx (* 2 (hook 'result))))))
		 (h 1)))))
    (test (list val endx) '(32 2)))
  )

(if (not (defined? 'hook-push))
    (define (hook-push hook func)
      (set! (hook-functions hook) (cons func (hook-functions hook)))))

(let ((h (make-hook)))
  (hook-push h (lambda (hook) (set! (hook 'result) 32)))
  (test (dynamic-wind h h h) 32)
  (test (catch h h h) 32)
  )

(let ((h (make-hook 'x)))
  (hook-push h (lambda (hook) (set! (hook 'result) (hook 'x))))
  (test (continuation? (call/cc h)) #t)
  (set! (hook-functions h) (list (lambda (hook) (set! (hook 'result) (+ 1 (hook 'x))))))
  (test (map h '(1 2 3)) '(2 3 4))
  )

(let ()
  (define-macro (hook . body)
    `(let ((h (make-hook)))
       (set! (hook-functions h) 
	     (list (lambda (h) 
		     (set! (h 'result) (begin ,@body)))))
       h)) 
  (let ((x 0))
    (define hi (hook (set! x 32) (+ 2 3 1)))
    (test (hi) 6)
    (test x 32)))

(let ()
  (define-macro (hooked-catch hook . body)
    `(catch #t 
       (lambda () 
	 ,@body) 
       (lambda args 
	 (let ((val (apply ,hook args)))
	   (if (eq? val #<unspecified>) ; hook did not do anything
	       (apply error args)       ; so re-raise the error
	       val)))))

 (let ((a-hook (make-hook 'error-type :rest 'error-info)))
   (set! (hook-functions a-hook)
         (list (lambda (hook) 
		 ;(format #t "hooked-catch: ~A~%" (apply format #t (car (hook 'error-info))))
		 (set! (hook 'result) 32))))
   (test (hooked-catch a-hook (abs "hi")) 32)
   
   (set! (hook-functions a-hook) ())

   (test (catch #t
	   (lambda ()
	     (hooked-catch a-hook (abs "hi")))
	   (lambda args
	     123))
	 123)
   ))
