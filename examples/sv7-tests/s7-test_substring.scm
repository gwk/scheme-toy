(test (substring "ab" 0 0) "")
(test (substring "ab" 1 1) "")
(test (substring "ab" 2 2) "")
(test (substring "ab" 0 1) "a")
(test (substring "ab" 1 2) "b")
(test (substring "ab" 0 2) "ab")
(test (substring "hi there" 3 6) "the")
(test (substring "hi there" 0 (string-length "hi there")) "hi there")
(test (substring "" 0 0) "")
(let ((str "012345"))
  (let ((str1 (substring str 2 4)))
    (string-set! str1 1 #\x)
    (test (string=? str "012345") #t)
    (let ((str2 (substring str1 1)))
      (set! (str2 0) #\z)
      (test (string=? str "012345") #t)
      (test (string=? str1 "2x") #t)
      (test (string=? str2 "z") #t))))
(test (substring (substring "hiho" 0 2) 1) "i")
(test (substring (substring "hiho" 0 2) 2) "")
(test (substring (substring "hiho" 0 2) 0 1) "h")
(test (substring "hi\nho" 3 5) "ho")
(test (substring (substring "hi\nho" 1 4) 2) "h")
(test (substring (substring "hi\nho" 3 5) 1 2) "o")
(test (substring "hi\"ho" 3 5) "ho")
(test (substring (substring "hi\"ho" 1 4) 2) "h")
(test (substring (substring "hi\"ho" 3 5) 1 2) "o")
(test (let* ((s1 "0123456789") (s2 (substring s1 1 3))) (string-set! s2 1 #\x) s1) "0123456789")
(test (substring (substring "" 0 0) 0 0) "")
(test (substring (format #f "") 0 0) "")
(test (string=? (substring (substring (substring "01234567" 1) 1) 1) "34567") #t)
(let ()
  (define (hi) (string=? (substring (substring (substring "01234567" 1) 1) 1) "34567"))
  (define (ho) (hi)) (ho)
  (test (ho) #t))

(test (substring "012" 3) "")
(test (substring "012" 10) 'error)
(test (substring "012" most-positive-fixnum) 'error)
(test (substring "012" -1) 'error)
(test (substring "012" 3 3) "")
(test (substring "012" 3 4) 'error)
(test (substring "012" 3 2) 'error)
(test (substring "012" 3 -2) 'error)
(test (substring "012" 3 0) 'error)
(test (substring "012" 0) "012")
(test (substring "012" 2) "2")
(test (substring "" 0) "")

(test (recompose 12 (lambda (a) (substring a 0 3)) "12345") "123")
(test (reinvert 12 (lambda (a) (substring a 0 3)) (lambda (a) (string-append a "45")) "12345") "12345")

(test (substring "ab" 0 3) 'error)
(test (substring "ab" 3 3) 'error)
(test (substring "ab" 2 3) 'error)
(test (substring "" 0 1) 'error)
(test (substring "" -1 0) 'error)
(test (substring "abc" -1 0) 'error)
(test (substring "hiho" (expt 2 32) (+ 2 (expt 2 32))) 'error)
(test (substring) 'error)
(test (substring "hiho" 0 1 2) 'error)
(test (substring "1234" -1 -1) 'error)
(test (substring "1234" 1 0) 'error)
(test (substring "" most-positive-fixnum 1) 'error)

(let ((str "0123456789"))
  (string-set! str 5 #\null)
  (test (substring str 6) "6789")
  (test (substring str 5 5) "")
  (test (substring str 4 5) "4")
  (test (substring str 5 6) "\x00")
  (test (substring str 5 7) "\x006")
  (test (substring str 4 7) "4\x006"))

(for-each
 (lambda (arg)
   (test (substring "hiho" arg 0) 'error))
 (list "hi" #\a 1 () (list 1) '(1 . 2) #f 'a-symbol (make-vector 3) abs _ht_ quasiquote macroexpand 1/0 (log 0) 
       3.14 3/4 1.0+1.0i #t :hi (if #f #f) (lambda (a) (+ a 1))))

(for-each
 (lambda (arg)
   (test (substring "0123" arg) 'error)
   (test (substring "hiho" 1 arg) 'error))
 (list "hi" #\a -1 '() (list 1) '(1 . 2) #f 'a-symbol (make-vector 3) abs _ht_ quasiquote macroexpand 1/0 (log 0) 
       3.14 3/4 1.0+1.0i #t :hi (if #f #f) (lambda (a) (+ a 1))))

(for-each
 (lambda (arg)
   (test (substring arg 1 2) 'error))
 (list #\a 1 () (list 1) '(1 . 2) #f 'a-symbol (make-vector 3) abs _ht_ quasiquote macroexpand 1/0 (log 0) 
       3.14 3/4 1.0+1.0i #t :hi (if #f #f) (lambda (a) (+ a 1))))

(define (substring? pattern target) ; taken from net somewhere (umich?) with changes for s7 (which now has string-position, so this is unneeded)
  (define (build-shift-vector pattern)
    (let* ((pat-len (length pattern))
	   (shift-vec (make-vector 256 (+ pat-len 1)))
	   (max-pat-index (- pat-len 1)))
      (let loop ((index 0))
	(set! (shift-vec (char->integer (pattern index))) (- pat-len index))
	(if (< index max-pat-index)
	    (loop (+ index 1))
	    shift-vec))))
  (if (or (not (string? pattern))
	  (not (string? target)))
      (error 'wrong-type-arg "substring? args should be strings: ~S ~S" pattern target)
      (let ((pat-len (length pattern)))
	(if (zero? pat-len)
	    0
	    (let ((shift-vec (build-shift-vector pattern)))
	      (let* ((tar-len (length target))
		     (max-tar-index (- tar-len 1))
		     (max-pat-index (- pat-len 1)))
		(let outer ((start-index 0))
		  (if (> (+ pat-len start-index) tar-len)
		      #f
		      (let inner ((p-ind 0) (t-ind start-index))
			(cond
			 ((> p-ind max-pat-index) #f)           ; nothing left to check
			 ((char=? (pattern p-ind) (target t-ind))
			  (if (= p-ind max-pat-index)
			      start-index                       ; success -- return start index of match
			      (inner (+ p-ind 1) (+ t-ind 1)))) ; keep checking
			 ((> (+ pat-len start-index) max-tar-index) #f) ; fail
			 (else (outer (+ start-index (shift-vec (char->integer (target (+ start-index pat-len)))))))))))))))))

(test (substring? "hiho" "test hiho test") 5)
(test (substring? "hiho" "test hihptest") #f)
(test (substring? "hiho" "test hih") #f)
(test (substring? "hiho" "") #f)
(test (substring? "hiho" "hiho") 0)
(test (substring? "" "hiho") 0)
(test (substring? "abc" 'abc) 'error)
