(test (do () (#t 1)) 1)
(for-each
 (lambda (arg)
   (test (do () (#t arg)) arg))
 (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #f #t (list 1 2 3) '(1 . 2)))

(for-each
 (lambda (arg)
   (test (do ((i arg)) (#t i)) arg))
 (list "hi" -1 #\a 1 'a-symbol '#(1 2 3) 3.14 3/4 1.0+1.0i #f #t (list 1 2 3) '(1 . 2)))

(test (do ((i 0 (+ i 1))) ((= i 3) #f)) #f)
(test (do ((i 0 (+ i 1))) ((= i 3) i)) 3)
(test (do ((i 1/2 (+ i 1/8))) ((= i 2) i)) 2)
(test (do ((i 1/2 (+ i 1/8))) ((> i 2) i)) 17/8)
(test (do ((vec (make-vector 5)) (i 0 (+ i 1))) ((= i 5) vec) (vector-set! vec i i)) '#(0 1 2 3 4))
(test (let ((x '(1 3 5 7 9))) (do ((x x (cdr x)) (sum 0 (+ sum (car x))))  ((null? x) sum))) 25)
(test (do ((i 4 (- i 1)) (a 1 (* a i))) ((zero? i) a)) 24)
(test (do ((i 2 (+ i 1))) ((> i 0) 123)) 123)

(test (do () (() ()) ()) '())
(test (do () ('() '())) '())
(test (do () ('())) '())
(test (do () (())) '())
(test (do) 'error)

(test (let ((x 0) (y 0)) (set! y (do () (#t (set! x 32) 123))) (list x y)) (list 32 123))
(test (let ((i 32)) (do ((i 0 (+ i 1)) (j i (+ j 1))) ((> j 33) i))) 2)
(test (let ((i 0)) (do () ((> i 1)) (set! i (+ i 1))) i) 2)
(test (let ((i 0) (j 0)) (do ((k #\a)) (#t i) (set! i (char->integer k)) (set! j (+ j i)))) 0)
(test (let ((i 0) (j 0)) (do ((k #\a)) ((> i 1) j) (set! i (char->integer k)) (set! j (+ j i)))) (char->integer #\a))
(test (let ((x 0)) (do ((i 0 (+ i 2)) (j 1 (* j 2))) ((= i 4) x) (set! x (+ x i j)))) 5)
(test (let ((sum 0)) (do ((lst '(1 2 3 4) (cdr lst))) ((null? lst) sum) (set! sum (+ sum (car lst))))) 10)
(test (do ((i 0 (+ 1 i))) ((= i 4) (do ((i 0 (+ i 2))) ((= i 10) i)))) 10)
(test (let ((i 0)) (do ((i 1 (+ i 1))) ((= i 3) i))) 3)
(test (let ((j 0)) (do ((i 0 (+ i 1))) ((= i 3) (+ i j)) (do ((j 0 (+ j i 1))) ((> j 3) j)))) 3)
(test (let ((add1 (lambda (a) (+ a 1)))) (do ((i 0 (add1 i))) ((= i 10) (add1 i)))) 11)
(test (do ((i 0 (do ((j 0 (+ j 1))) ((= j i) (+ i 1))))) ((= i 3) i)) 3)
(test (do ((i 0 (do ((i 0 (+ i 1))) ((= i 3) i)))) ((= i 3) i)) 3)
(test (let ((i 123)) (do ((i 0 (+ i 1)) (j i (+ j i))) ((> j 200) i))) 13)
(test (do ((i 0 (+ i 1))) ((> i 3) i) (set! i (* i 10))) 11)
(test (do ((i 123) (j 0 (+ j i))) ((= j 246) i)) 123)
(test (do ((i 123 i) (j 0 (+ j i))) ((= j 246) i)) 123)
(test (do ((i 0 i)) (i i)) 0)
(test (do ((i 1 i)) (i i (+ i i) (+ i i i))) 3)
(test (do ((i 1)) (#t 1) 123) 1)
(test (do ((i 0 (+ i j)) (j 0 (+ j 1))) (#t 1)) 1)
(test (do ((i 0 j) (j 0 (+ j 1))) ((= j 3) i)) 2) ; uh, lessee... lexical scoping...
(test (do ((i 1 j) (j 0 k) (k 0 m) (m 0 (+ i j k))) ((> m 10) (list i j k m))) (list 4 5 8 11))
(test (let ((i 10) (j 11) (k 12)) (do ((i i j) (j j k) (k k m) (m (+ i j k) (+ i j k))) ((> m 100) (list i j k m)))) (list 33 56 78 122))
(test (let ((x 0) (i 3)) (do ((i i (+ i 1))) ((= i 6)) (do ((i i (+ i 1))) ((= i 7)) (set! x (+ x i)))) x) 44)
(test (let () (define (hi) (let ((x 0) (i 3)) (do ((i i (+ i 1))) ((= i 6)) (do ((i i (+ i 1))) ((= i 7)) (set! x (+ x i)))) x)) (hi)) 44)
(test (do ((i 0 (let () (set! j 3) (+ i 1))) (j 0 (+ j 1))) ((= i 3) j)) 4)
(test (let ((i 0)) (do () ((= i 3) (* i 2)) (set! i (+ i 1)))) 6)
(num-test (do ((i 0 (- i 1))) ((= i -3) i)) -3)
(num-test (do ((i 1/2 (+ i 1/2))) ((> i 2) i)) 5/2)
(num-test (do ((i 0.0 (+ i 0.1))) ((>= i 0.9999) i)) 1.0)
(num-test (do ((i 0 (- i 1/2))) ((< i -2) i)) -5/2)
(num-test (do ((i 0+i (+ i 0+i))) ((> (magnitude i) 2) i)) 0+3i)
(test (let ((x 0)) 
	(do ((i 0 (+ i 1)))
	    ((> i 4) x) 
	  (set! x (+ x i))
	  (set! i (+ i 0.5))))
      4.5)
(test (do ((i 0 1)) ((> i 0) i)) 1)
(test (do ((i 1.0+i 3/4)) ((= i 3/4) i)) 3/4)
(test (do ((i 0 "hi")) ((not (number? i)) i)) "hi")
(test (do ((i "hi" 1)) ((number? i) i)) 1)
(test (do ((i #\c "hi")) ((string? i) i)) "hi")
(test (do ((i #\c +)) ((not (char? i)) i)) +)
(test (let ((j 1)) (do ((i 0 j)) ((= i j) i))) 1)
(test (let ((j 1)) (do ((i 0 j)) ((= i j) i) (set! j 2))) 2)
(test (do ((j 1 2) (i 0 j)) ((= i j) i)) 2)
(test (let ((old+ +) (j 0)) (do ((i 0 (old+ i 1))) ((or (< i -3) (> i 3))) (set! old+ -) (set! j (+ j i))) j) -6)
(test (do ((i 0 (case i ((0) 1) ((1) "hi")))) ((string? i) i)) "hi")
(test (do ((i if +)) ((equal? i +) i)) +)
(test (let ((k 0)) (do ((j 0 (+ j 1)) (i 0 ((if (= i 0) + -) i 1))) ((= j 5)) (set! k (+ k i))) k) 2)
(test (let ((j -10) (k 0)) (do ((i 0 (+ i j)) (j 2)) ((> i 4) k) (set! k (+ k i)))) 6)
(test (let ((j -10) (k 0)) (do ((i j (+ i j)) (j 2)) ((> i 4) k) (set! k (+ k i)))) -24)
(test (let ((j -10) (k 0)) (do ((i j (+ i j)) (j 2)) ((= i j) k) (set! k (+ k i)))) -30)
(test (let ((j -10) (k 0)) (do ((i j (+ i j)) (j 2)) ((= i j) j) (set! k (+ k i)))) 2)
(test (let ((equal =)) (do ((i 0 (+ i 1))) ((equal i 3) i))) 3)
(test (let ((equal =)) (do ((i 0 (+ i 1))) ((equal i 3) i) (set! equal >))) 4)
(test (do ((equal =) (i 0 (+ i 1))) ((equal i 3) i)) 3)
(test (do ((equal = >) (i 0 (+ i 1))) ((equal i 3) i)) 4)
(test (do ((j 0) (plus + -) (i 0 (plus i 1))) ((= i -1) j) (set! j (+ j 1))) 3)
(test (let ((expr `(+ i 1))) (do ((j 0) (i 0 (eval expr))) ((= i 3) j) (set! j (+ j 1)))) 3)
(test (let ((expr `(+ i 1))) (do ((j 0) (i 0 (eval expr))) ((= i -3) j) (set! j (+ j 1)) (if (= j 3) (set! expr `(- i 1))))) 7)
(test (do ((i 0 (+ i 1))) ((or (= i 12) (not (number? i)) (> (expt 2 i) 32)) (expt 2 i))) 64)
(test (let ((k 0)) (do ((i 0 (+ i 1))) ((let () (set! k (+ k 1)) (set! i (+ i 1)) (> k 3)) i))) 7)
(num-test (do ((i 0 (+ i 1))) ((> i 3) i) (set! i (* .9 i))) 3.439)
(test (let ((v #(0 0 0))) (do ((i 0 (+ i 1))) ((= i 3) v) (set! (v i) i))) #(0 1 2))
(test (let ((v (list 0 0 0))) (do ((i 0 (+ i 1))) ((= i 3) v) (set! (v i) i))) '(0 1 2))
(test (let ((sum 0)) ((do ((i 0 (+ i 1))) ((> i 64) (lambda () sum)) (set! sum (+ sum i))))) 2080)
(test (do ((lst '() (cons i lst)) (i 0 (+ i 1))) ((> i 6) (reverse lst))) '(0 1 2 3 4 5 6))
(let ()
  (define (d1) (do ((i 0 (+ i 1))) ((= i 10) i)))
  (define (d2) (do ((i 0 (+ i 1))) ((= i 10) i) i))
  (test (d1) 10)
  (test (d1) (d2)))

(test (let ((x (do ((i 0 (+ i 1))) (#t)))) x) '()) ; guile: #<unspecified>

(test (let ((lst '(1 2 3))
	    (v (vector 0 0 0)))
	(do ((l lst (map (lambda (a) (+ a 1)) (cdr l))))
	    ((null? l))
	  (set! (v (- (length l) 1)) (apply + l)))
	v)
      #(5 7 6))

(test (let ((lst '(1 2 3)))
	(map (lambda (a)
	       (let ((! 1))
		 (do ((i 0 (+ i 1))
		      (sum 0))
		     ((= i a) sum)
		   (set! sum (+ sum a)))))
	     lst))
      '(1 4 9))

(test (let ((sum 0)) (do ((i_0 0 (+ i_0 0))(i_1 1 (+ i_1 1))(i_2 2 (+ i_2 2))(i_3 3 (+ i_3 3))(i_4 4 (+ i_4 4))(i_5 5 (+ i_5 5))(i_6 6 (+ i_6 6))(i_7 7 (+ i_7 7))(i_8 8 (+ i_8 8))(i_9 9 (+ i_9 9))(i_10 10 (+ i_10 10))(i_11 11 (+ i_11 11))(i_12 12 (+ i_12 12))(i_13 13 (+ i_13 13))(i_14 14 (+ i_14 14))(i_15 15 (+ i_15 15))(i_16 16 (+ i_16 16))(i_17 17 (+ i_17 17))(i_18 18 (+ i_18 18))(i_19 19 (+ i_19 19))(i_20 20 (+ i_20 20))(i_21 21 (+ i_21 21))(i_22 22 (+ i_22 22))(i_23 23 (+ i_23 23))(i_24 24 (+ i_24 24))(i_25 25 (+ i_25 25))(i_26 26 (+ i_26 26))(i_27 27 (+ i_27 27))(i_28 28 (+ i_28 28))(i_29 29 (+ i_29 29))(i_30 30 (+ i_30 30))(i_31 31 (+ i_31 31))(i_32 32 (+ i_32 32))(i_33 33 (+ i_33 33))(i_34 34 (+ i_34 34))(i_35 35 (+ i_35 35))(i_36 36 (+ i_36 36))(i_37 37 (+ i_37 37))(i_38 38 (+ i_38 38))(i_39 39 (+ i_39 39)))
    ((= i_1 10) sum)
  (set! sum (+ sum i_0 i_1 i_2 i_3 i_4 i_5 i_6 i_7 i_8 i_9 i_10 i_11 i_12 i_13 i_14 i_15 i_16 i_17 i_18 i_19 i_20 i_21 i_22 i_23 i_24 i_25 i_26 i_27 i_28 i_29 i_30 i_31 i_32 i_33 i_34 i_35 i_36 i_37 i_38 i_39))))
      35100)

(let () (define (jtest) (let ((j 0)) (do ((i 0 (+ i 1))) ((= i 10) j) (if (= i 3) (set! j i))))) (test (jtest) 3))
(let () (define (jtest1) (let ((j (vector 0))) (do ((i 0 (+ i 1))) ((= i 10) (j 0)) (if (= i 3) (set! (j 0) i))))) (test (jtest1) 3))
(let () (define (jtest2) (let ((j (vector 0))) (do ((i 0 (+ i 1))) ((= i 10) (j 0)) (if (= i 3) (vector-set! j 0 i))))) (test (jtest2) 3))
(let () (define (jtest3) (let ((j (vector 0))) (do ((i 0 (+ i 1))) ((= i 10) (j 0)) (if (= i 3) (set! (vector-ref j 0) i))))) (test (jtest3) 3))
(let () (define (jtest4) (let ((j (list 0))) (do ((i 0 (+ i 1))) ((= i 10) (j 0)) (if (= i 3) (set! (j 0) i))))) (test (jtest4) 3))
(let () (define (jtest5) (let ((j (list 0))) (do ((i 0 (+ i 1))) ((= i 10) (j 0)) (if (= i 3) (set! (car j) i))))) (test (jtest5) 3))
(let () (define (jtest6) (let ((j (list 0))) (do ((i 0 (+ i 1))) ((= i 10) (j 0)) (if (= i 3) (set-car! j i))))) (test (jtest6) 3))
(let () (define (jtest7) (let ((j (list 0))) (do ((i 0 (+ i 1))) ((= i 10) (j 0)) (if (= i 3) (list-set! j 0 i))))) (test (jtest7) 3))
(let () (define (jtest8) (let ((j #f)) (do ((i 0 (+ i 1))) ((= i 10) (car j)) (if (= i 3) (set! j (list i)))))) (test (jtest8) 3))
(let () (define (jtest9) (let ((j #f)) (do ((i 0 (+ i 1))) ((= i 10) (j 0)) (if (= i 3) (set! j (vector i)))))) (test (jtest9) 3))
(let () (define (jtest10) (let ((j (cons 1 2))) (do ((i 0 (+ i 1))) ((= i 10) j) (if (= i 3) (set-car! j i))))) (test (jtest10) '(3 . 2)))
(let () (define (jtest10a) (let ((j (cons 1 2))) (do ((i 0 (+ i 1))) ((= i 10) j) (if (= i 3) (list-set! j 0 i))))) (test (jtest10a) '(3 . 2)))
(let () (define (jtest11) (let ((j (cons 1 2))) (do ((i 0 (+ i 1))) ((= i 10) j) (if (= i 3) (set! j (cons 0 i)))))) (test (jtest11) '(0 . 3)))
;; (let ((f #f)) (define (jtest12) (do ((i 0 (+ i 1))) ((= i 10) (f)) (if (= i 3) (set! f (lambda () i))))) (test (jtest12) 3))
;; this lambda business is a separate issue (s7 returns 10 here)


(test (let () (define (step-it a) (+ a 1)) (define (hi) (do ((i 0 (step-it i))) ((= i 3) i))) (hi) (hi)) 3)

(test (call-with-exit (lambda (return) (do () () (if #t (return 123))))) 123)
(test (call-with-exit (lambda (return) (do () (#f) (if #t (return 123))))) 123)
(test (call-with-exit (lambda (return) (do ((i 0 (+ i 1))) () (if (= i 100) (return 123))))) 123)
(test (call-with-exit (lambda (return) (do () ((return 123))))) 123)
(test (call-with-exit (lambda (return) (do () (#t (return 123))))) 123)

(test (do () (/ 0)) 0)
(test (do () (+)) '())
(test (do () (+ +) *) +)

(if with-bignums
    (begin
      (num-test (do ((i 24444516448431392447461 (+ i 1))
		     (j 0 (+ j 1)))
		    ((>= i 24444516448431392447471) j))
		10)
      (num-test (do ((i 0 (+ i 24444516448431392447461))
		     (j 0 (+ j 1)))
		    ((>= i 244445164484313924474610) j))
		10)
      (num-test (do ((i 4096 (* i 2))
		     (j 0 (+ j 1)))
		    ((= i 4722366482869645213696) j))
		60)))

(test (do ((i 9223372036854775805 (+ i 1))
	   (j 0 (+ j 1)))
	  ((>= i 9223372036854775807) j))
      2)
(test (do ((i -9223372036854775805 (- i 1))
	   (j 0 (+ j 1)))
	  ((<= i -9223372036854775808) j))
      3)

(num-test (do ((x (list 1 2 3) (cdr x)) (j -1)) ((null? x) j) (set! j (car x))) 3)

(test (let ((x 0)) 
	(do ((i 0 (+ i 1)))
	    ((= i (do ((j 0 (+ j 1))) ((= j 2) (+ j 1)))))
	  (set! x (+ x i)))
	x)
      3)
(test (let ((x 0)) 
	(do ((i 0 (+ i (do ((j 0 (+ j 1))) ((= j 2) 1)))))
	    ((= i 3) x)
	  (set! x (+ x i))))
      3)
(test (let ((x 0)) 
	(do ((i 0 (+ i (do ((j 0 (+ j 1))) ((= j 2) 1)))))
	    ((= i 3) (do ((j 0 (+ j 1))) ((= j 5) x) (set! x j)))
	  (set! x (+ x i))))
      4)

(test (call-with-exit (lambda (exit) (do ((i 0 (+ i 1))) ((= i 100) i) (if (= i 2) (exit 321))))) 321)
(test (call-with-exit (lambda (exit) (do ((i 0 (if (= i 3) (exit 321) (+ i 1)))) ((= i 100) i)))) 321)
(test (call-with-exit (lambda (exit) (do ((i 0 (+ i 1))) ((= i 10) (exit 321))))) 321)
(test (call-with-exit (lambda (exit) (do ((i 0 (+ i 1))) ((= i 10) i) (if (= i -2) (exit 321))))) 10)
(test (do ((x 0 (+ x 1)) (y 0 (call/cc (lambda (c) c)))) ((> x 5) x) #f) 6)
(test (let ((happy #f)) (do ((i 0 (+ i 1))) (happy happy) (if (> i 3) (set! happy i)))) 4)

(test (+ (do ((i 0 (+ i 1))) ((= i 3) i)) (do ((j 0 (+ j 1))) ((= j 4) j))) 7)
(test (do ((i (if #f #f))) (i i)) (if #f #f))
(test (do ((i (if #f #f)) (j #f i)) (j j)) (if #f #f))

(test (let ((cont #f)
	    (j 0)
	    (k 0))
	(call/cc (lambda (exit) 
		   (do ((i 0 (+ i 1))) 
		       ((= i 100) i) 
		     (set! j i)
		     (call/cc (lambda (r) (set! cont r)))
		     (if (= j 2) (exit))
		     (set! k i))))
	(if (= j 2)
	    (begin
	      (set! j 3)
	      (cont))
	    (list j k)))
      (list 99 99))

(test (call/cc (lambda (r) (do () (#f) (r 1)))) 1)
(test (let ((hi (lambda (x) (+ x 1)))) (do ((i 0 (hi i))) ((= i 3) i))) 3)
(test (do ((i 0 (+ i 1))) (list 1) ((= i 3) #t)) 1) ; a typo originally -- Guile and Gauche are happy with it
(test (do () (1 2) 3) 2)

;; from sacla tests
(test (let ((rev (lambda (list)
		   (do ((x list (cdr x))
			(reverse '() (cons (car x) reverse)))
		       ((null? x) reverse)))))
	(and (null? (rev '()))
	     (equal? (rev '(0 1 2 3 4)) '(4 3 2 1 0))))
      #t)

(test (let ((nrev (lambda (list)
		    (do ((f1st (if (null? list) '() (cdr list)) (if (null? f1st) '() (cdr f1st)))
			 (s2nd list f1st)
			 (t3rd '() s2nd))
			((null? s2nd) t3rd)
		      (set-cdr! s2nd t3rd)))))
	(and (null? (nrev '()))
	     (equal? (nrev (list 0 1 2 3 4)) '(4 3 2 1 0))))
      #t)

(test (do ((temp-one 1 (+ temp-one 1))
	   (temp-two 0 (- temp-two 1)))
	  ((> (- temp-one temp-two) 5) temp-one))
      4)

(test (do ((temp-one 1 (+ temp-one 1))
	   (temp-two 0 (+ temp-one 1)))     
	  ((= 3 temp-two) temp-one))
      3)

(let ((vec (vector 0 1 2 3 4 5 6 7 8 9)))
  (test (do ((i 0 (+ 1 i))
	     (n #f)
	     (j 9 (- j 1)))
	    ((>= i j) vec)
	  (set! n (vector-ref vec i))
	  (vector-set! vec i (vector-ref vec j))
	  (vector-set! vec j n))
	'#(9 8 7 6 5 4 3 2 1 0)))

(test (do ((i 0 (+ i 1))) (#t i) (error "do evaluated its body?")) 0)
(test (do '() (#t 1)) 'error)
(test (do . 1) 'error)
(test (do ((i i i)) (i i)) 'error)
(test (do ((i 0 i (+ i 1))) (i i)) 'error)
(test (do ((i)) (#t i)) 'error)
(test (do ((i 0 (+ i 1))) #t) 'error)
(test (do 123 (#t 1)) 'error)
(test (do ((i 1)) (#t . 1) 1) 'error)
(test (do ((i 1) . 1) (#t 1) 1) 'error)
(test (do ((i 1) ()) (= i 1)) 'error)
(test (do ((i 0 . 1)) ((= i 1)) i) 'error)
(test (do ((i 0 (+ i 1))) ((= i 3)) (set! i "hiho")) 'error)
(test (let ((do+ +)) (do ((i 0 (do+ i 1))) ((= i 3)) (set! do+ abs))) 'error)
(test (do () . 1) 'error)
(test (do ((i)) (1 2)) 'error)
(test (do (((i))) (1 2)) 'error)
(test (do ((i 1) ((j))) (1 2)) 'error)
(test (do (((1))) (1 2)) 'error)
(test (do ((pi 1 2)) (#t pi)) 'error)
(test (do ((1+i 2 3)) (#t #t)) 'error)
(test (do ((1.2 2 3)) (#t #t)) 'error)
(test (do (((1 . 2) "hi" (1 2))) (#t 1)) 'error)
(test (do ((() () ())) (#t #t)) 'error)
(test (do (("hi" "hi")) ("hi")) 'error)
(test (do ((:hi 1 2)) (#t :hi)) 'error)
(test (do ((i 0 (abs ()))) ((not (= i 0)) i)) 'error)
(test (do ((i j) (j i)) (i i)) 'error)
(test (do ((i 0 0) . ((j 0 j))) (#t j)) 0)
(test (do ((i 0 1 . 2)) (#t i)) 'error)
(test (do ((i 0 "hi")) ((string? i) . i)) 'error)
(test (do ((i 0 j)) (#t i)) 0) ; guile also -- (do ((i 0 (abs "hi"))) (#t i)) etc (do ((i 0 1)) (#t i) (abs "hi"))
(test (do ((i 0 1) . (j 0 0)) ((= i 1) i) i) 'error)
(test (do ((i 0 1) ((j 0 0)) ((= i 1) i)) i) 'error)
(test (do #f) 'error)
(test (do () #f) 'error)
(test (do () #()) 'error)
(test (do '((i 1)) ()) 'error)
(test (do #() ()) 'error)
(test (do ((#() 1)) ()) 'error)
(test (do ((1)) ()) 'error)
(test (do ((i 1) . #(a 1)) ()) 'error)
(test (do () ((3 4))) 'error)
(test (do ((i 1)) '()) '())
(test (do . (() (#t 1))) 1)
(test (do () . ((#t 1))) 1)
(test (do ((i 1 (+ i 1))) . ((() . ()))) '())

(test (define-constant) 'error)
(test (define-constant _asdf_ 2 3) 'error)
(test (define-constant pi 3) 'error) ; except in Utah
(test (define-constant pi . 3) 'error)
(define-constant __do_step_var_check__ 1)
(test (do ((__do_step_var_check__ 2 3)) (#t #t)) 'error)
(test (let ((__do_step_var_check__ 2)) 1) 'error)
(test (let () (set! __do_step_var_check__ 2)) 'error)
(test (let ((__do_step_var_access_1__ #f))
	(set! (symbol-access '__do_step_var_access_1__) (list #f #f #f))
	(do ((__do_step_var_access_1__ 1 2)) (#t __do_step_var_access_1__)))
      1)

(test (let ((__do_step_var_access_1__ #f))
	(set! (symbol-access '__do_step_var_access_1__) (list #f (lambda (x y) (error "do step var is being set!"))
							      (lambda (x y) (+ y 1))))
	(do ((__do_step_var_access_1__ 1 32)) (#t __do_step_var_access_1__)))
      2) 
(test (do ((hi #3d(((1 2) (3 4)) ((5 6) (7 8))) (hi 1))) ((equal? hi 8) hi)) 8)
(test (do ((i 0 ('((1 2) (3 4)) 0 1))) ((not (= i 0)) i)) 2)
(test (do () (#t (+ 1 2 3))) 6)
(test (do ((f + *) (j 1 (+ j 1))) ((= j 2) (apply f (list j j)))) 4)
(test (do ((f lambda) (j 1 (+ j 1))) ((= j 2) ((f (a) (+ a j)) 3))) 5)

(let ()
  (define-macro (add-1 x) `(+ ,x 1))
  (test (do ((i 0 (add-1 i))) ((= i 3) i)) 3)
  (test (do ((i 0 (add-1 i))) ((= i 3) (add-1 i))) 4))

(test (let ((j #f))
	(do ((i 0 (let ((x 0))
		    (dynamic-wind
			(lambda ()
			  (set! x i))
			(lambda ()
			  (+ x 1))
			(lambda ()
			  (if (> x 3)
			      (set! j #t)))))))
	    (j i)))
      5)
(test (let ((j 0)) (do ((i 0 (eval-string "(+ j 1)"))) ((= i 4) j) (set! j i))) 3)
(test (do ((i (do ((i (do ((i 0 (+ i 1)))
			  ((= i 3) (+ i 1)))
		      (do ((j 0 (+ j 1)))
			  ((= j 3)) (+ j i))))
		  ((> (do ((k 0 (+ k 1)))
			  ((= k 2) (* k 4)))
		      (do ((n 0 (+ n 1)))
			  ((= n 3) n)))
		   (do ((m 0 (+ m 1)))
		       ((= m 3) (+ m i)))))
	      i))
	  ((> i 6) i))
      7)

(test (let ((L (list 1 2))) 
	(do ((sum 0 (+ sum (car lst))) 
	     (i 0 (+ i 1)) 
	     (lst L (cdr lst))) 
	    ((or (null? lst) 
		 (> i 10)) 
	     sum) 
	  (set-cdr! (cdr L) L))) 
      16)

;;; optimizer checks
(num-test (let ((x 0)) (do ((i 1.0 (+ i 1))) ((> i 3)) (set! x (+ x i))) x) 6.0)
(num-test (let ((x 0)) (do ((i 1 4)) ((> i 3)) (set! x (+ x i))) x) 1)
(num-test (let ((x 0)) (do ((i 1 ((if #t + -) i 1))) ((> i 3)) (set! x (+ x i))) x) 6)
(num-test (let ((x 0)) (do ((i 1 (+))) ((> i 0)) (set! x (+ x i))) x) 0)
(num-test (let ((x 0)) (do ((i 1 (+ 1))) ((> i 0)) (set! x (+ x i))) x) 0)
(num-test (let ((x 0)) (do ((i 1 (+ 1 i 2))) ((> i 10)) (set! x (+ x i))) x) 22)
(num-test (let ((x 0)) (do ((i 1 (+ 1.0 i))) ((> i 3)) (set! x (+ x i))) x) 6.0)
(num-test (let ((x 0)) (do ((i 1 (+ 1 pi))) ((> i 2)) (set! x (+ x i))) x) 1)
(num-test (do ((i 0 (+ 1 pi))) ((> i 2) i)) (+ pi 1.0))
(num-test (let ((x 0)) (do ((i 0 (+ i 8796093022208))) ((> i 0)) (set! x (+ x i))) x) 0)
(num-test (let ((x 0)) (do ((i 0 (+ i 8796093022208))) ((> i 17592186044416)) (set! x (+ x i))) x) (+ (expt 2 44) (expt 2 43)))
(num-test (let ((x 0)) (do ((i 1 (* i 2))) ((> i 10)) (set! x (+ x i))) x) 15)
(num-test (do ((i 0 (+ i 1))) ((> i 2) i) (set! i (+ i 3.0))) 4.0)
(num-test (let ((x 0)) (let ((add +)) (do ((i 0 (add i 1))) ((< i -2)) (set! add -) (set! x (+ x i)))) x) -3)
(num-test (let ((equals =) (x 0)) (do ((i 0 (+ i 1))) ((equals i 3) x) (set! x (+ x i)))) 3)
(num-test (let ((equals =) (x 0)) (do ((i 0 (+ i 1))) ((equals i 3) x) (set! x (+ x i)) (set! i (* i 1.0)))) 3.0)
(num-test (let ((equals =) (x 0)) (do ((i 0 (+ i 1))) ((equals i 3) x) (set! x (+ x i)) (set! equals >))) 6)
(num-test (let ((equals =) (x 0)) (do ((i 0 (+ i 1))) ((equals i 3) x) (set! x (+ x i)) (set! equals =))) 3)
(num-test (let ((equals =) (x 0)) (do ((i 0 (+ i 1))) ((equals i 3) (set! x (+ x 1)) x) (set! x (+ x i)) (set! equals =))) 4)
(num-test (do ((i 0 (+ i 1))) ((> i 3) i) (set! i (expt 2 60))) (+ 1 (expt 2 60)))
(num-test (let ((x 0) (n 3)) (do ((i 0 (+ i 1))) ((= i n) x) (set! x (+ x i)))) 3)
(num-test (let ((x 0) (n 3)) (do ((i 0 (+ i 1))) ((= 1 1) x) (set! x (+ x i)))) 0)
(num-test (let ((x 0) (n (expt 2 50))) (do ((i 0 (+ i n))) ((= i (expt 2 51)) x) (set! x (+ x i)))) (expt 2 50))
(num-test (let ((x 0) (n 31.0)) (do ((i 0 (+ i 1))) ((= i n) x) (set! x (+ x i)) (set! n 3))) 3)
(num-test (let ((x 0)) (do ((i 0 (+ i 1/2))) ((= i 3) x) (set! x (+ x i)))) 15/2)
(num-test (let ((x 0)) (do ((i 0 (+ i 1+i))) ((> (magnitude i) 3) x) (set! x (+ x i)))) 3+3i)
(num-test (call-with-exit (lambda (r) (do () () (r 1)))) 1)
(num-test (call-with-exit (lambda (r) (do () (#t 10 14) (r 1)))) 14)
(num-test (do ((i 0 (+ i 1))) (#t 10 12)) 12)
(num-test (do ((i 0 (+ i 1))) ((= i 3) i)) 3)
(num-test (do ((i 0 (+ i 1))) ((> i 3) i)) 4)
(num-test (do ((i 0 (+ i 1))) ((< i 3) i)) 0)
(num-test (do ((i 0 (+ i 1))) ((<= i 3) i)) 0)
(num-test (do ((i 0 (+ i 1))) ((>= i 3) i)) 3)
(num-test (do ((i 0 (+ i 1))) ((>= 3 i) i)) 0)
(num-test (do ((i 0 (+ i 1))) ((> 3 i) i)) 0)
(num-test (do ((i 0 (+ i 1))) ((< 3 i) i)) 4)
(num-test (do ((i 0 (+ i 1))) ((<= 3 i) i)) 3)
(num-test (let ((n 3)) (do ((i 0 (+ i 1))) ((> i n) i))) 4)
(num-test (let ((n 3)) (do ((i 0 (+ i 1))) ((< n i) i))) 4)
(num-test (do ((i 10 (- i 1))) ((= i 0) i)) 0)
(num-test (do ((i 10 (- 1 i))) ((< i 0) i)) -9)
(num-test (do ((i 10 (- i 3))) ((< i 0) i)) -2)
(let () (define (hi) (do ((i 1 (+ 1 i))) ((= i 1) i))) (hi) (test (hi) 1))
(let () (define (hi) (do ((i 10 (+ i 1))) ((= i 10) i) (abs i))) (hi) (test (hi) 10))
(let ((sum 0)) (define (hi) (do ((i 10 (+ i 1))) ((= i 10) i) (set! sum (+ sum i)))) (hi) (test (hi) 10))
(let () (define (hi a) (do ((i a (+ i 1))) ((= i a) i) (+ a 1))) (hi 1) (test (hi 1) 1))

;;; check an optimizer bug
(define _do_call_cc_end_ 1)
(define (call-cc-do-test)
  (do ((i 0 (+ i 1)))
      ((= i _do_call_cc_end_))
    (let ((ctr 0)) 
      (call/cc (lambda (exit) 
		 (if (> 3 2) 
		     (let () 
		       (exit ctr) 
		       (set! ctr 100) ctr) 
		     #f)))))
  (do ((i 0 (+ 1 i)))
      ((= i _do_call_cc_end_))
    (let ((ctr 0)) 
      (call/cc (lambda (exit) 
		 (if (> 3 2) 
		     (let () 
		       (exit ctr) 
		       (set! ctr 100) ctr) 
		     #f))))))
(call-cc-do-test)

;;; and another
(let()
  (define (hi)
    (let ((checker (lambda (nlst v)
		     (let ((chr (car nlst)))
		       (if (not (char-alphabetic? chr))
			   (if (not (char=? v chr))
			       (format #t ";(char-downcase #\\~A) -> ~A" chr v))
			   (if (and (not (char=? chr v))
				    (not (char=? chr (char-upcase v))))
			       (format #t ";(char-downcase #\\~A) -> ~A~%" chr v))))))
	  (result 0))
      (let ((try 0))
	(do ((i 0 (+ i 1)))
	    ((> i 10))
	  (set! try i)
	  (checker '(#\a) #\a)
	  (checker '(#\a) #\a)))))
  (test (hi) '()))

(define (__a-func__ a)
  (format #t ";oops called first a-func by mistake: ~A~%" a)
  (if (> a 0)
      (__a-func__ (- a 1))))

(define (__a-func__ a)
  (if (> a 0)
      (__a-func__ (- a 1))))

(__a-func__ 3)

(define (__c-func__ a)
  (format #t ";oops called first __c-func__ by mistake: ~A~%" a)
  (if (> a 0)
      (__c-func__ (- a 1))))
  
(let ()
  (define (__c-func__ a)
    (if (> a 0)
	(__c-func__ (- a 1))))
  
  (__c-func__ 3))

;;; more optimizer checks
(let () 
  (define (do-test-1) (do ((i 0 (+ i 1))) ((= i 10)) (display i)))
  (test (with-output-to-string (lambda () (do-test-1))) "0123456789"))

(let () 
  (define (do-test-2) (do ((i 0 (+ 1 i))) ((= i 10)) (display i))) 
  (test (with-output-to-string (lambda () (do-test-2))) "0123456789"))

(let ((start 0)) 
  (define (do-test-3) (do ((i start (+ i 1))) ((= i 10)) (display i))) 
  (test (with-output-to-string (lambda () (do-test-3))) "0123456789"))

(let ((start 0) (end 10)) 
  (define (do-test-4) (do ((i start (+ i 1))) ((= i end)) (display i))) 
  (test (with-output-to-string (lambda () (do-test-4))) "0123456789"))

(let ((start 0) (end 10)) 
  (define (do-test-5) (do ((i start (+ i 1))) ((= end i)) (display i))) 
  (test (with-output-to-string (lambda () (do-test-5))) "0123456789"))

(let () 
  (define (do-test-6) (do ((i 0 (+ i 1))) ((= i 10)) (let ((k i)) (display k)))) 
  (test (with-output-to-string (lambda () (do-test-6))) "0123456789"))

(let () 
  (define (do-test-7) (do ((i 0 (+ i 2))) ((= i 20)) (display (/ i 2)))) 
  (test (with-output-to-string (lambda () (do-test-7))) "0123456789"))

(let () 
  (define (do-test-8) (do ((i 0 (+ i 1))) ((= i 10)) (let ((a (+ 1 2))) (display #\0)))) 
  (test (with-output-to-string (lambda () (do-test-8))) "0000000000"))

(let () 
  (define (do-test-9) (do ((i 0 (+ i 1))) ((= i 10)) (let ((j 0)) (set! j i) (display j)))) 
  (test (with-output-to-string (lambda () (do-test-9))) "0123456789"))

(let () 
  (define (do-test-10) (do ((i 0 (+ i 1))) ((= i 10)) (let ((j 0)) (display i)))) 
  (test (with-output-to-string (lambda () (do-test-10))) "0123456789"))

(let () 
  (define (do-test-11) (do ((i 0 (+ i 1))) ((= i 10)) (let ((j 0)) (set! j 32) (display i)))) 
  (test (with-output-to-string (lambda () (do-test-11))) "0123456789"))

(let ()
  (define (do-test-12) (do ((i 0 (+ i 1))) ((= i 10)) (let ((j i)) (display j)))) 
  (test (with-output-to-string (lambda () (do-test-12))) "0123456789"))

(let () 
  (define (do-test-13) (do ((i 0 (+ i 1))) ((= i 5)) (let ((j (+ i 1))) (let ((i j)) (display (- i 1)))))) 
  (test (with-output-to-string (lambda () (do-test-13))) "01234"))

(let () 
  (define (do-test-14) (do ((i 0 (+ i 1))) ((= i 10)) (set! i (+ i 1)) (display i))) 
  (test (with-output-to-string (lambda () (do-test-14))) "13579"))

(let ((lst '()))
  (define (do-test-15) (do ((i 0 (+ i 1))) ((= i 10)) (set! lst (cons i lst))) lst) 
  (test (do-test-15) '(9 8 7 6 5 4 3 2 1 0)))

(let ((lst (list 9 8 7 6 5 4 3 2 1 0))) 
  (define (do-test-16) (do ((i 0 (+ i 1))) ((= i 10)) (list-set! lst i i)) lst) 
  (test (do-test-16) '(0 1 2 3 4 5 6 7 8 9)))

(let ((lst '())) 
  (define (do-test-17) (do ((i 0 (+ i 1))) ((= i 10)) (let ((j i)) (set! lst (cons j lst)))) lst) 
  (test (do-test-17) '(9 8 7 6 5 4 3 2 1 0)))

(let ((lst '())) 
  (define (do-test-17a) (do ((i 0 (+ i 1))) ((= i 10)) (let ((j (min i 100))) (set! lst (cons j lst)))) lst) 
  (test (do-test-17a) '(9 8 7 6 5 4 3 2 1 0)))

(let () 
  (define (do-test-18) (do ((i 0 (+ i 1)) (j 0)) ((= i 10) j) (if (= i 3) (set! j i))))
  (test (do-test-18) 3))

(let ((end 10)) 
  (define (do-test-19) (do ((i 0 (+ i 1))) ((= i end)) (display i))) 
  (test (with-output-to-string (lambda () (do-test-19))) "0123456789"))

(let ((end 10)) 
  (define (do-test-19A) (do ((i 0 (+ 1 i))) ((= end i)) (display i))) 
  (test (with-output-to-string (lambda () (do-test-19A))) "0123456789"))

(let ((end 10)) 
  (define (do-test-20) (do ((i 0 (+ i 1))) ((= i end)) (set! end 8) (display i))) 
  (test (with-output-to-string (lambda () (do-test-20))) "01234567"))

(let ((end 10)) 
  (define (do-test-20A) (do ((i 0 (+ 1 i))) ((= end i)) (set! end 8) (display i))) 
  (test (with-output-to-string (lambda () (do-test-20A))) "01234567"))

(let () 
  (define (do-test-21) (do ((i 0 (+ i 1))) ((= i 3)) (with-environment (global-environment) (+ 1 2)))) 
  (do-test-21))

(let ((v (vector 0 0 0))) 
  (define (hi a) (do ((i 0 (+ i 1))) ((> i a)) (vector-set! v i 1))) (hi 2) 
  (test v (vector 1 1 1)))

(let () ; dotimes_c_c case can't involve set so we use write-char
  (define (hi a) 
    (do ((i 0 (+ i 1))) 
	((= i a)) 
      (write-char #\a))) 
  (with-output-to-file "tmp1.r5rs" 
    (lambda () 
      (hi 3)))
  (let ((str (with-input-from-file "tmp1.r5rs" 
	       (lambda () 
		 (read-line)))))
    (test str "aaa")))

(let ()
  (define (do-test-22) (do ((i 0 (+ i 1))) ((= i 10)) (display i)))
  (test (with-output-to-string (lambda () (do-test-22))) "0123456789"))

(let ((v (make-list 10)))
  (define (do-test-23) (do ((i 0 (+ i 1))) ((= i 10)) (list-set! v i i)))
  (do-test-23) 
  (test v '(0 1 2 3 4 5 6 7 8 9)))

;;; safe simple h_safe_c_s
(let ()
  (define (do-test-24) (do ((i 0 (+ i 1))) ((> i 10)) (display i)))
  (test (with-output-to-string (lambda () (do-test-24))) "012345678910"))

;;; safe simple h_safe_c_ss
(let ()
  (define (do-test-25 p) (do ((i 0 (+ i 1))) ((> i 10)) (display i p)))
  (test (call-with-output-string (lambda (p) (do-test-25 p))) "012345678910"))

;;; safe simple h_safe_c_c
(let ()
  (define (do-test-26) (do ((i 0 (+ i 1))) ((> i 10)) (display 0)))
  (test (with-output-to-string (lambda () (do-test-26))) "00000000000"))

;;; safe simple h_safe_c_opsq_s
(let ()
  (define (do-test-27 p) (do ((i 0 (+ i 1))) ((> i 10)) (display (- i) p)))
  (test (call-with-output-string (lambda (p) (do-test-27 p))) "0-1-2-3-4-5-6-7-8-9-10"))

(let ()
  (define (do-test-22 i o) (catch #t (lambda () (do () () (write-char (read-char i) o))) (lambda err (get-output-string o))))
  (test (call-with-output-string (lambda (out) (call-with-input-string "0123" (lambda (in) (do-test-22 in out))))) "0123"))
