(test (defined? 'pi) #t)
(test (defined? 'pi (global-environment)) #t)
(test (defined? 'abs (global-environment)) #t)
(test (defined? 'abs (current-environment)) #t)
(test (let ((__c2__ 32)) (defined? '__c2__)) #t)
(test (let ((__c2__ 32)) (defined? '__c2__ (current-environment))) #t)
(test (let ((__c2__ 32)) (defined? '__c3__ (current-environment))) #f)
(test (let ((__c2__ 32)) (defined? '__c2__ (global-environment))) #f)
(test (let ((__c2__ 32)) (defined? '__c3__ (global-environment))) #f)
(test (defined?) 'error)
(test (defined? 'a 'b) 'error)
(for-each
 (lambda (arg)
   (test (defined? arg) 'error)
   (test (defined? 'abs arg) 'error))
 (list -1 #\a 1 _ht_ '#(1 2 3) 3.14 3/4 1.0+1.0i '() #f '#(()) (list 1 2 3) '(1 . 2) "hi"))
(test (defined? 'lambda car) 'error)
(test (defined? lambda gensym) 'error)
(test (defined? 'lambda defined?) 'error)
(test (defined? 'define car) 'error)
(test (defined? 'abs (augment-environment '())) #t) ; nil = global now
(test (defined? lambda) 'error)
(test (defined? 'lambda) #t)
(test (defined? 'dynamic-wind) #t)
(test (defined? 'asdaf) #f)
;(test (defined? ':asdaf) #f) ; keywords are defined in the sense that they evaluate to themselves
;(test (defined? :asdaf) #f)
(test (defined? 'ok?) #t)
(test (defined? 'test-t) #t)
(test (defined? 'quasiquote) #t)
(test (defined? (symbol "123")) #f)
(test (defined? (symbol "+")) #t)
(test (defined? ''+) 'error)
(test (defined? 'if) #t)
(test (defined? if) 'error)
(test (defined? quote) 'error)

(test (let ((b 2))
	(let ((e (current-environment)))
	  (let ((a 1))
	    (if (defined? 'a e)
		(format #f "a: ~A in ~{~A ~}" (symbol->value 'a e) e)))))
      #<unspecified>) ; not "a: 1 in (b . 2)")

(test (let ((b 2))
	(let ((e (current-environment)))
	  (let ((a 1))
	    (format #f "~A: ~A" (defined? 'abs e) (eval '(abs -1) e)))))
      "#t: 1")
